import * as SourceFiles from '@contentlayer/source-files';
import { casesHandled, isReadonlyArray, notImplemented, pick } from '@contentlayer/utils';
import { identity } from '@contentlayer/utils/effect';
export const stackbitDocumentLikeModelToDocumentType = (ctx) => (stackbitModel) => {
    return SourceFiles.defineDocumentType(() => ({
        name: stackbitModel.name,
        description: stackbitModel.description,
        fields: (stackbitModel.fields ?? []).map(stackbitFieldToField(ctx)),
        isSingleton: stackbitModel.type === 'config' || stackbitModel.singleInstance === true,
    }));
};
export const stackbitObjectModelToDocumentType = (ctx) => (stackbitModel) => {
    return SourceFiles.defineNestedType(() => ({
        name: stackbitModel.name,
        description: stackbitModel.description,
        fields: (stackbitModel.fields ?? []).map(stackbitFieldToField(ctx)),
    }));
};
const stackbitFieldToField = (ctx) => (stackbitField) => {
    const commonFields = {
        ...pick(stackbitField, ['name', 'description', 'required']),
        // TODO don't map Stackbit `default` to Contentlayer `default`
        // See https://github.com/contentlayerdev/contentlayer/issues/120
        default: stackbitField.default,
    };
    switch (stackbitField.type) {
        case 'boolean':
        case 'number':
            return identity({ ...commonFields, type: stackbitField.type });
        case 'enum':
            return identity({
                ...commonFields,
                type: 'enum',
                options: stackbitField.options.map(mapStackbitEnumOption),
            });
        case 'style':
            return identity({ ...commonFields, type: 'json' });
        case 'list': {
            const of = stackbitListItemToListFieldDef(ctx)(stackbitField.items);
            return isReadonlyArray(of)
                ? identity({
                    ...commonFields,
                    type: 'list',
                    of,
                    typeField: 'type',
                })
                : identity({ ...commonFields, type: 'list', of });
        }
        case 'reference': {
            const of = stackbitField.models.map((modelName) => ctx.documentTypeMap[modelName]);
            if (of.length === 1) {
                return identity({ ...commonFields, type: 'reference', of: of[0] });
            }
            return identity({
                ...commonFields,
                type: 'reference',
                of,
                typeField: 'type',
            });
        }
        case 'model': {
            const of = stackbitField.models.map((modelName) => ctx.nestedTypeMap[modelName]);
            if (of.length === 1) {
                return identity({ ...commonFields, type: 'nested', of: of[0] });
            }
            return identity({
                ...commonFields,
                type: 'nested',
                of,
                typeField: 'type',
            });
        }
        case 'object': {
            const unnamedNestedTypeDef = identity({
                fields: stackbitField.fields.map(stackbitFieldToField(ctx)),
            });
            return identity({
                ...commonFields,
                type: 'nested',
                of: { type: 'nested', def: () => unnamedNestedTypeDef },
            });
        }
        case 'markdown':
            return identity({ ...commonFields, type: 'markdown' });
        case 'json':
            return identity({ ...commonFields, type: 'json' });
        case 'image':
            return identity({ ...commonFields, type: 'image' });
        case 'datetime':
        case 'date':
            return identity({ ...commonFields, type: 'date' });
        case 'string':
        case 'url':
        case 'text':
        case 'color':
        case 'slug':
        case 'html':
        case 'file':
            return identity({ ...commonFields, type: 'string' });
        case 'richText':
        case 'cross-reference':
            notImplemented(`richText doesn't exist in the "files" content source`);
        default:
            casesHandled(stackbitField);
    }
};
const stackbitListItemToListFieldDef = (ctx) => (stackbitListItem) => {
    switch (stackbitListItem.type) {
        case 'boolean':
        case 'string':
        case 'number':
            return identity({ type: stackbitListItem.type });
        case 'enum':
            return identity({
                type: 'enum',
                options: stackbitListItem.options.map(mapStackbitEnumOption),
            });
        case 'reference':
            return firstArrayItemIfOne(stackbitListItem.models.map((modelName) => identity(ctx.documentTypeMap[modelName])));
        case 'model':
            return firstArrayItemIfOne(stackbitListItem.models.map((modelName) => identity(ctx.nestedTypeMap[modelName])));
        case 'object':
            return identity({
                type: 'nested',
                def: () => ({ fields: stackbitListItem.fields.map(stackbitFieldToField(ctx)) }),
            });
        case 'date':
        case 'datetime':
            return identity({ type: 'date' });
        case 'json':
            return identity({ type: 'json' });
        case 'markdown':
            return identity({ type: 'markdown' });
        case 'image':
            return identity({ type: 'image' });
        case 'url':
        case 'text':
        case 'color':
        case 'slug':
        case 'html':
        case 'file':
            return identity({ type: 'string' });
        case 'richText':
        case 'cross-reference':
            notImplemented(`richText doesn't exist in the "files" content source`);
        default:
            casesHandled(stackbitListItem);
    }
};
const mapStackbitEnumOption = (option) => {
    if (typeof option === 'string' || typeof option === 'number') {
        return option.toString();
    }
    return option.value.toString();
};
const firstArrayItemIfOne = (array) => (array.length === 1 ? array[0] : array);
//# sourceMappingURL=mapping.js.map