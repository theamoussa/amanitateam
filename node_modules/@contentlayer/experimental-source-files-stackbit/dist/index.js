import { defineDocumentType, defineNestedType } from '@contentlayer/source-files';
import { mergeDeep, not, partition, pick } from '@contentlayer/utils';
import * as Stackbit from '@stackbit/sdk';
import { validateAndNormalizeConfig } from '@stackbit/sdk/dist/config/config-loader.js';
import { stackbitDocumentLikeModelToDocumentType, stackbitObjectModelToDocumentType } from './mapping.js';
/**
 * @example
 * ```ts
 * // contentlayer.config.ts
 * import { makeSource } from 'contentlayer/source-files'
 * import { loadStackbitConfigAsDocumentTypes } from '@contentlayer/experimental-source-files-stackbit'
 *
 * // Looks for `stackbit.yaml` in the current directory
 * export default loadStackbitConfigAsDocumentTypes().then((documentTypes) => {
 *   return makeSource({ contentDirPath: 'content', documentTypes })
 * })
 * ```
 */
export const loadStackbitConfigAsDocumentTypes = (options = { dirPath: '' }, overrideArgs = { documentTypes: {}, nestedTypes: {} }) => Stackbit.loadConfig(options).then((configResult) => {
    if (configResult.errors.length > 0) {
        throw new Error(configResult.errors.join('\n'));
    }
    return stackbitConfigToDocumentTypes(configResult.config, overrideArgs);
});
/**
 *
 * @example
 * ```ts
 * // contentlayer.config.ts
 * import { makeSource } from 'contentlayer/source-files'
 * import { stackbitConfigToDocumentTypes } from '@contentlayer/source-files-stackbit'
 * import stackbitConfig from './stackbit.config.js'
 *
 * const documentTypes = stackbitConfigToDocumentTypes(stackbitConfig)
 *
 * export default makeSource({ contentDirPath: 'content', documentTypes })
 * ```
 */
export const stackbitConfigToDocumentTypes = (stackbitConfig, overrideArgs = { documentTypes: {}, nestedTypes: {} }) => {
    const validatedStackbitConfig = validateStackbitConfig(stackbitConfig);
    // NOTE File-based content sources don't have image models
    const models = validatedStackbitConfig.models.filter(not(isImageModel));
    const [documentLikeModels, objectModels] = partition(models, isDocumentLikeModel);
    const ctx = { documentTypeMap: {}, nestedTypeMap: {} };
    const documentTypes = documentLikeModels.map(stackbitDocumentLikeModelToDocumentType(ctx));
    objectModels.forEach((model) => {
        const nestedType = stackbitObjectModelToDocumentType(ctx)(model);
        ctx.nestedTypeMap[model.name] = nestedType;
        const nestedOverride = overrideArgs.nestedTypes?.[model.name];
        const fields = nestedType.def().fields;
        if (nestedOverride?.fields && fields) {
            for (const [fieldName, { type }] of Object.entries(nestedOverride.fields)) {
                const fieldDef = Array.isArray(fields)
                    ? fields.find((fieldDef) => fieldDef.name === fieldName)
                    : fields[fieldName];
                if (fieldDef) {
                    fieldDef.type = type;
                }
            }
            patchNestedType(nestedType, { fields });
        }
    });
    documentTypes.forEach((documentType) => {
        const documentTypeName = documentType.def().name;
        ctx.documentTypeMap[documentTypeName] = documentType;
        const documentOverride = overrideArgs.documentTypes?.[documentTypeName];
        if (documentOverride?.filePathPattern !== undefined || documentOverride?.computedFields !== undefined) {
            patchDocumentType(documentType, pick(documentOverride, ['filePathPattern', 'computedFields']));
        }
        const fields = documentType.def().fields;
        if (documentOverride?.fields && fields) {
            for (const [fieldName, { type }] of Object.entries(documentOverride.fields)) {
                const fieldDef = Array.isArray(fields)
                    ? fields.find((fieldDef) => fieldDef.name === fieldName)
                    : fields[fieldName];
                if (fieldDef) {
                    fieldDef.type = type;
                }
            }
            patchDocumentType(documentType, { fields });
        }
    });
    return documentTypes;
};
const patchDocumentType = (documentType, patch) => {
    const previousDef = documentType.def();
    documentType.def = defineDocumentType(() => mergeDeep({ ...previousDef, ...patch })).def;
};
const patchNestedType = (nestedType, patch) => {
    const previousDef = nestedType.def();
    nestedType.def = defineNestedType(() => mergeDeep({ ...previousDef, ...patch })).def;
};
const validateStackbitConfig = (stackbitConfig) => {
    if (Array.isArray(stackbitConfig.models)) {
        return stackbitConfig;
    }
    const stackbitConfigResult = validateAndNormalizeConfig(stackbitConfig);
    if (stackbitConfigResult.errors.length > 0) {
        throw new Error(stackbitConfigResult.errors.join('\n'));
    }
    return stackbitConfigResult.config;
};
const isDocumentLikeModel = (model) => model.type === 'data' || model.type === 'page' || model.type === 'config';
const isImageModel = (model) => model.type === 'image';
//# sourceMappingURL=index.js.map