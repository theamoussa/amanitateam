import _ from 'lodash';
import * as ContentSourceTypes from '@stackbit/types';
import { ReleaseProps, ScheduledActionProps } from 'contentful-management';
import { ScheduledAction, ScheduledActionState } from '@stackbit/types';

export function findScheduleForRelease(contentfulSchedulesForEntity: ScheduledActionProps[]) {
    if (!contentfulSchedulesForEntity?.length) {
        return null;
    }
    // find closest future schedule for release, or the last past schedule.
    // contentfulSchedulesForEntity are assumed to be sorted by scheduledFor.datetime.
    const now = new Date();
    return contentfulSchedulesForEntity.find((schedule) => now.toISOString() < schedule.scheduledFor.datetime) || _.last(contentfulSchedulesForEntity);
}

export function convertAndFilterScheduledActions(
    contentfulReleases: ReleaseProps[],
    contentfulSchedules: ScheduledActionProps[]
): ContentSourceTypes.ScheduledAction[] {
    const schedulesByEntity = _.groupBy(_.sortBy(contentfulSchedules, ['scheduledFor.datetime']), 'entity.sys.id');
    const allScheduledActions = [];
    for (const contentfulRelease of contentfulReleases) {
        const releaseSchedule = findScheduleForRelease(schedulesByEntity[contentfulRelease.sys.id] ?? []);
        if (releaseSchedule) {
            allScheduledActions.push(convertScheduledAction(contentfulRelease, releaseSchedule!));
        }
    }
    return filterScheduledActions(allScheduledActions);
}
export function convertScheduledAction(contentfulRelease: ReleaseProps, contentfulSchedule: ScheduledActionProps): ContentSourceTypes.ScheduledAction {
    return {
        id: contentfulRelease.sys.id,
        name: contentfulRelease.title,
        state: getScheduledActionState(contentfulSchedule),
        action: contentfulSchedule.action,
        createdAt: contentfulRelease.sys.createdAt,
        createdBy: contentfulRelease.sys.createdBy.sys.id,
        executeAt: contentfulSchedule.scheduledFor.datetime,
        documentIds: contentfulRelease.entities.items.map((doc) => doc.sys.id)
    };
}

export function filterScheduledActions(scheduledActions: ScheduledAction[]) {
    const cutoffDate = new Date();
    cutoffDate.setMonth(cutoffDate.getMonth() - 1);
    const cutoffDateStr = cutoffDate.toISOString();
    return scheduledActions.filter(
        (scheduledAction: ScheduledAction) => scheduledAction.state !== 'cancelled' && scheduledAction.executeAt.localeCompare(cutoffDateStr) > 0
    );
}

function getScheduledActionState(contentfulSchedule: ScheduledActionProps): ScheduledActionState {
    if (contentfulSchedule.sys.status === 'inProgress') {
        return 'executing';
    }
    if (contentfulSchedule.sys.status === 'canceled') {
        return 'cancelled';
    }
    return contentfulSchedule.sys.status;
}
