import type * as StackbitTypes from '@stackbit/types';
/**
 * Takes object of UpdateOperationField and creates a new object by mapping the
 * UpdateOperationField to DocumentField.
 *
 * @param updateOperationFields
 * @param modelName
 * @param getModelByName
 * @param locale
 */
export declare function createDocumentFieldsWithUpdateOperationFields({ updateOperationFields, modelName, getModelByName, locale }: {
    updateOperationFields: Record<string, StackbitTypes.UpdateOperationField>;
    modelName: string;
    getModelByName: (modelName: string) => StackbitTypes.Model | undefined;
    locale?: string;
}): Record<string, StackbitTypes.DocumentField>;
/**
 * Updates `document` with array of `UpdateOperation`.
 *
 * This method doesn't mutate the passed `document`, it returns a new deep copied
 * document with the updated data.
 *
 * @param document
 * @param operations
 * @param getModelByName
 */
export declare function updateDocumentWithOperations({ document, operations, getModelByName }: {
    document: StackbitTypes.Document;
    operations: StackbitTypes.UpdateOperation[];
    getModelByName: (modelName: string) => StackbitTypes.Model | undefined;
}): StackbitTypes.Document;
/**
 * Updates `document` with `updateOperation`.
 *
 * This method doesn't mutate the passed `document`, it returns a new deep copied
 * document with the updated data.
 *
 * @param document
 * @param updateOperation
 * @param getModelByName
 */
export declare function updateDocumentWithOperation({ document, updateOperation, getModelByName }: {
    document: StackbitTypes.Document;
    updateOperation: StackbitTypes.UpdateOperation;
    getModelByName: (modelName: string) => StackbitTypes.Model | undefined;
}): StackbitTypes.Document;
//# sourceMappingURL=update-document-operation.d.ts.map