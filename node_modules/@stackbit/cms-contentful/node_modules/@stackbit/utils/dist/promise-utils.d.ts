export declare function forEachPromise<T>(array: T[], callback: (value: T, index: number, array: T[]) => Promise<any>, thisArg?: any): Promise<void>;
export declare function mapPromise<T, U>(array: T[], callback: (value: T, index: number, array: T[]) => Promise<U>, thisArg?: any): Promise<U[]>;
export declare function mapValuesPromise<T extends object, U>(object: T, callback: (value: T[keyof T], key: string, object: T) => Promise<U>, thisArg?: any): Promise<Record<string, U>>;
export declare function reducePromise<T, U>(array: T[], callback: (accumulator: U, currentValue: T, currentIndex: number, array: T[]) => Promise<U>, initialValue: U, thisArg?: any): Promise<U>;
export declare function findPromise<T>(array: T[], callback: (value: T, index: number, array: T[]) => Promise<boolean>, thisArg?: any): Promise<T | undefined>;
export interface DeferredPromise<T> {
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
    promise: Promise<T>;
}
export declare function deferredPromise<T>(): DeferredPromise<T>;
/**
 * Creates a function that is restricted to invoking `func` serially. Subsequent
 * calls to the function while the previous `func` call is being resolved, defer
 * invoking the `func` until the previous call is resolved. The deferred `func`
 * is invoked with the last arguments provided to the created function. All
 * subsequent calls to the function are resolved simultaneously with the result
 * of the last `func` invocation.
 *
 * The `options.groupResolver` function allows separating deferred calls into
 * groups based on the arguments provided to the created function.
 *
 * The `options.argsResolver` function allows controlling the arguments passed
 * to the deferred `func`.
 *
 * @example
 * const defFunc = deferOnceWhileRunning(origFunc);
 *
 *                          defFunc(z)
 *              defFunc(y)      ↓
 *  defFunc(x)      ↓           o---------------------------●
 *      ↓           o---------------------------------------●
 *      o--------------------------------●                  ↑
 *      ↓                                ↑                  ↑
 * -----o================================●-o================●----->
 *      ↑                                  ↑
 *  origFunc(x)                        origFunc(z)
 */
export declare function deferWhileRunning<R, T extends (...args: any) => Promise<R>>(func: T, options?: {
    thisArg?: any;
    groupResolver?: (...args: Parameters<T>) => string;
    argsResolver?: ({ nextArgs, prevArgs }: {
        nextArgs: Parameters<T>;
        prevArgs: Parameters<T> | null;
    }) => Parameters<T>;
    debounceDelay?: number;
    debounceMaxDelay?: number;
}): T;
//# sourceMappingURL=promise-utils.d.ts.map