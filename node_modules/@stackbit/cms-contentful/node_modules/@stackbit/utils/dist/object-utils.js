"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncMapDeep = exports.deepMap = exports.undefinedIfEmpty = exports.omitByUndefined = exports.omitByNil = exports.rename = exports.copyIfNotSet = exports.copy = exports.concat = exports.prepend = exports.append = exports.getFirst = void 0;
const lodash_1 = __importDefault(require("lodash"));
/**
 * Gets the value at the first path of object having non undefined value.
 * If all paths resolve to undefined values, the defaultValue is returned.
 *
 * @param object
 * @param paths
 * @param defaultValue
 */
function getFirst(object, paths, defaultValue) {
    const result = (0, lodash_1.default)(object).at(paths).reject(lodash_1.default.isUndefined).first();
    return lodash_1.default.isUndefined(result) ? defaultValue : result;
}
exports.getFirst = getFirst;
/**
 * Appends the `value` to the end of the array located at the specified `path` in
 * the provided `object`. If array at the specified `path` doesn't exist, the
 * function creates a new array with a single `value` item.
 *
 * @param object
 * @param path
 * @param value
 */
function append(object, path, value) {
    if (!lodash_1.default.has(object, path)) {
        lodash_1.default.set(object, path, []);
    }
    lodash_1.default.get(object, path).push(value);
}
exports.append = append;
/**
 * Prepends the `value` to the beginning of the array located at the specified
 * `path` in the provided `object`. If array at the specified `path` doesn't
 * exist, the function creates a new array with a single `value` item.
 *
 * @param object
 * @param path
 * @param value
 */
function prepend(object, path, value) {
    if (!lodash_1.default.has(object, path)) {
        lodash_1.default.set(object, path, []);
    }
    lodash_1.default.get(object, path).unshift(value);
}
exports.prepend = prepend;
/**
 * Concatenates the `value` with an array located at the specified `path` in the
 * provided `object`. If array at the specified `path` doesn't exist, the
 * function creates a new array and concatenates it with `value`.
 *
 * @param object
 * @param path
 * @param value
 */
function concat(object, path, value) {
    if (!lodash_1.default.has(object, path)) {
        lodash_1.default.set(object, path, []);
    }
    const result = lodash_1.default.get(object, path).concat(value);
    lodash_1.default.set(object, path, result);
}
exports.concat = concat;
/**
 * Copies the value from the `sourceObject` at the specified `sourcePath` to
 * the `targetObject` at the specified `targetPath`, optionally transforming the
 * value using the `transform` function.
 *
 * If `sourcePath` resolves to `undefined`, this method does nothing.
 *
 * @param sourceObject
 * @param sourcePath
 * @param targetObject
 * @param targetPath
 * @param transform
 */
function copy(sourceObject, sourcePath, targetObject, targetPath, transform) {
    if (lodash_1.default.has(sourceObject, sourcePath)) {
        let value = lodash_1.default.get(sourceObject, sourcePath);
        if (transform) {
            value = transform(value);
        }
        lodash_1.default.set(targetObject, targetPath, value);
    }
}
exports.copy = copy;
/**
 * Copies the value from the `sourceObject` at the specified `sourcePath` to
 * the `targetObject` at the specified `targetPath`.
 *
 * If `targetPath` resolves to `undefined`, this method does nothing.
 * If `sourcePath` resolves to `undefined`, this method does nothing.
 *
 * Optionally transform the value using the `transform` function.
 *
 * @param sourceObject
 * @param sourcePath
 * @param targetObject
 * @param targetPath
 * @param transform
 */
function copyIfNotSet(sourceObject, sourcePath, targetObject, targetPath, transform) {
    if (!lodash_1.default.has(targetObject, targetPath)) {
        copy(sourceObject, sourcePath, targetObject, targetPath, transform);
    }
}
exports.copyIfNotSet = copyIfNotSet;
/**
 * Renames `oldPath` to a `newPath`.
 *
 * @param object
 * @param oldPath
 * @param newPath
 */
function rename(object, oldPath, newPath) {
    if (lodash_1.default.has(object, oldPath)) {
        lodash_1.default.set(object, newPath, lodash_1.default.get(object, oldPath));
        oldPath = lodash_1.default.toPath(oldPath);
        if (oldPath.length > 1) {
            object = lodash_1.default.get(object, lodash_1.default.initial(oldPath));
        }
        const lastKey = lodash_1.default.last(oldPath);
        if (lastKey) {
            delete object[lastKey];
        }
    }
}
exports.rename = rename;
/**
 * Removed all null and undefined properties from the passed object
 * @param object
 */
function omitByNil(object) {
    return lodash_1.default.omitBy(object, lodash_1.default.isNil);
}
exports.omitByNil = omitByNil;
function omitByUndefined(object) {
    return lodash_1.default.omitBy(object, lodash_1.default.isUndefined);
}
exports.omitByUndefined = omitByUndefined;
function undefinedIfEmpty(value) {
    return lodash_1.default.isEmpty(value) ? undefined : value;
}
exports.undefinedIfEmpty = undefinedIfEmpty;
function deepMap(object, iteratee, options) {
    const context = lodash_1.default.get(options, 'context');
    const iterateCollections = lodash_1.default.get(options, 'iterateCollections', true);
    const iteratePrimitives = lodash_1.default.get(options, 'iteratePrimitives', true);
    const includeKeyPath = lodash_1.default.get(options, 'includeKeyPath', true);
    function _mapDeep(value, keyPath, mappedValueStack) {
        const invokeIteratee = lodash_1.default.isPlainObject(value) || lodash_1.default.isArray(value) ? iterateCollections : iteratePrimitives;
        if (invokeIteratee) {
            value =
                options?.includeKeyPath === false ? iteratee.call(context, value, object) : iteratee.call(context, value, keyPath, mappedValueStack, object);
        }
        const childrenIterator = (val, key) => {
            if (includeKeyPath) {
                return _mapDeep(val, lodash_1.default.concat(keyPath, key), lodash_1.default.concat(mappedValueStack, value));
            }
            return _mapDeep(val, null, null);
        };
        if (lodash_1.default.isPlainObject(value)) {
            value = lodash_1.default.mapValues(value, childrenIterator);
        }
        else if (Array.isArray(value)) {
            value = lodash_1.default.map(value, childrenIterator);
        }
        return value;
    }
    return _mapDeep(object, [], []);
}
exports.deepMap = deepMap;
async function asyncMapDeep(value, iteratee, options = {}) {
    const context = lodash_1.default.get(options, 'context');
    const iterateCollections = lodash_1.default.get(options, 'iterateCollections', true);
    const iteratePrimitives = lodash_1.default.get(options, 'iteratePrimitives', lodash_1.default.get(options, 'iterateScalars', true));
    const postOrder = lodash_1.default.get(options, 'postOrder', false);
    async function _mapDeep(value, keyPath, stack) {
        const invokeIteratee = lodash_1.default.isPlainObject(value) || lodash_1.default.isArray(value) ? iterateCollections : iteratePrimitives;
        let shouldSkipNested = false;
        if (invokeIteratee && !postOrder) {
            value = await iteratee.call(context, {
                value,
                keyPath,
                stack,
                skipNested: () => {
                    shouldSkipNested = true;
                }
            });
        }
        // check if we should stop handling current branch
        if (shouldSkipNested) {
            return value;
        }
        if (lodash_1.default.isPlainObject(value)) {
            const mappedObject = {};
            const keys = Object.keys(value);
            const values = await Promise.all(lodash_1.default.map(keys, (key) => {
                return _mapDeep(value[key], lodash_1.default.concat(keyPath, key), lodash_1.default.concat(stack, value));
            }));
            keys.forEach((key, i) => (mappedObject[key] = values[i]));
            value = mappedObject;
        }
        else if (lodash_1.default.isArray(value)) {
            value = await Promise.all(lodash_1.default.map(value, (val, key) => {
                return _mapDeep(val, lodash_1.default.concat(keyPath, key), lodash_1.default.concat(stack, value));
            }));
        }
        if (invokeIteratee && postOrder) {
            value = await iteratee.call(context, {
                value,
                keyPath,
                stack,
                skipNested: () => { }
            });
        }
        return value;
    }
    return _mapDeep(value, [], []);
}
exports.asyncMapDeep = asyncMapDeep;
//# sourceMappingURL=object-utils.js.map