import { Entry, Asset } from 'contentful';
import { AssetProps, EntryProps, ContentTypeProps } from 'contentful-management';
import { Logger } from '@stackbit/types';
export type ContentPollerSyncContext = {
    lastUpdatedEntryDate?: string;
    lastUpdatedAssetDate?: string;
    lastUpdatedContentTypeDate?: string;
};
export interface ContentPollerSyncResult {
    entries: EntryProps<any>[];
    assets: AssetProps[];
    contentTypes: ContentTypeProps[];
    deletedEntries: Entry<any>[];
    deletedAssets: Asset[];
}
export type SyncCallback = (result: ContentPollerSyncResult) => Promise<void>;
export declare class ContentPoller {
    private readonly logger;
    private readonly client;
    private readonly managementClient;
    private readonly notificationCallback;
    private readonly pollingIntervalMs;
    private nextSyncToken;
    private running;
    private pollTimeout;
    readonly pollType: 'sync' | 'date';
    private syncContext;
    constructor({ spaceId, environment, previewToken, managementToken, previewHost, managementHost, uploadHost, pollingIntervalMs, pollType, syncContext, notificationCallback, logger }: {
        spaceId: string;
        environment: string;
        previewToken: string;
        managementToken: string;
        previewHost?: string;
        managementHost?: string;
        uploadHost?: string;
        pollingIntervalMs?: number;
        pollType?: 'sync' | 'date';
        syncContext?: ContentPollerSyncContext;
        notificationCallback: SyncCallback;
        logger: Logger;
    });
    start(): void;
    stop(): void;
    setSyncContext(syncContext?: ContentPollerSyncContext): void;
    private setPollTimeout;
    handleTimeout(): Promise<void>;
    pollDate(): Promise<any>;
    pollSync(): Promise<any>;
    private batchRefetchData;
}
//# sourceMappingURL=content-poller.d.ts.map