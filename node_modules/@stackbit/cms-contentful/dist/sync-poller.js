"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncPoller = void 0;
const lodash_1 = __importDefault(require("lodash"));
const contentful_1 = require("contentful");
const lazy_poller_1 = require("./lazy-poller");
const contentful_api_client_1 = require("./contentful-api-client");
class SyncPoller extends lazy_poller_1.LazyPoller {
    constructor({ spaceId, environment, accessToken, managementToken, ...options }) {
        options.logger.debug('creating SyncPoller', { spaceId, environment });
        super(options);
        this.nextSyncToken = null;
        this.client = (0, contentful_1.createClient)({
            space: spaceId,
            environment: environment,
            accessToken: accessToken,
            host: 'preview.contentful.com'
        });
        this.managementClient = (0, contentful_api_client_1.createPlainApiClient)({ accessToken: managementToken, spaceId, environment });
    }
    async poll(notificationCallback) {
        const initial = this.nextSyncToken === null;
        let hasMoreItems = true;
        let hasItems = false;
        const result = {
            entries: [],
            assets: [],
            deletedEntries: [],
            deletedAssets: []
        };
        while (hasMoreItems) {
            const response = await this.client.sync({
                initial: this.nextSyncToken === null,
                nextSyncToken: this.nextSyncToken,
                resolveLinks: false
            });
            const isEmptyResponse = lodash_1.default.every(lodash_1.default.pick(response, ['entries', 'assets', 'deletedEntries', 'deletedAssets']), lodash_1.default.isEmpty);
            if (this.nextSyncToken === response.nextSyncToken || isEmptyResponse) {
                hasMoreItems = false;
            }
            else {
                if (!initial) {
                    const { entries, assets } = await this.batchRefetchData({
                        entryIds: response.entries.map((entry) => entry.sys.id),
                        assetIds: response.assets.map((entry) => entry.sys.id)
                    });
                    hasItems = true;
                    result.entries = result.entries.concat(entries);
                    result.assets = result.assets.concat(assets);
                    result.deletedEntries = result.deletedEntries.concat(response.deletedEntries);
                    result.deletedAssets = result.deletedAssets.concat(response.deletedAssets);
                }
            }
            this.nextSyncToken = response.nextSyncToken;
        }
        if (!initial && hasItems) {
            notificationCallback(result);
        }
    }
    async batchRefetchData({ entryIds, assetIds }) {
        const limit = 300;
        const entryChunks = lodash_1.default.chunk(entryIds, limit);
        const entries = lodash_1.default.flatMap(await Promise.all(entryChunks.map((chunk) => this.managementClient.entry.getMany({
            query: {
                limit: limit,
                'sys.id[in]': chunk.join(',')
            }
        }))), (result) => result.items);
        const assetChunks = lodash_1.default.chunk(assetIds, limit);
        const assets = lodash_1.default.flatMap(await Promise.all(assetChunks.map((chunk) => this.managementClient.asset.getMany({
            query: {
                limit: limit,
                'sys.id[in]': chunk.join(',')
            }
        }))), (result) => result.items);
        return { entries, assets };
    }
}
exports.SyncPoller = SyncPoller;
//# sourceMappingURL=sync-poller.js.map