import { WebhookProps } from 'contentful-management';
import type { DocumentVersion, DocumentVersionWithDocument, Model, Schema } from '@stackbit/types';
import type * as ContentSourceTypes from '@stackbit/types';
import { DocumentContext, AssetContext, ContextualDocument, ContextualAsset } from './contentful-entries-converter';
export interface ContentSourceOptions {
    /** Contentful Space ID */
    spaceId: string;
    /** Contentful Space Environment. Default: 'master' */
    environment?: string;
    /** Contentful Preview Token */
    previewToken: string;
    /** Contentful Personal Access Token */
    accessToken: string;
    /**
     * Use webhook for content updates.
     */
    useWebhookForContentUpdates?: boolean;
    /**
     * Use accessToken instead of userContext.accessToken for write operations.
     */
    useAccessTokenForUpdates?: boolean;
    /**
     * Switches the ContentfulContentSource to work with EU data regions.
     * When set to true, the following updated accordingly:
     * previewHost: 'preview.eu.contentful.com'
     * manageHost: 'api.eu.contentful.com'
     * uploadHost: 'upload.eu.contentful.com'
     */
    useEURegion?: boolean;
    /**
     * The host of the Contentful's preview API.
     * By default, this value is set to 'preview.contentful.com'.
     * If `useEURegion` is set, uses 'preview.eu.contentful.com'.
     */
    previewHost?: string;
    /**
     * The host of the Contentful's management API.
     * By default, this value is `undefined` which makes the contentful-management
     * use the 'api.contentful.com'.
     * If `useEURegion` is set, this value is set to 'api.eu.contentful.com'.
     */
    managementHost?: string;
    /**
     * The host used to upload assets to Contentful.
     * By default, this value is `undefined` which makes the contentful-management
     * use the 'upload.contentful.com'.
     * If `useEURegion` is set, this value is set to 'upload.eu.contentful.com'.
     */
    uploadHost?: string;
}
type UserContext = {
    accessToken: string;
};
export type SchemaContext = {
    lastUpdatedContentTypeDate?: string;
};
export declare class ContentfulContentSource implements ContentSourceTypes.ContentSourceInterface<UserContext, SchemaContext, DocumentContext, AssetContext> {
    private readonly spaceId;
    private readonly environment;
    private readonly accessToken;
    private readonly previewToken;
    private logger;
    private userLogger;
    private localDev;
    private contentPoller;
    private useWebhookForContentUpdates;
    private useAccessTokenForUpdates;
    private useEURegion;
    private previewHost?;
    private managementHost?;
    private uploadHost?;
    private locales;
    private defaultLocale?;
    private userMap;
    private cloudinaryImagesAsList;
    private bynderImagesAsList;
    private plainClient;
    private webhookUrl?;
    private devAppRestartNeeded?;
    private cache;
    private taskQueue;
    constructor(options: ContentSourceOptions);
    getVersion(): Promise<ContentSourceTypes.Version>;
    getContentSourceType(): string;
    getProjectId(): string;
    getProjectEnvironment(): string;
    getProjectManageUrl(): string;
    private getProjectUrl;
    init({ logger, userLogger, localDev, webhookUrl, devAppRestartNeeded, cache }: ContentSourceTypes.InitOptions<SchemaContext, DocumentContext, AssetContext>): Promise<void>;
    reset(): Promise<void>;
    destroy(): Promise<void>;
    validateConfig(): Promise<void>;
    createWebhookIfNeeded(): Promise<void>;
    createWebhook(webhookURL: string): Promise<WebhookProps>;
    startWatchingContentUpdates(): void;
    stopWatchingContentUpdates(): void;
    private fetchUsers;
    private fetchUsersIfNeeded;
    private updateContentPollerSyncContext;
    private getSyncContextForContentPollerFromCache;
    private convertSyncResult;
    getSchema(): Promise<Schema<SchemaContext>>;
    getDocuments(options?: {
        syncContext?: string;
    }): Promise<ContextualDocument[] | {
        documents: ContextualDocument[];
        syncContext?: string;
    }>;
    getAssets(options?: {
        syncContext?: string;
    }): Promise<ContextualAsset[] | {
        assets: ContextualAsset[];
        syncContext?: string;
    }>;
    hasAccess({ userContext }: {
        userContext?: UserContext;
    }): Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    createDocument({ updateOperationFields, model, locale, userContext }: {
        updateOperationFields: Record<string, ContentSourceTypes.UpdateOperationField>;
        model: Model;
        locale?: string;
        userContext?: UserContext;
    }): Promise<{
        documentId: string;
    }>;
    updateDocument({ document, operations, userContext }: {
        document: ContextualDocument;
        operations: ContentSourceTypes.UpdateOperation[];
        userContext?: UserContext;
    }): Promise<void>;
    deleteDocument({ document, userContext }: {
        document: ContextualDocument;
        userContext?: UserContext;
    }): Promise<void>;
    uploadAsset({ url, base64, fileName, mimeType, locale, userContext }: {
        url?: string;
        base64?: string;
        fileName: string;
        mimeType: string;
        locale?: string;
        userContext?: UserContext;
    }): Promise<ContextualAsset>;
    updateAsset({ asset, operations, userContext }: {
        asset: ContextualAsset;
        operations: ContentSourceTypes.UpdateOperation[];
        userContext?: UserContext;
    }): Promise<void>;
    validateDocuments({ documents, assets, locale, userContext }: {
        documents: ContextualDocument[];
        assets: ContextualAsset[];
        locale?: string;
        userContext?: UserContext;
    }): Promise<{
        errors: ContentSourceTypes.ValidationError[];
    }>;
    publishDocuments({ documents, assets, userContext }: {
        documents: ContextualDocument[];
        assets: ContextualAsset[];
        userContext?: UserContext;
    }): Promise<void>;
    unpublishDocuments({ documents, assets, userContext }: {
        documents: ContextualDocument[];
        assets: ContextualAsset[];
        userContext?: UserContext;
    }): Promise<void>;
    archiveDocument({ document, userContext }: {
        document: ContextualDocument;
        userContext?: UserContext;
    }): Promise<void>;
    unarchiveDocument({ document, userContext }: {
        document: ContextualDocument;
        userContext?: UserContext;
    }): Promise<void>;
    onWebhook({ data, headers }: {
        data: unknown;
        headers: Record<string, string>;
    }): Promise<void>;
    private getPlainApiClientForUser;
    private convertEntries;
    private convertAssets;
    private convertVersions;
    private localeOrDefaultOrThrow;
    cancelScheduledAction({ scheduledActionId, userContext }: {
        scheduledActionId: string;
        userContext?: UserContext;
    }): Promise<{
        cancelledScheduledActionId: string;
    }>;
    createScheduledAction({ documentIds, name, action, executeAt, userContext }: {
        documentIds: string[];
        name: string;
        action: ContentSourceTypes.ScheduledActionActionType;
        executeAt: string;
        userContext?: UserContext;
    }): Promise<{
        newScheduledActionId: string;
    }>;
    getScheduledActions(): Promise<ContentSourceTypes.ScheduledAction[]>;
    updateScheduledAction({ scheduledActionId, documentIds, name, executeAt, userContext }: {
        scheduledActionId: string;
        documentIds?: string[];
        name?: string;
        executeAt?: string;
        userContext?: UserContext;
    }): Promise<{
        updatedScheduledActionId: string;
    }>;
    getDocumentVersions({ documentId }: {
        documentId: string;
    }): Promise<{
        versions: DocumentVersion[];
    }>;
    getDocumentForVersion({ documentId, versionId }: {
        documentId: string;
        versionId: string;
    }): Promise<{
        version: DocumentVersionWithDocument;
    }>;
}
export {};
//# sourceMappingURL=contentful-content-source.d.ts.map