"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterScheduledActions = exports.convertScheduledAction = exports.convertAndFilterScheduledActions = exports.findScheduleForRelease = void 0;
const lodash_1 = __importDefault(require("lodash"));
function findScheduleForRelease(contentfulSchedulesForEntity) {
    if (!contentfulSchedulesForEntity?.length) {
        return null;
    }
    // find closest future schedule for release, or the last past schedule.
    // contentfulSchedulesForEntity are assumed to be sorted by scheduledFor.datetime.
    const now = new Date();
    return contentfulSchedulesForEntity.find((schedule) => now.toISOString() < schedule.scheduledFor.datetime) || lodash_1.default.last(contentfulSchedulesForEntity);
}
exports.findScheduleForRelease = findScheduleForRelease;
function convertAndFilterScheduledActions(contentfulReleases, contentfulSchedules) {
    const schedulesByEntity = lodash_1.default.groupBy(lodash_1.default.sortBy(contentfulSchedules, ['scheduledFor.datetime']), 'entity.sys.id');
    const allScheduledActions = [];
    for (const contentfulRelease of contentfulReleases) {
        const releaseSchedule = findScheduleForRelease(schedulesByEntity[contentfulRelease.sys.id] ?? []);
        if (releaseSchedule) {
            allScheduledActions.push(convertScheduledAction(contentfulRelease, releaseSchedule));
        }
    }
    return filterScheduledActions(allScheduledActions);
}
exports.convertAndFilterScheduledActions = convertAndFilterScheduledActions;
function convertScheduledAction(contentfulRelease, contentfulSchedule) {
    return {
        id: contentfulRelease.sys.id,
        name: contentfulRelease.title,
        state: getScheduledActionState(contentfulSchedule),
        action: contentfulSchedule.action,
        createdAt: contentfulRelease.sys.createdAt,
        createdBy: contentfulRelease.sys.createdBy.sys.id,
        executeAt: contentfulSchedule.scheduledFor.datetime,
        documentIds: contentfulRelease.entities.items.map((doc) => doc.sys.id)
    };
}
exports.convertScheduledAction = convertScheduledAction;
function filterScheduledActions(scheduledActions) {
    const cutoffDate = new Date();
    cutoffDate.setMonth(cutoffDate.getMonth() - 1);
    const cutoffDateStr = cutoffDate.toISOString();
    return scheduledActions.filter((scheduledAction) => scheduledAction.state !== 'cancelled' && scheduledAction.executeAt.localeCompare(cutoffDateStr) > 0);
}
exports.filterScheduledActions = filterScheduledActions;
function getScheduledActionState(contentfulSchedule) {
    if (contentfulSchedule.sys.status === 'inProgress') {
        return 'executing';
    }
    if (contentfulSchedule.sys.status === 'canceled') {
        return 'cancelled';
    }
    return contentfulSchedule.sys.status;
}
//# sourceMappingURL=contentful-scheduled-actions-converter.js.map