"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentValidationError = exports.IllegalModelFieldError = exports.ModelNotFoundError = exports.FileForModelNotFoundError = exports.FolderReadError = exports.FileReadError = exports.FileMatchedMultipleModelsError = exports.FileNotMatchedModelError = exports.CustomError = void 0;
class CustomError extends Error {
    constructor(message) {
        super(message);
        Error.captureStackTrace(this, CustomError);
    }
}
exports.CustomError = CustomError;
class FileNotMatchedModelError extends Error {
    constructor({ filePath }) {
        super(`file '${filePath}' does not match any model`);
        this.filePath = filePath;
    }
}
exports.FileNotMatchedModelError = FileNotMatchedModelError;
class FileMatchedMultipleModelsError extends Error {
    constructor({ filePath, modelNames }) {
        super(`file '${filePath}' matches several models '${modelNames.join(', ')}'`);
        this.filePath = filePath;
        this.modelNames = modelNames;
    }
}
exports.FileMatchedMultipleModelsError = FileMatchedMultipleModelsError;
class FileReadError extends Error {
    constructor({ filePath, error }) {
        super(`file '${filePath}' could not be loaded:  ${error.message}`);
        this.filePath = filePath;
        this.error = error;
    }
}
exports.FileReadError = FileReadError;
class FolderReadError extends Error {
    constructor({ folderPath, error }) {
        super(`folder '${folderPath}' could not be loaded: ${error.message}`);
        this.folderPath = folderPath;
        this.error = error;
    }
}
exports.FolderReadError = FolderReadError;
class FileForModelNotFoundError extends Error {
    constructor({ modelName }) {
        super(`file for model '${modelName}' not found`);
        this.modelName = modelName;
    }
}
exports.FileForModelNotFoundError = FileForModelNotFoundError;
class ModelNotFoundError extends Error {
    constructor({ modelName, fieldPath }) {
        super(`model '${modelName}' referenced in '${fieldPath.join('.')}' not found`);
        this.modelName = modelName;
        this.fieldPath = fieldPath;
    }
}
exports.ModelNotFoundError = ModelNotFoundError;
class IllegalModelFieldError extends Error {
    constructor({ modelName, modelType, fieldPath }) {
        super(`field of type 'model' cannot reference model of type other than 'object', field '${fieldPath.join('.')}' referenced model '${modelName}' of type '${modelType}'`);
        this.modelName = modelName;
        this.modelType = modelType;
        this.fieldPath = fieldPath;
    }
}
exports.IllegalModelFieldError = IllegalModelFieldError;
class ContentValidationError extends Error {
    constructor({ type, message, modelName, filePath, value, fieldPath }) {
        super(message);
        this.name = 'ContentValidationError';
        this.type = type;
        this.modelName = modelName;
        this.filePath = filePath;
        this.fieldPath = fieldPath;
        this.value = value;
        // redefine "message" as enumerable, this helps seeing the provided and the expected message in failed Jest's toMatchObject calls
        Object.defineProperty(this, 'message', { value: message, writable: true, enumerable: true, configurable: true });
    }
}
exports.ContentValidationError = ContentValidationError;
//# sourceMappingURL=content-errors.js.map