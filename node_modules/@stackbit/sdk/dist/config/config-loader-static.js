"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadStaticConfig = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@stackbit/utils");
const config_errors_1 = require("./config-errors");
const config_loader_utils_1 = require("./config-loader-utils");
const ROOT_PROPERTIES = [
    'nodeVersion',
    'ssgName',
    'ssgVersion',
    'cmsName',
    'postGitCloneCommand',
    'preInstallCommand',
    'postInstallCommand',
    'buildCommand',
    'publishDir'
];
const IMPORT_PROPERTIES = [
    'uploadAssets',
    'assetsDirectory',
    'spaceIdEnvVar',
    'accessTokenEnvVar',
    'deliveryTokenEnvVar',
    'previewTokenEnvVar',
    'sanityStudioPath',
    'deployStudio',
    'deployGraphql',
    'projectIdEnvVar',
    'datasetEnvVar',
    'tokenEnvVar'
];
const BOOLEAN_PROPERTIES = ['uploadAssets', 'deployStudio', 'deployGraphql'];
async function loadStaticConfig({ dirPath, secondaryDirPath, logger }) {
    try {
        const lookupDirs = [dirPath, secondaryDirPath].filter((dir) => typeof dir === 'string');
        const configFilePath = await config_loader_utils_1.findStackbitConfigFile(lookupDirs);
        if (!configFilePath) {
            return {
                config: null,
                errors: [new config_errors_1.StackbitConfigNotFoundError()]
            };
        }
        logger === null || logger === void 0 ? void 0 : logger.debug(`[config-loader-static] found stackbit config at ${configFilePath}`);
        const configExtension = path_1.default.extname(configFilePath).substring(1);
        if (['yaml', 'yml'].includes(configExtension)) {
            return loadStaticConfigFromStackbitYaml(configFilePath);
        }
        return loadStaticConfigFromStackbitJs(configFilePath);
    }
    catch (error) {
        return {
            config: null,
            errors: [new config_errors_1.ConfigLoadError(`Error loading Stackbit configuration: ${error.message}`, { originalError: error })]
        };
    }
}
exports.loadStaticConfig = loadStaticConfig;
async function loadStaticConfigFromStackbitYaml(configFilePath) {
    const result = await config_loader_utils_1.loadConfigFromStackbitYaml(configFilePath);
    if (result.error) {
        return {
            config: null,
            errors: [result.error]
        };
    }
    const stackbitVersion = result.config.stackbitVersion;
    if (!stackbitVersion) {
        const fileName = path_1.default.basename(configFilePath);
        return {
            config: null,
            errors: [new config_errors_1.ConfigLoadError(`stackbitVersion not found in ${fileName}, ${config_errors_1.REFER_TO_STACKBIT_CONFIG_DOCS}`)]
        };
    }
    const config = {
        stackbitVersion: stackbitVersion,
        ...utils_1.omitByNil(ROOT_PROPERTIES.reduce((accum, propertyName) => {
            accum[propertyName] = toStringOrNull(result.config[propertyName]);
            return accum;
        }, {
            import: result.config.import
        })),
        dirPath: path_1.default.dirname(configFilePath),
        filePath: configFilePath
    };
    return {
        config: config,
        errors: []
    };
}
function toStringOrNull(value) {
    if (value) {
        return lodash_1.default.toString(value);
    }
    return null;
}
async function loadStaticConfigFromStackbitJs(configFilePath) {
    const jsConfigString = await fs_extra_1.default.readFile(configFilePath, 'utf8');
    const stackbitVersion = parseInlineProperty(jsConfigString, 'stackbitVersion');
    if (!stackbitVersion) {
        const fileName = path_1.default.basename(configFilePath);
        return {
            config: null,
            errors: [new config_errors_1.ConfigLoadError(`stackbitVersion not found in ${fileName}, ${config_errors_1.REFER_TO_STACKBIT_CONFIG_DOCS}`)]
        };
    }
    const config = {
        stackbitVersion: stackbitVersion,
        ...utils_1.omitByNil(ROOT_PROPERTIES.reduce((accum, propertyName) => {
            accum[propertyName] = parseInlineProperty(jsConfigString, propertyName);
            return accum;
        }, {
            import: parseImport(jsConfigString),
            hasContentSources: hasProperty(jsConfigString, 'contentSources') || null
        })),
        dirPath: path_1.default.dirname(configFilePath),
        filePath: configFilePath
    };
    return {
        config: config,
        errors: []
    };
}
function parseImport(jsConfigString) {
    const importObjectRegExp = /(["']?)import\1\s*:\s*{([^}]+)}/;
    const match = jsConfigString.match(importObjectRegExp);
    if (match) {
        const importObjectStr = match[2];
        const type = parseInlineProperty(importObjectStr, 'type');
        const contentFile = parseInlineProperty(importObjectStr, 'contentFile');
        if (!type || !contentFile) {
            return null;
        }
        return {
            type,
            contentFile,
            ...utils_1.omitByNil(IMPORT_PROPERTIES.reduce((result, propertyName) => {
                result[propertyName] = parseInlineProperty(importObjectStr, propertyName);
                return result;
            }, {}))
        };
    }
    return null;
}
function parseInlineProperty(jsConfigString, propertyName) {
    const propRegExp = `(["']?)${propertyName}\\1`;
    const valueRegExp = '(?:\'(.+?)(?<!\\\\)\'|"(.+?)(?<!\\\\)"|([^\\s\'",}]+))';
    const fullRegExp = new RegExp(`${propRegExp}\\s*:\\s*${valueRegExp}`);
    const match = jsConfigString.match(fullRegExp);
    if (match) {
        if (match[2]) {
            return match[2].replace(/\\'/g, "'");
        }
        else if (match[3]) {
            return match[3].replace(/\\"/g, '"');
        }
        else if (BOOLEAN_PROPERTIES.includes(propertyName)) {
            return match[4] === 'true';
        }
        else {
            return lodash_1.default.toString(match[4]);
        }
    }
    return null;
}
function hasProperty(jsConfigString, propertyName) {
    return new RegExp(`\\b${propertyName}\\b`).test(jsConfigString);
}
//# sourceMappingURL=config-loader-static.js.map