"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateContentModels = exports.validateConfig = exports.validateBaseConfig = void 0;
const lodash_1 = __importDefault(require("lodash"));
const config_schema_1 = require("./config-schema");
const config_errors_1 = require("./config-errors");
function validateBaseConfig(config) {
    const validationOptions = { abortEarly: false, context: { config: config } };
    const validationResult = config_schema_1.stackbitConfigBaseSchema.validate(config, validationOptions);
    const errors = mapJoiErrorsToConfigValidationErrors(validationResult);
    return {
        config: validationResult.value,
        valid: lodash_1.default.isEmpty(errors),
        errors
    };
}
exports.validateBaseConfig = validateBaseConfig;
function validateConfig(config) {
    var _a;
    const validationOptions = { abortEarly: false, context: { config: config } };
    const validationResult = config_schema_1.stackbitConfigFullSchema.validate(config, validationOptions);
    const validatedConfig = validationResult.value;
    const errors = mapJoiErrorsToConfigValidationErrors(validationResult);
    const valid = lodash_1.default.isEmpty(errors);
    const invalidModelNames = getInvalidModelNames(errors, 'models', config);
    const validatedModels = (_a = validatedConfig.models) !== null && _a !== void 0 ? _a : [];
    lodash_1.default.forEach(validatedModels, (model) => {
        if (invalidModelNames.includes(model.name)) {
            lodash_1.default.set(model, '__metadata.invalid', true);
        }
    });
    return {
        config: validatedConfig,
        valid,
        errors
    };
}
exports.validateConfig = validateConfig;
function validateContentModels(contentModels, models) {
    var _a;
    const modelMap = lodash_1.default.keyBy(models, 'name');
    const config = { contentModels: contentModels };
    const validationResult = config_schema_1.contentModelsSchema.validate(config, {
        abortEarly: false,
        context: {
            modelMap: modelMap
        }
    });
    const validatedConfig = validationResult.value;
    const errors = mapJoiErrorsToConfigValidationErrors(validationResult);
    const valid = lodash_1.default.isEmpty(errors);
    const invalidModelNames = getInvalidModelNames(errors, 'contentModels', config);
    const validatedContentModels = (_a = validatedConfig.contentModels) !== null && _a !== void 0 ? _a : {};
    lodash_1.default.forEach(validatedContentModels, (contentModel, modelName) => {
        if (invalidModelNames.includes(modelName)) {
            lodash_1.default.set(contentModel, '__metadata.invalid', true);
        }
    });
    return {
        contentModels: validatedContentModels,
        valid,
        errors
    };
}
exports.validateContentModels = validateContentModels;
function mapJoiErrorsToConfigValidationErrors(validationResult) {
    var _a;
    const joiErrors = ((_a = validationResult.error) === null || _a === void 0 ? void 0 : _a.details) || [];
    return joiErrors.map((validationError) => {
        var _a;
        const normFieldPath = validationError.path.slice();
        if (validationError.path[0] === 'models' && typeof validationError.path[1] == 'string') {
            const modelName = validationError.path[1];
            normFieldPath[1] = lodash_1.default.findIndex(validationResult.value.models, { name: modelName });
        }
        return new config_errors_1.ConfigValidationError({
            type: validationError.type,
            message: validationError.message,
            fieldPath: validationError.path,
            normFieldPath: normFieldPath,
            value: (_a = validationError.context) === null || _a === void 0 ? void 0 : _a.value
        });
    });
}
function getInvalidModelNames(errors, configKey, value) {
    // get array of invalid model names by iterating errors and filtering these
    // having fieldPath starting with ['models', modelName]
    return lodash_1.default.reduce(errors, (modelNames, error) => {
        if (error.fieldPath[0] === configKey) {
            if (typeof error.fieldPath[1] == 'string') {
                modelNames.push(error.fieldPath[1]);
            }
            else if (typeof error.fieldPath[1] == 'number') {
                const model = value[configKey][error.fieldPath[1]];
                if (model === null || model === void 0 ? void 0 : model.name) {
                    modelNames.push(model === null || model === void 0 ? void 0 : model.name);
                }
            }
        }
        return modelNames;
    }, []);
}
//# sourceMappingURL=config-validator.js.map