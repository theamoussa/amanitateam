/// <reference types="node" />
/// <reference types="node" />
import type { ChildProcessWithoutNullStreams } from 'child_process';
import type { Model } from './models';
import type { Logger } from './logger';
import type { Document, Asset, TypeDocument, TypeAsset, DocumentStatus } from './content-source-document';
import type { UpdateOperation, UpdateOperationField } from './content-source-operation';
export interface ContentSourceInterface<UserContext = unknown, DocumentContext = unknown, AssetContext = unknown> {
    /**
     * This function should return the type of the content source.
     * The type must be unique among other content sources within the same project.
     */
    getContentSourceType(): string;
    /**
     * This function should return the project ID of the content source.
     * The ID must be unique among other content sources of the same type.
     */
    getProjectId(): string;
    getProjectEnvironment(): string;
    getProjectManageUrl(): string;
    /**
     * This function should initialize the content source by fetching the schema
     * and everything else needed to produce the StackbitSchema
     */
    init(options: InitOptions): Promise<void>;
    reset(): Promise<void>;
    onWebhook?(data: {
        data: unknown;
        headers: Record<string, string>;
    }): void;
    onFilesChange?({ updatedFiles }: {
        updatedFiles: string[];
    }): Promise<{
        schemaChanged?: boolean;
        contentChangeEvent?: ContentChangeEvent<DocumentContext, AssetContext>;
    }>;
    startWatchingContentUpdates(options: {
        getModelMap: () => ModelMap;
        getDocument: ({ documentId }: {
            documentId: string;
        }) => Document<DocumentContext> | undefined;
        getAsset: ({ assetId }: {
            assetId: string;
        }) => Asset<AssetContext> | undefined;
        onContentChange: (contentChangeEvent: ContentChangeEvent<DocumentContext, AssetContext>) => Promise<void>;
        onSchemaChange: () => void;
    }): void;
    stopWatchingContentUpdates(): void;
    /**
     * This function is responsible to fetch and convert content models
     * to Stackbit models.
     */
    getModels(): Promise<Model[]>;
    getLocales(): Promise<Locale[]>;
    /**
     * This function should fetch the documents and convert them into Stackbit's
     * Document type
     */
    getDocuments(options: {
        modelMap: ModelMap;
    }): Promise<Document<DocumentContext>[]>;
    getAssets(): Promise<Asset<AssetContext>[]>;
    hasAccess(options: {
        userContext?: UserContext;
    }): Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    createDocument(options: {
        updateOperationFields: Record<string, UpdateOperationField>;
        model: Model;
        modelMap: ModelMap;
        locale?: string;
        defaultLocaleDocumentId?: string;
        userContext?: UserContext;
    }): Promise<Document<DocumentContext>>;
    updateDocument(options: {
        document: Document<DocumentContext>;
        operations: UpdateOperation[];
        modelMap: ModelMap;
        userContext?: UserContext;
    }): Promise<Document<DocumentContext>>;
    deleteDocument(options: {
        document: Document<DocumentContext>;
        userContext?: UserContext;
    }): Promise<void>;
    uploadAsset(options: {
        url?: string;
        base64?: string;
        fileName: string;
        mimeType: string;
        locale?: string;
        userContext?: UserContext;
    }): Promise<Asset<AssetContext>>;
    validateDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        locale?: string;
        userContext?: UserContext;
    }): Promise<{
        errors: ValidationError[];
    }>;
    publishDocuments(options: {
        documents: Document<DocumentContext>[];
        assets: Asset<AssetContext>[];
        userContext?: UserContext;
    }): Promise<void>;
}
export declare type RunResult = {
    stdout: string;
    stderr: string;
    exitCode?: number;
    err?: Error;
};
export declare type CommandRunner = (command: string, args?: string[], options?: {
    cwd?: string;
    shell?: boolean;
    env?: NodeJS.ProcessEnv;
}) => Promise<RunResult>;
export interface GitFileCommitDescriptor {
    filePath: string;
    description: string;
}
export interface GitAuthor {
    name?: string;
    email: string;
}
export interface GitCommitLogEntry {
    author: string;
    timestamp: Date;
    commitHash: string;
    changes: {
        status: DocumentStatus;
        filePath: string;
    }[];
}
export interface GitServiceInterface {
    getRepoUrl(): string;
    getRepoBranch(): string;
    getRepoPublishBranch(): string;
    commitAndPush: (author: GitAuthor, files: GitFileCommitDescriptor[]) => Promise<void>;
    publish(author: GitAuthor, filePaths?: string[]): Promise<void>;
    commitLog(): Promise<GitCommitLogEntry[]>;
    diff(): Promise<string[]>;
}
export interface InitOptions {
    logger: Logger;
    userLogger: Logger;
    userCommandSpawner?: UserCommandSpawner;
    localDev: boolean;
    webhookUrl?: string;
    devAppRestartNeeded?: () => void;
    git: GitServiceInterface;
    runCommand: CommandRunner;
}
export declare type UserCommandSpawner = (options: SpawnUserCommandOptions) => ChildProcessWithoutNullStreams;
export interface SpawnUserCommandOptions {
    command: string;
    args?: string[];
    cwd?: string;
    env?: NodeJS.ProcessEnv;
}
export interface ContentChangeEvent<DocumentContext = unknown, AssetContext = unknown> {
    documents: Document<DocumentContext>[];
    assets: Asset<AssetContext>[];
    deletedDocumentIds: string[];
    deletedAssetIds: string[];
}
export declare type ModelMap = Record<string, Model>;
export interface Locale {
    code: string;
    default?: boolean;
}
export declare type ValidationError = {
    message: string;
    objectType: TypeDocument | TypeAsset;
    objectId: string;
    fieldPath: (string | number)[];
    isUniqueValidation?: boolean;
};
//# sourceMappingURL=content-source.d.ts.map