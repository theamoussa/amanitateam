import _ from 'lodash';
import { Model } from '@stackbit/sdk';
import { Field, FieldListItems, FieldListProps, FieldObjectProps } from '@stackbit/types';
import * as ContentStoreTypes from '../types';
import { getDocumentFieldForLocale } from '../content-store-utils';

export function getModelFieldAtFieldPath({
    document,
    fieldPath,
    modelMap,
    locale
}: {
    document: ContentStoreTypes.Document;
    fieldPath: (string | number)[];
    modelMap: Record<string, Model>;
    locale?: string;
}): Field | FieldListItems {
    if (_.isEmpty(fieldPath)) {
        throw new Error('the fieldPath can not be empty');
    }

    const model = modelMap[document.srcModelName];
    if (!model) {
        throw new Error(`model with name '${document.srcModelName}' of a document '${document.srcObjectId}' not found`);
    }

    function getField(docField: ContentStoreTypes.DocumentField, modelField: Field | FieldListItems, fieldPath: (string | number)[]): Field | FieldListItems {
        const fieldName = _.head(fieldPath);
        if (typeof fieldName === 'undefined') {
            throw new Error('the first fieldPath item must be string');
        }
        const childFieldPath = _.tail(fieldPath);
        let childDocField: ContentStoreTypes.DocumentField | undefined;
        let childModelField: Field | undefined;
        switch (docField.type) {
            case 'object': {
                const localizedObjectField = getDocumentFieldForLocale(docField, locale);
                if (!localizedObjectField) {
                    throw new Error(`locale for field was not found`);
                }
                if (localizedObjectField.isUnset) {
                    throw new Error(`field is not set`);
                }
                childDocField = localizedObjectField.fields[fieldName];
                childModelField = _.find((modelField as FieldObjectProps).fields, (field) => field.name === fieldName);
                if (!childDocField || !childModelField) {
                    throw new Error(`field ${fieldName} doesn't exist`);
                }
                if (childFieldPath.length === 0) {
                    return childModelField;
                }
                return getField(childDocField, childModelField, childFieldPath);
            }
            case 'model': {
                const localizedModelField = getDocumentFieldForLocale(docField, locale);
                if (!localizedModelField) {
                    throw new Error(`locale for field was not found`);
                }
                if (localizedModelField.isUnset) {
                    throw new Error(`field is not set`);
                }
                const modelName = localizedModelField.srcModelName;
                const childModel = modelMap[modelName];
                if (!childModel) {
                    throw new Error(`model ${modelName} doesn't exist`);
                }
                childModelField = _.find(childModel.fields, (field) => field.name === fieldName);
                childDocField = localizedModelField.fields![fieldName];
                if (!childDocField || !childModelField) {
                    throw new Error(`field ${fieldName} doesn't exist`);
                }
                if (childFieldPath.length === 0) {
                    return childModelField;
                }
                return getField(childDocField, childModelField!, childFieldPath);
            }
            case 'list': {
                const localizedListField = getDocumentFieldForLocale(docField, locale);
                if (!localizedListField) {
                    throw new Error(`locale for field was not found`);
                }
                const listItem = localizedListField.items && localizedListField.items[fieldName as number];
                const listItemsModel = (modelField as FieldListProps).items;
                if (!listItem || !listItemsModel) {
                    throw new Error(`field ${fieldName} doesn't exist`);
                }
                if (childFieldPath.length === 0) {
                    return listItemsModel;
                }
                if (!Array.isArray(listItemsModel)) {
                    return getField(listItem, listItemsModel, childFieldPath);
                } else {
                    const fieldListItems = (listItemsModel as FieldListItems[]).find((listItemsModel) => listItemsModel.type === listItem.type);
                    if (!fieldListItems) {
                        throw new Error('cannot find matching field model');
                    }
                    return getField(listItem, fieldListItems, childFieldPath);
                }
            }
            default:
                if (!_.isEmpty(childFieldPath)) {
                    throw new Error('illegal fieldPath');
                }
                return modelField;
        }
    }

    const fieldName = _.head(fieldPath);
    const childFieldPath = _.tail(fieldPath);

    if (typeof fieldName !== 'string') {
        throw new Error('the first fieldPath item must be string');
    }

    const childDocField = document.fields[fieldName];
    const childModelField = _.find(model.fields, { name: fieldName });

    if (!childDocField || !childModelField) {
        throw new Error(`field ${fieldName} doesn't exist`);
    }

    if (childFieldPath.length === 0) {
        return childModelField;
    }

    return getField(childDocField, childModelField, childFieldPath);
}

export type GetDocumentFieldAtFieldPathOptions = {
    document: ContentStoreTypes.Document;
    fieldPath: (string | number)[];
    locale?: string;
    isFullFieldPath?: boolean;
    returnUndefined?: boolean;
};
export type GetDocumentFieldAtFieldPathOptionsThrow = GetDocumentFieldAtFieldPathOptions & {
    returnUndefined?: false;
};
export type GetDocumentFieldAtFieldPathOptionsUndefined = GetDocumentFieldAtFieldPathOptions & {
    returnUndefined: true;
};

/**
 * This function receives a `document` and returns DocumentFieldNonLocalized at
 * the specified `fieldPath` while resolving any localized fields with the
 * specified `locale`.
 *
 * @example
 * getDocumentFieldAtFieldPath({
 *   document,
 *   locale,
 *   fieldPath: ['sections', 1, 'title']
 * })
 *
 * For improved localization support, use the getModelAndDocumentFieldForLocalizedFieldPath
 * method instead.
 *
 * The `isFullFieldPath` flag specifies if the `fieldPath` includes container
 * specifiers such as "fields" and "items".
 *
 * By default, if the document field at the specified `fieldPath` not found, this
 * function will throw exception. Setting `returnUndefined` to true will allow
 * the function to return `undefined` if the document field is not found.
 *
 * @example
 * isFullFieldPath: false => fieldPath: ['sections', 1, 'title']
 * isFullFieldPath: true => fieldPath: ['fields', 'sections', 'items', 1, 'fields', 'title']
 */
export function getDocumentFieldAtFieldPath(options: GetDocumentFieldAtFieldPathOptionsThrow): ContentStoreTypes.DocumentFieldNonLocalized;
export function getDocumentFieldAtFieldPath(options: GetDocumentFieldAtFieldPathOptionsUndefined): ContentStoreTypes.DocumentFieldNonLocalized | undefined;
export function getDocumentFieldAtFieldPath({
    document,
    fieldPath,
    locale,
    isFullFieldPath,
    returnUndefined
}: GetDocumentFieldAtFieldPathOptions): ContentStoreTypes.DocumentFieldNonLocalized | undefined {
    function throwOrReturnUndefined(errorMessage: string) {
        if (returnUndefined) {
            return undefined;
        } else {
            throw new Error(errorMessage);
        }
    }
    if (isFullFieldPath) {
        if (_.head(fieldPath) !== 'fields') {
            return throwOrReturnUndefined('fieldPath must start with "fields" specifier');
        }
        fieldPath = _.tail(fieldPath);
    }

    if (_.isEmpty(fieldPath)) {
        return throwOrReturnUndefined('the fieldPath cannot be empty');
    }

    const docId = document.srcObjectId;
    const modelName = document.srcModelName;
    const origFieldPath = fieldPath;
    const origFieldPathStr = fieldPath.join('.');

    function getPrefixOf(fieldPath: (string | number)[], include = 0) {
        return origFieldPath.slice(0, origFieldPath.length - fieldPath.length + include).join('.');
    }

    function getField(
        docField: ContentStoreTypes.DocumentField | ContentStoreTypes.DocumentListFieldItems,
        fieldPath: (string | number)[]
    ): ContentStoreTypes.DocumentFieldNonLocalized | undefined {
        const localizedField = getDocumentFieldForLocale(docField, locale);
        if (!localizedField) {
            return throwOrReturnUndefined(
                `the value of a field at fieldPath '${getPrefixOf(fieldPath)}' is undefined ` +
                    `for the document '${docId}' of type '${modelName}' for the '${locale}' locale.`
            );
        }

        // if no more items in fieldPath return the found document and model fields
        if (fieldPath.length === 0) {
            return localizedField;
        }

        switch (localizedField.type) {
            case 'object':
            case 'model': {
                if (localizedField.isUnset) {
                    return throwOrReturnUndefined(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${modelName}' points into an object that is not set`
                    );
                }
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'fields') {
                        return throwOrReturnUndefined(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier before a field's name`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const fieldName = _.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    return throwOrReturnUndefined(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${modelName}' must point to a field name`
                    );
                }
                fieldPath = _.tail(fieldPath);
                const childDocField = localizedField.fields[fieldName];
                if (!childDocField) {
                    return throwOrReturnUndefined(
                        `the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing field in a document '${docId}' of type '${modelName}'`
                    );
                }
                return getField(childDocField, fieldPath);
            }
            case 'list': {
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'items') {
                        return throwOrReturnUndefined(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "items" specifier after a "list" field`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const itemIndex = _.head(fieldPath) as number;
                if (typeof itemIndex === 'undefined') {
                    return throwOrReturnUndefined(
                        `fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${modelName}' must point to a list item index`
                    );
                }
                fieldPath = _.tail(fieldPath);
                const listItem = localizedField.items && localizedField.items[itemIndex];
                if (!listItem) {
                    return throwOrReturnUndefined(
                        `the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing list item in a document '${docId}' of type '${modelName}'`
                    );
                }
                return getField(listItem, fieldPath);
            }
            default: {
                const primitiveFieldName = origFieldPath[origFieldPath.length - fieldPath.length - 1];
                return throwOrReturnUndefined(
                    `the fieldPath '${origFieldPathStr}' is illegal, a primitive field '${primitiveFieldName}' of type '${localizedField.type}' cannot be followed by additional field paths`
                );
            }
        }
    }

    const fieldName = _.head(fieldPath);
    const restFieldPath = _.tail(fieldPath);

    if (typeof fieldName !== 'string') {
        return throwOrReturnUndefined('the first fieldPath item must be string');
    }

    const childDocField: ContentStoreTypes.DocumentField | undefined = document.fields[fieldName];
    if (!childDocField) {
        return throwOrReturnUndefined(`document '${docId}' of type '${modelName}' doesn't have a field named '${fieldName}'`);
    }

    return getField(childDocField, restFieldPath);
}

/**
 * This function receives a `document` and a `modelMap` and returns an object
 * with DocumentFieldNonLocalized and a model Field at the specified `fieldPath`
 * while resolving any localized fields with the specified `locale`.
 *
 * @example
 * getDocumentAndModelFieldAtFieldPath({
 *   document,
 *   locale,
 *   modelMap,
 *   fieldPath: ['sections', 1, 'title']
 * })
 *
 * For improved localization support, use the getModelAndDocumentFieldForLocalizedFieldPath
 * method instead.
 *
 * The `isFullFieldPath` flag specifies if the `fieldPath` includes container
 * specifiers such as "fields" and "items".
 *
 * @example
 * isFullFieldPath: false => fieldPath: ['sections', 1, 'title']
 * isFullFieldPath: true => fieldPath: ['fields', 'sections', 'items', 1, 'fields', 'title']
 */
export function getDocumentAndModelFieldAtFieldPath({
    document,
    fieldPath,
    modelMap,
    locale,
    isFullFieldPath
}: {
    document: ContentStoreTypes.Document;
    fieldPath: (string | number)[];
    modelMap: Record<string, Model>;
    locale?: string;
    isFullFieldPath?: boolean;
}): { modelField: Field | FieldListItems; documentField: ContentStoreTypes.DocumentFieldNonLocalized } {
    if (isFullFieldPath) {
        if (_.head(fieldPath) !== 'fields') {
            throw new Error('fieldPath must start with "fields" specifier');
        }
        fieldPath = _.tail(fieldPath);
    }

    if (_.isEmpty(fieldPath)) {
        throw new Error('the fieldPath cannot be empty');
    }

    const docId = document.srcObjectId;
    const docModelName = document.srcModelName;
    const origFieldPath = fieldPath;
    const origFieldPathStr = fieldPath.join('.');

    let parentModel: Model = modelMap[docModelName]!;
    let fieldPathFromParentModel = fieldPath;

    if (!parentModel) {
        throw new Error(`model with name '${docModelName}' of a document '${docId}' not found`);
    }

    function getPrefixOf(fieldPath: (string | number)[], include = 0) {
        return origFieldPath.slice(0, origFieldPath.length - fieldPath.length + include).join('.');
    }

    function getModelPrefixOf(fieldPath: (string | number)[], include = 0) {
        return fieldPathFromParentModel.slice(0, fieldPathFromParentModel.length - fieldPath.length + include).join('.');
    }

    function getField(
        docField: ContentStoreTypes.DocumentField | ContentStoreTypes.DocumentListFieldItems,
        modelField: Field | FieldListItems,
        fieldPath: (string | number)[]
    ): { modelField: Field | FieldListItems; documentField: ContentStoreTypes.DocumentFieldNonLocalized } {
        const localizedField = getDocumentFieldForLocale(docField, locale);
        if (!localizedField) {
            throw new Error(
                `the value of a field at fieldPath '${getPrefixOf(fieldPath)}' is undefined ` +
                    `for the document '${docId}' of type '${docModelName}' for the '${locale}' locale.`
            );
        }

        // if no more items in fieldPath return the found document and model fields
        if (fieldPath.length === 0) {
            return {
                modelField: modelField,
                documentField: localizedField
            };
        }

        switch (localizedField.type) {
            case 'object': {
                if (localizedField.isUnset) {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' points into an object that is not set`
                    );
                }
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'fields') {
                        throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier before a field's name`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const fieldName = _.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' must point to a field name`
                    );
                }
                fieldPath = _.tail(fieldPath);
                const childDocField = localizedField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing field in a document '${docId}' of type '${docModelName}'`
                    );
                }
                if (modelField.type !== 'object') {
                    throw new Error(
                        `model field of type '${modelField.type}' of model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                            `doesn't match document field of type 'object' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`
                    );
                }
                const childModelField = _.find(modelField.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${parentModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'model': {
                if (localizedField.isUnset) {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' points into an object that is not set`
                    );
                }
                fieldPathFromParentModel = fieldPath;
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'fields') {
                        throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier before a field's name`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const fieldName = _.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' must point to a field name`
                    );
                }
                fieldPath = _.tail(fieldPath);
                const childDocField = localizedField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing field in a document '${docId}' of type '${docModelName}'`
                    );
                }
                const modelName = localizedField.srcModelName;
                const childModel = modelMap[modelName];
                if (!childModel) {
                    throw new Error(
                        `the "model" field at path '${getPrefixOf(fieldPath)}' of a document '${docId}' of type '${docModelName}' ` +
                            `contains an object with type of non existing model '${modelName}'`
                    );
                }
                parentModel = childModel;
                const childModelField = _.find(childModel.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${childModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'list': {
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'items') {
                        throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "items" specifier before a list item index`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const itemIndex = _.head(fieldPath) as number;
                if (typeof itemIndex === 'undefined') {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' must point to a list item index`
                    );
                }
                fieldPath = _.tail(fieldPath);
                const listItem = localizedField.items && localizedField.items[itemIndex];
                if (!listItem) {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing list item in a document '${docId}' of type '${docModelName}'`
                    );
                }
                if (modelField.type !== 'list') {
                    throw new Error(
                        `model field of type '${modelField.type}' of model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                            `doesn't match document field of type 'list' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`
                    );
                }
                const listItemsModel = modelField.items;
                if (!Array.isArray(listItemsModel)) {
                    return getField(listItem, listItemsModel, fieldPath);
                } else {
                    const fieldListItems = (listItemsModel as FieldListItems[]).find((listItemsModel) => listItemsModel.type === listItem.type);
                    if (!fieldListItems) {
                        throw new Error(
                            `cannot find list item model for list item of type '${listItem.type}' for model '${parentModel.name}' ` +
                                `at field path '${getModelPrefixOf(fieldPath)}'`
                        );
                    }
                    return getField(listItem, fieldListItems, fieldPath);
                }
            }
            default: {
                const primitiveFieldName = origFieldPath[origFieldPath.length - fieldPath.length - 1];
                throw new Error(
                    `the fieldPath '${origFieldPathStr}' is illegal, a primitive field '${primitiveFieldName}' of type '${localizedField.type}' cannot be followed by additional field paths`
                );
            }
        }
    }

    const fieldName = _.head(fieldPath);
    const restFieldPath = _.tail(fieldPath);

    if (typeof fieldName !== 'string') {
        throw new Error('the first fieldPath item must be string');
    }

    const childDocField: ContentStoreTypes.DocumentField | undefined = document.fields[fieldName];
    if (!childDocField) {
        throw new Error(`document '${docId}' of type '${docModelName}' doesn't have a field named '${fieldName}'`);
    }

    const childModelField: Field | undefined = _.find(parentModel.fields, { name: fieldName });
    if (!childModelField) {
        throw new Error(`model '${docModelName}' doesn't have a field named '${fieldName}'`);
    }

    return getField(childDocField, childModelField, restFieldPath);
}

/**
 * This function receives a `document` and a `modelMap` and returns an object
 * with DocumentField and a model Field at the specified `fieldPath`.
 *
 * If some fields along the fieldPath are localized, the `fieldPath` must
 * contain the locale of the field under the "locales" property. The locales
 * along the field path don't have to be the same.
 *
 * @example
 * fieldPath: ['fields', 'button', 'locales', 'en', 'fields', 'title', 'locales', 'es']
 *
 * If the provided `fieldPath` points to a list item, the returned model field
 * and document field will belong to a list item. In this case, the model field
 * will contain only field-specific properties and the document field will be
 * localized.
 *
 * @example
 * fieldPath: ['fields', 'buttons', 'items', 2]
 *
 * The `isFullFieldPath` flag specifies if the `fieldPath` includes container
 * specifiers such as "fields" and "items".
 *
 * @example
 * isFullFieldPath: false => fieldPath: ['sections', 1, 'title', 'es']
 * isFullFieldPath: true => fieldPath: ['fields', 'sections', 'items', 1, 'fields', 'title', 'locales', 'es']
 */
export function getModelAndDocumentFieldForLocalizedFieldPath({
    document,
    fieldPath,
    modelMap,
    isFullFieldPath
}: {
    document: ContentStoreTypes.Document;
    fieldPath: (string | number)[];
    modelMap: Record<string, Model>;
    isFullFieldPath?: boolean;
}): { modelField: Field | FieldListItems; documentField?: ContentStoreTypes.DocumentField | ContentStoreTypes.DocumentListFieldItems } {
    if (isFullFieldPath) {
        if (_.head(fieldPath) !== 'fields') {
            throw new Error('fieldPath must start with "fields" specifier');
        }
        fieldPath = _.tail(fieldPath);
    }
    if (_.isEmpty(fieldPath)) {
        throw new Error('the fieldPath cannot be empty');
    }

    const docId = document.srcObjectId;
    const origModelName = document.srcModelName;
    const origFieldPath = fieldPath;
    const origFieldPathStr = fieldPath.join('.');
    const model = modelMap[origModelName];
    if (!model) {
        throw new Error(`model with name '${origModelName}' of a document '${docId}' not found`);
    }

    let parentModel = model;
    let fieldPathFromParentModel = fieldPath;

    function getPrefixOf(fieldPath: (string | number)[], include = 0) {
        return origFieldPath.slice(0, origFieldPath.length - fieldPath.length + include).join('.');
    }
    function getModelPrefixOf(fieldPath: (string | number)[], include = 0) {
        return fieldPathFromParentModel.slice(0, fieldPathFromParentModel.length - fieldPath.length + include).join('.');
    }

    function getField(
        docField: ContentStoreTypes.DocumentField | ContentStoreTypes.DocumentListFieldItems,
        modelField: Field | FieldListItems,
        fieldPath: (string | number)[]
    ): { modelField: Field | FieldListItems; documentField?: ContentStoreTypes.DocumentField | ContentStoreTypes.DocumentListFieldItems } {
        // if no more items in fieldPath return the found document and model fields
        if (fieldPath.length === 0) {
            return {
                modelField: modelField,
                documentField: docField
            };
        }

        if (docField.localized) {
            if (isFullFieldPath) {
                if (_.head(fieldPath) !== 'locales') {
                    throw new Error(`fieldPath '${origFieldPath.join('.')}' must contain "locales" specifier for localized field`);
                }
                fieldPath = _.tail(fieldPath);
            }
            const locale = _.head(fieldPath);
            if (typeof locale !== 'string') {
                throw new Error(`the locale specifier must be string in fieldPath '${origFieldPath.join('.')}'`);
            }
            fieldPath = _.tail(fieldPath);
            const localizedDocField = getDocumentFieldForLocale(docField, locale);
            if (!localizedDocField) {
                if (!fieldPath.length) {
                    // field locale is not set
                    return { modelField, documentField: undefined };
                }
                throw new Error(
                    `document '${docId}' of type '${origModelName}' doesn't have a localized value for locale ${locale} at path '${getPrefixOf(fieldPath)}'`
                );
            }
            docField = localizedDocField;
        }

        switch (docField.type) {
            case 'object': {
                if (docField.isUnset) {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath)}' of document ${docId} points ` +
                            `into the fields of an empty 'object' field, full fieldPath '${origFieldPathStr}'.`
                    );
                }
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'fields') {
                        throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier after an "object" field`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const fieldName = _.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must specify a field name for an "object" field`);
                }
                fieldPath = _.tail(fieldPath);

                const childDocField = docField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(`document '${docId}' of type '${origModelName}' doesn't have a field at path: '${getPrefixOf(fieldPath)}'`);
                }
                if (modelField.type !== 'object') {
                    throw new Error(
                        `model field of type '${modelField.type}' of model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                            `doesn't match document field of type 'object' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`
                    );
                }
                const childModelField = _.find(modelField.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${parentModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'model': {
                if (docField.isUnset) {
                    throw new Error(
                        `the fieldPath '${getPrefixOf(fieldPath, 1)}' of document ${docId} points ` +
                            `into the fields of an empty "model" field, full fieldPath '${origFieldPathStr}'`
                    );
                }
                fieldPathFromParentModel = fieldPath;
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'fields') {
                        throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier after a "model" field`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const fieldName = _.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must specify a field name for an "model" field`);
                }
                fieldPath = _.tail(fieldPath);

                const modelName = docField.srcModelName;
                const childModel = modelMap[modelName];
                if (!childModel) {
                    throw new Error(
                        `a "model" field of a document '${docId}' at path '${getPrefixOf(fieldPath)}' ` +
                            `contains an object with non existing modelName '${modelName}'`
                    );
                }
                parentModel = childModel;
                const childDocField = docField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(`document '${docId}' of type '${origModelName}' doesn't have a field at path: '${getPrefixOf(fieldPath)}'`);
                }
                const childModelField = _.find(childModel.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${childModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'list': {
                if (isFullFieldPath) {
                    if (_.head(fieldPath) !== 'items') {
                        throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "items" specifier after a "list" field`);
                    }
                    fieldPath = _.tail(fieldPath);
                }
                const itemIndex = _.head(fieldPath) as number;
                if (typeof itemIndex === 'undefined') {
                    throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must specify a list item index for a "list" field`);
                }
                fieldPath = _.tail(fieldPath);

                const listItem = docField.items && docField.items[itemIndex as number];
                if (!listItem) {
                    throw new Error(`document '${docId}' of type '${origModelName}' doesn't have a list item at path: '${getPrefixOf(fieldPath)}'`);
                }
                if (modelField.type !== 'list') {
                    throw new Error(
                        `model field type '${modelField.type}' of a model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                            `doesn't match document field of type 'list' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`
                    );
                }
                const listItemsModel = modelField.items;
                if (!Array.isArray(listItemsModel)) {
                    return getField(listItem, listItemsModel, fieldPath);
                } else {
                    const fieldListItems = (listItemsModel as FieldListItems[]).find((listItemsModel) => listItemsModel.type === listItem.type);
                    if (!fieldListItems) {
                        throw new Error(
                            `cannot find list item model for document list item of type '${listItem.type}' for model '${parentModel.name}' ` +
                                `at field path '${getModelPrefixOf(fieldPath, 1)}'`
                        );
                    }
                    return getField(listItem, fieldListItems, fieldPath);
                }
            }
            default:
                if (!_.isEmpty(fieldPath)) {
                    throw new Error(
                        `illegal fieldPath, a primitive field of type '${docField.type}' was found in the middle of the fieldPath '${origFieldPathStr}'`
                    );
                }
                return {
                    modelField,
                    documentField: docField
                };
        }
    }

    const fieldName = _.head(fieldPath);
    const childFieldPath = _.tail(fieldPath);

    if (typeof fieldName !== 'string') {
        throw new Error('the first fieldPath item must be string');
    }

    const childDocField: ContentStoreTypes.DocumentField | undefined = document.fields[fieldName];
    const childModelField: Field | undefined = _.find(model.fields, { name: fieldName });

    if (!childDocField) {
        throw new Error(`document '${docId}' of type '${model.name}' doesn't have a field named '${fieldName}'`);
    }

    if (!childModelField) {
        throw new Error(`model '${model.name}' doesn't have a field named '${fieldName}'`);
    }

    return getField(childDocField, childModelField, childFieldPath);
}
