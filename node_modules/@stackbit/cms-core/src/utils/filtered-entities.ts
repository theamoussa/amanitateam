import * as CSITypes from '@stackbit/types';
import _ from 'lodash';
import { ContentStoreTypes } from '../';
import { STACKBIT_PRESET_MODEL_NAME } from '../consts';
import { getContentSourceDataByIdOrThrow, getContentSourceId } from '../content-store-utils';
import { mapCSIAssetsToStoreAssets } from './csi-to-store-docs-converter';

export const getFilteredDocumentsForUser = ({
    user,
    documents,
    permissionsForModel,
    permissionsForDocument,
    contentSourceDataById,
    createConfigDelegate,
    logger
}: {
    user?: ContentStoreTypes.User;
    permissionsForModel: CSITypes.StackbitConfig['permissionsForModel'];
    permissionsForDocument: CSITypes.StackbitConfig['permissionsForDocument'];
    documents: ContentStoreTypes.Document[];
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    createConfigDelegate: () => CSITypes.ConfigDelegate;
    logger: CSITypes.Logger;
}): ContentStoreTypes.Document[] => {
    if (!user) {
        return documents;
    }

    const documentsBySourceId = _.groupBy(documents, (object) => getContentSourceId(object.srcType, object.srcProjectId));
    const resultDocuments: ContentStoreTypes.Document[] = [];
    const configDelegate = createConfigDelegate();

    for (const [contentSourceId, contentSourceDocuments] of Object.entries(documentsBySourceId)) {
        const contentSourceData = getContentSourceDataByIdOrThrow(contentSourceId, contentSourceDataById);
        const filteredModelsMap: Record<string, CSITypes.Model> = {};

        contentSourceDocuments.forEach((document) => {
            const csiDoc = contentSourceData.csiDocumentMap[document.srcObjectId];
            if (!csiDoc) {
                throw new Error(`Document with id '${document.srcObjectId}' not found in content source '${contentSourceId}'`);
            }
            const modelName = csiDoc.modelName;
            if (!filteredModelsMap[modelName]) {
                filteredModelsMap[modelName] = getFilteredModelForUser({
                    user,
                    name: modelName,
                    contentSourceData,
                    configDelegate,
                    permissionsForModel
                });
            }
            const documentModel = filteredModelsMap[modelName];
            if (!documentModel) {
                throw new Error(
                    `Can't find model with name '${document.srcModelName}' for object with id '${document.srcObjectId}' in content source '${contentSourceId}'`
                );
            }
            const docPermissions = _.defaults(csiDoc.permissions, documentModel.permissions);
            const permissions =
                permissionsForDocument?.({
                    ...configDelegate,
                    document: {
                        ...csiDoc,
                        permissions: docPermissions,
                        srcType: contentSourceData.srcType,
                        srcProjectId: contentSourceData.srcProjectId
                    },
                    userContext: user
                }) ?? docPermissions;
            resultDocuments.push({
                ...document,
                permissions,
                hidden: documentModel.hidden || document.hidden || permissions?.canView === false
            });
            return;
        });
    }

    return resultDocuments;
};

export const getFilteredAssetsForUser = ({
    user,
    assets,
    filterAsset,
    configDelegate,
    contentSourceDataById
}: {
    user?: ContentStoreTypes.User;
    assets: ContentStoreTypes.Asset[];
    filterAsset: CSITypes.StackbitConfig['filterAsset'];
    configDelegate: CSITypes.ConfigDelegate;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): ContentStoreTypes.Asset[] => {
    if (!user || !filterAsset) {
        return _.cloneDeep(assets);
    }

    const assetsBySourceId = _.groupBy(assets, (object) => getContentSourceId(object.srcType, object.srcProjectId));

    const transformedCsiAssets: CSITypes.AssetWithSource[] = [];

    const resultAssets: ContentStoreTypes.Asset[] = [];

    for (const [contentSourceId, contentSourceAssets] of Object.entries(assetsBySourceId)) {
        const contentSourceData = getContentSourceDataByIdOrThrow(contentSourceId, contentSourceDataById);

        contentSourceAssets.forEach((asset) => {
            const csiAsset = contentSourceData.csiAssetMap[asset.srcObjectId];
            if (!csiAsset) {
                throw new Error(`Asset with id '${asset.srcObjectId}' not found in content source '${contentSourceId}'`);
            }

            const csiAssetWithSource: CSITypes.AssetWithSource = {
                ..._.cloneDeep(csiAsset),
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId
            };
            const shouldIncludeAsset = filterAsset({
                ...configDelegate,
                asset: csiAssetWithSource,
                userContext: user
            });
            if (typeof shouldIncludeAsset === 'undefined') {
                transformedCsiAssets.push(csiAssetWithSource);
            } else {
                transformedCsiAssets.push({
                    ...csiAssetWithSource,
                    hidden: !shouldIncludeAsset
                });
            }
        });

        if (transformedCsiAssets.length) {
            const csResultAssets = mapCSIAssetsToStoreAssets({
                csiAssets: transformedCsiAssets,
                contentSourceInstance: contentSourceData.instance,
                defaultLocaleCode: contentSourceData.defaultLocaleCode
            });

            resultAssets.push(...csResultAssets);
        }
    }

    return resultAssets;
};

export const getContentSourceFilteredModelsForUser = ({
    user,
    configDelegate,
    contentSourceData,
    permissionsForModel
}: {
    user?: ContentStoreTypes.User;
    configDelegate: CSITypes.ConfigDelegate;
    contentSourceData: ContentStoreTypes.ContentSourceData;
    permissionsForModel: CSITypes.StackbitConfig['permissionsForModel'];
}): CSITypes.Model[] => {
    const filteredModels = contentSourceData.models.map((model) => {
        return getFilteredModelForUser({
            user,
            configDelegate,
            name: model.name,
            contentSourceData,
            permissionsForModel
        });
    });
    const cleanModels = filteredModels.filter((model) => model.name !== STACKBIT_PRESET_MODEL_NAME);
    return cleanModels;
};

export const getFilteredModelForUser = ({
    user,
    name,
    configDelegate,
    contentSourceData,
    permissionsForModel
}: {
    user?: ContentStoreTypes.User;
    name: string;
    configDelegate: CSITypes.ConfigDelegate;
    contentSourceData: ContentStoreTypes.ContentSourceData;
    permissionsForModel: CSITypes.StackbitConfig['permissionsForModel'];
}): CSITypes.Model => {
    const model = contentSourceData.modelMap[name];
    if (!model) {
        throw new Error(`Model with name ${name} not found in source`);
    }

    const shouldResolvePermissions = permissionsForModel || model?.permissions;
    if (!user || !shouldResolvePermissions) {
        return model;
    }
    const modelWithSource = {
        ..._.cloneDeep(model),
        srcType: contentSourceData.srcType,
        srcProjectId: contentSourceData.srcProjectId
    };

    const permissionsResult =
        typeof model.permissions === 'function' ? model.permissions?.({ ...configDelegate, model: modelWithSource, userContext: user }) : model.permissions;
    const permissionsHookResult =
        permissionsForModel?.({
            ...configDelegate,
            model: { ...modelWithSource, permissions: permissionsResult },
            userContext: user
        }) ?? permissionsResult;
    const permissions = _.isEmpty(permissionsHookResult) ? undefined : permissionsHookResult;

    const shouldHideModel = model.hidden || permissions?.canView === false;
    return {
        ...model,
        permissions,
        hidden: shouldHideModel
    };
};
