const _ = require('lodash');
const fse = require('fs-extra');
const path = require('path');

const { mapPromise, replaceInRange, readDirRec } = require('../utils');
const { LOADER_EXCLUDED_FILES, LOADER_EXCLUDED_DIRS } = require('../consts');

const reactAnnotator = require('./react');
const htmlAnnotator = require('./html');

module.exports = {
    annotateDir,
    annotateFiles,
    decodeSourcemap
};

const FILE_TYPES = ['js', 'jsx', 'ts', 'tsx', 'html', 'htm'];
const MAX_FILE_SIZE = 500 * 1024; // 500kb

async function encodeSourcemap(filePath, data, annotations) {
    let annotatedData = data;
    const sortedAnnotations = _.orderBy(annotations, ['insertOffset'], ['desc']);
    sortedAnnotations.forEach((annotation) => {
        const loc = annotation.sourceLocation;
        const attribute = ` data-sb-source-file="${filePath}" data-sb-source-position="${loc.start.line},${loc.start.column}:${loc.end.line},${loc.end.column}"`;
        annotatedData = replaceInRange(annotatedData, [annotation.insertOffset, annotation.insertOffset], attribute);
    });
    return annotatedData;
}

async function annotateFile(filePath, inputDir, outputDir, annotator, logger, options = {}) {
    const data = (await fse.readFile(path.join(inputDir, filePath))).toString();
    if (!data || data.length > MAX_FILE_SIZE) {
        logger.debug(`[annotator] skipping file: ${filePath}`, { dataLength: _.get(data, 'length') });
        return null;
    }
    // annotator.createAnnotations returns annotations with the following structure:
    // {
    //   insertOffset: number - global character offset in the data where we can insert the annotation data
    //   sourceLocation: { start: Position, end: Position } - span of the entire source block in line+column format
    // }
    const annotations = await annotator.createAnnotations(filePath, data, logger);
    if (_.isEmpty(annotations)) {
        return null;
    }
    const annotatedData = await encodeSourcemap(_.get(options, 'pathPrefix') ? path.join(options.pathPrefix, filePath) : filePath, data, annotations);
    if (_.isEqual(data, annotatedData)) {
        return null;
    }
    const outputFilePath = path.join(outputDir, filePath);
    const existingData = (await fse.pathExists(outputFilePath)) ? (await fse.readFile(outputFilePath)).toString() : null;
    if (_.isEqual(annotatedData, existingData) || (existingData && existingData.includes('data-sb-source-position'))) {
        logger.debug(`[annotator] annotating, but skipping write: ${filePath}`, { annotations: annotations.length });
        return;
    }
    logger.debug(`[annotator] annotating: ${filePath}`, { annotations: annotations.length });
    await fse.writeFile(outputFilePath, annotatedData);
    return outputFilePath;
}

function decodePosition(positionString) {
    const parts = positionString.split(',');
    return {
        line: parseInt(parts[0]),
        column: parseInt(parts[1])
    };
}

function decodeSourcemap(attributes) {
    const sourceFile = _.get(attributes, 'data-sb-source-file');
    const sourcePosition = _.get(attributes, 'data-sb-source-position');
    let sourcemap;
    if (sourceFile) {
        let start, end;
        if (sourcePosition) {
            const parts = sourcePosition.split(':');
            start = decodePosition(parts[0]);
            end = decodePosition(parts[1]);
        }
        sourcemap = {
            file: sourceFile,
            start,
            end
        };
    }
    return sourcemap;
}

async function annotateFiles(filePaths, inputDir, outputDir, logger, options = {}) {
    const result = await mapPromise(filePaths, async (filePath) => {
        const ext = path.extname(filePath).substring(1);
        let annotator = null;
        if (['js', 'jsx', 'ts', 'tsx'].includes(ext)) {
            annotator = reactAnnotator;
        } else if (['html', 'htm'].includes(ext)) {
            annotator = htmlAnnotator;
        }
        if (annotator) {
            return annotateFile(filePath, inputDir, outputDir, annotator, logger, options);
        }
    });
    return _.compact(result);
}

async function annotateDir(inputDir, outputDir, logger, options = {}) {
    logger?.debug('[annotator] annotating dir', { inputDir });
    const filePaths = await readDirRec(inputDir, {
        filter: (filePath, stats) => {
            const p = path.parse(filePath);
            const fileName = p.name;
            const dirName = p.dir;
            const ext = path.extname(filePath).substring(1);
            return (
                !filePath.startsWith('.') &&
                !filePath.includes('node_modules') &&
                (!stats.isFile() ||
                    (FILE_TYPES.includes(ext) &&
                        !['config', '_config'].includes(fileName) &&
                        !_.some(LOADER_EXCLUDED_FILES, (f) => filePath.endsWith(f)) &&
                        !_.some(LOADER_EXCLUDED_DIRS, (f) => dirName.endsWith(f)) &&
                        !fileName.includes('webpack')))
            );
        }
    });
    return annotateFiles(filePaths, inputDir, outputDir, logger, options);
}

if (require.main === module) {
    annotateDir([process.argv[2]], process.argv[3], console);
}
