import * as StackbitTypes from '@stackbit/types';
import { ImageModel, Model } from '@stackbit/sdk';
import { Asset, Document } from './content-store-documents';
import { BackCompatContentSourceInterface } from '../utils/backward-compatibility';
import * as CSITypes from '@stackbit/types';

export type ContentSourceRawData = {
    /* Internal content source id computed by concatenating srcType and srcProjectId */
    id: string;
    /* The content source instance loaded from stackbitConfig.contentSources */
    instance: BackCompatContentSourceInterface;
    destroyed: boolean;
    version: { interfaceVersion: string; contentSourceVersion: string };
    srcType: string;
    srcProjectId: string;
    locales?: StackbitTypes.Locale[];
    defaultLocaleCode?: string;
    /* Array of original Models (as provided by content source)  */
    csiSchema: StackbitTypes.Schema;
    csiModels: StackbitTypes.Model[];
    /* Map of original Models (as provided by content source) by model name */
    csiModelMap: Record<string, StackbitTypes.Model>;
    /* Array of original content source Documents */
    csiDocuments: StackbitTypes.Document[];
    /* Map of original content source Documents by document ID */
    csiDocumentMap: Record<string, StackbitTypes.Document>;
    /* Array of original content source Assets */
    csiAssets: StackbitTypes.Asset[];
    /* Map of original content source Assets by asset ID */
    csiAssetMap: Record<string, StackbitTypes.Asset>;
    /* Array of converted content-store Assets */
    assets: Asset[];
    /* Map of converted content-store Assets by asset ID */
    assetMap: Record<string, Asset>;
    // Array of converted scheduled actions (publishes)
    scheduledActions: StackbitTypes.ScheduledAction[];
    // Content source documents and assets sync context
    syncContext?: { documentsSyncContext?: unknown; assetsSyncContext?: unknown };
    /* Map of advanced features to enable in the studio client */
    enabledFeatures: {
        unpublish: boolean;
        archive: boolean;
        unarchive: boolean;
        scheduledActions: boolean;
        documentVersions: boolean;
        assetsEditing?: boolean;
    };
};

export type ProvisionalData = Pick<ContentSourceRawData, 'srcType' | 'srcProjectId'> &
    Partial<
        Pick<
            ContentSourceRawData,
            'syncContext' | 'csiSchema' | 'csiModelMap' | 'csiDocuments' | 'csiDocumentMap' | 'csiAssets' | 'csiAssetMap' | 'scheduledActions'
        >
    >;

export type ContentSourceData = ContentSourceRawData & {
    /* Array of extended and validated Models */
    models: Model[];
    /* Map of extended and validated Models by model name */
    modelMap: Record<string, Model>;
    /* Array of converted content-store Documents */
    documents: Document[];
    /* Map of converted content-store Documents by document ID */
    documentMap: Record<string, Document>;
};

export const ContentStoreEventType = {
    YamlModelFilesChange: 'yamlModelFilesChange',
    PresetFilesChange: 'presetFilesChange',
    ContentSourceInvalidateSchema: 'contentSourceInvalidateSchema',
    ContentSourceContentChange: 'contentSourceContentChange',
    ContentSourceRequestSync: 'contentSourceRequestSync'
} as const;

export type ContentStoreEvent =
    | {
          eventName: typeof ContentStoreEventType.YamlModelFilesChange;
      }
    | {
          eventName: typeof ContentStoreEventType.PresetFilesChange;
      }
    | {
          eventName: typeof ContentStoreEventType.ContentSourceInvalidateSchema;
          contentSourceId: string;
      }
    | {
          eventName: typeof ContentStoreEventType.ContentSourceContentChange;
          contentSourceId: string;
          contentChanges: CSITypes.ContentChanges;
      }
    | {
          eventName: typeof ContentStoreEventType.ContentSourceRequestSync;
          contentSourceId: string;
          options: Parameters<CSITypes.Cache['requestSync']>[0];
      };

export interface UploadAssetData {
    url: string;
    data?: string;
    metadata: {
        name: string;
        type: string;
    };
}

export type OnFilesChangeResponse = {
    contentChanged?: boolean;
    codeChanged?: boolean;
    contentFiles: string[];
};

export type ContentChangeType = 'added' | 'modified' | 'deleted';

export interface ContentChangeItem {
    srcType: string;
    srcProjectId: string;
    srcObjectId: string;
}

export interface ContentChangeResultItem extends ContentChangeItem {
    type: ContentChangeType;
    srcObjectType: 'document' | 'asset';
}

export interface ContentChangeScheduledAction {
    srcType: string;
    srcProjectId: string;
    scheduledActionId: string;
}

export interface ContentChangeResultScheduledAction extends ContentChangeScheduledAction {
    type: ContentChangeType;
}

export interface ContentChangeResult {
    createdDocuments: ContentChangeItem[];
    createdAssets: ContentChangeItem[];
    createdScheduledActions: ContentChangeScheduledAction[];
    updatedDocuments: ContentChangeItem[];
    updatedAssets: ContentChangeItem[];
    updatedScheduledActions: ContentChangeScheduledAction[];
    deletedDocuments: ContentChangeItem[];
    deletedAssets: ContentChangeItem[];
    deletedScheduledActions: ContentChangeScheduledAction[];
}

export interface User {
    id: string;
    name: string;
    email: string;
    role?: string;
    sso?: StackbitTypes.UserSSOProfile;
    connections: {
        type: string;
        [key: string]: any;
    }[];
}

export interface ValidationError {
    message: string;
    srcType: string;
    srcProjectId: string;
    srcObjectType: string;
    srcObjectId: string;
    fieldPath: (string | number)[];
    isUniqueValidation?: boolean;
}

export interface HasAccessResult {
    hasConnection: boolean;
    hasPermissions: boolean;
    contentSources: {
        srcType: string;
        srcProjectId: string;
        hasConnection: boolean;
        hasPermissions: boolean;
    }[];
}

export interface CrossReferenceData {
    refId: string;
    refSrcType: string;
    refProjectId: string;
}

export interface ContentStoreLocale {
    srcType: string;
    srcProjectId: string;
    locales: string[];
    defaultLocale: string | undefined;
}

export type RecordSchema = Record<string, Record<string, Record<string, Model | ImageModel>>>;

export type FieldFile = StackbitTypes.FieldCommonProps & { type: 'assetFile' };

export type AssetModelField = StackbitTypes.FieldString | StackbitTypes.FieldText | FieldFile;

export type AssetModel = {
    type: 'asset';
    name: '__asset_model';
    label?: string;
    labelField?: string;
    fields?: AssetModelField[];
};
