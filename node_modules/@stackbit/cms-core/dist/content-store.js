"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentStore = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const sanitize_filename_1 = __importDefault(require("sanitize-filename"));
const types_1 = require("@stackbit/types");
const sdk_1 = require("@stackbit/sdk");
const utils_1 = require("@stackbit/utils");
const timer_1 = require("./utils/timer");
const types_2 = require("./types");
const search_utils_1 = require("./utils/search-utils");
const csi_to_store_docs_converter_1 = require("./utils/csi-to-store-docs-converter");
const content_store_utils_1 = require("./content-store-utils");
const site_map_1 = require("./utils/site-map");
const store_to_api_docs_converter_1 = require("./utils/store-to-api-docs-converter");
const store_to_api_v2_docs_converter_1 = require("./utils/store-to-api-v2-docs-converter");
const create_update_csi_docs_1 = require("./utils/create-update-csi-docs");
const duplicate_document_1 = require("./utils/duplicate-document");
const model_utils_1 = require("./utils/model-utils");
const common_schema_1 = require("./common/common-schema");
const preset_utils_1 = require("./utils/preset-utils");
const backward_compatibility_1 = require("./utils/backward-compatibility");
const config_delegate_1 = require("./utils/config-delegate");
const asset_sources_utils_1 = require("./utils/asset-sources-utils");
const document_hooks_1 = require("./utils/document-hooks");
const custom_actions_1 = require("./utils/custom-actions");
const tree_views_1 = require("./utils/tree-views");
const field_path_utils_1 = require("./utils/field-path-utils");
const user_log_utils_1 = require("./utils/user-log-utils");
const content_engine_1 = require("@netlify/content-engine");
const csi_to_api_docs_converter_1 = require("./utils/csi-to-api-docs-converter");
const file_cache_1 = require("./utils/file-cache");
const filtered_entities_1 = require("./utils/filtered-entities");
const consts_1 = require("./consts");
const content_store_data_manager_1 = require("./utils/content-store-data-manager");
const references_utils_1 = require("./utils/references-utils");
const _1 = require("./");
const document_validations_1 = require("./utils/document-validations");
class ContentStore {
    constructor(options) {
        this.contentSources = [];
        this.contentSourceDataById = {};
        this.stackbitConfig = null;
        this.yamlModels = [];
        this.configModels = [];
        this.modelExtensions = null;
        this.presets = {};
        this.siteMapEntryGroups = {};
        this.processingContentSourcesPromise = null;
        this.contentStoreEventQueue = [];
        this.treeViews = [];
        this.customActionRunStateMap = {};
        this.referenceMap = {};
        this.logger = options.logger.createLogger({ label: 'content-store' });
        this.userLogger = options.userLogger.createLogger({ label: 'content-store' });
        this.isLocalDev = options.isLocalDev;
        this.isDevServer = options.isDevServer;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.webhookUrl = options.webhookUrl;
        this.runCommand = options.runCommand;
        this.git = options.git;
        this.userCommandSpawner = options.userCommandSpawner;
        this.onSchemaChangeCallback = options.onSchemaChangeCallback;
        this.onContentChangeCallback = options.onContentChangeCallback;
        this.onActionStateChangeCallback = options.onActionStateChangeCallback;
        this.handleConfigAssets = options.handleConfigAssets;
        this.contentUpdatesWatchTimer = new timer_1.Timer({ timerCallback: () => this.handleTimerTimeout(), logger: this.logger });
        this.devAppRestartNeeded = options.devAppRestartNeeded;
        // The `loadContentSourcesAndProcessData` method can be called multiple times rapidly for several reasons:
        // stackbit.config.js updated, one of the preset or the yaml-model files changed, one of the content-source's
        // schema files updated (for example Sanity's schema files).
        // Therefore, to prevent parallel executions of this method and corrupting the ContentStore state,
        // debounce rapid invocations of this method and defer invocation while this method is running.
        this.loadContentSourcesAndProcessData = (0, utils_1.deferWhileRunning)(this.loadContentSourcesAndProcessData, {
            thisArg: this,
            debounceDelay: 100,
            debounceMaxDelay: 500,
            // When the loadContentSourcesAndProcessData is called multiple times with different arguments,
            // ensure that the deferred call will be called with the lowest denominator of the passed arguments.
            argsResolver: ({ nextArgs, prevArgs }) => {
                // If at least one call had "init: true" then call the deferred
                // function with "init: true" and without invalidateSchemaForContentSourceIds.
                const init = nextArgs[0].init || Boolean(prevArgs?.[0].init);
                if (init) {
                    return [{ init }];
                }
                // If at least one call had "startWatchingContentUpdates: true" then call the deferred
                // function with "startWatchingContentUpdates: true".
                const startWatchingContentUpdates = nextArgs[0].startWatchingContentUpdates || Boolean(prevArgs?.[0].startWatchingContentUpdates);
                // If at least one call had "invalidateSchemaForContentSourceIds: undefined" (signal to reload all content sources)
                // then call the deferred function with "invalidateSchemaForContentSourceIds: undefined",
                // otherwise call it with union of content source ids.
                const invalidateSchemaForContentSourceIds = typeof nextArgs[0].invalidateSchemaForContentSourceIds === 'undefined' ||
                    (prevArgs && typeof prevArgs[0].invalidateSchemaForContentSourceIds === 'undefined')
                    ? undefined
                    : lodash_1.default.union(nextArgs[0].invalidateSchemaForContentSourceIds, prevArgs?.[0].invalidateSchemaForContentSourceIds);
                return [{ init, startWatchingContentUpdates, invalidateSchemaForContentSourceIds }];
            }
        });
        this.processContentStoreEvents = (0, utils_1.deferWhileRunning)(this.processContentStoreEvents, { thisArg: this });
    }
    async init({ stackbitConfig }) {
        this.logger.debug('init');
        this.stackbitConfig = stackbitConfig;
        if (stackbitConfig) {
            if (stackbitConfig.modelExtensions) {
                this.modelExtensions = stackbitConfig.modelExtensions;
            }
            else {
                this.yamlModels = await this.loadYamlModels({ stackbitConfig });
                this.configModels = this.mergeConfigModels(stackbitConfig.models ?? [], this.yamlModels);
            }
        }
        await this.loadContentSourcesAndProcessData({ init: true });
        this.contentUpdatesWatchTimer.startTimer();
    }
    async onStackbitConfigChange({ stackbitConfig }) {
        this.logger.debug('onStackbitConfigChange');
        this.stackbitConfig = stackbitConfig;
        if (stackbitConfig) {
            if (stackbitConfig.modelExtensions) {
                this.modelExtensions = stackbitConfig.modelExtensions;
            }
            else {
                this.configModels = this.mergeConfigModels(stackbitConfig.models ?? [], this.yamlModels);
            }
        }
        await this.loadContentSourcesAndProcessData({ init: true });
    }
    /**
     * This method is called when contentUpdatesWatchTimer receives timeout.
     * This happens when the user is not using the Stackbit app for some time
     * but container is not hibernated.
     * It then notifies all content sources to stop watching for content
     * changes, which in turn stops polling CMS for content changes and helps
     * reducing the CMS API usage.
     */
    handleTimerTimeout() {
        for (const contentSourceInstance of this.contentSources) {
            contentSourceInstance.stopWatchingContentUpdates?.();
        }
    }
    /**
     * This method is called when user interacts with Stackbit application.
     * It is used to reset contentUpdatesWatchTimer. When the timer is over
     * all content sources are notified to stop watching for content updates.
     */
    async keepAlive() {
        if (this.contentUpdatesWatchTimer.isRunning()) {
            this.contentUpdatesWatchTimer.resetTimer();
            return;
        }
        this.logger.debug('keepAlive => contentUpdatesWatchTimer is not running => load content source data');
        this.contentUpdatesWatchTimer.startTimer();
        await this.loadContentSourcesAndProcessData({ init: false, startWatchingContentUpdates: true });
    }
    async destroy() {
        this.contentUpdatesWatchTimer.stopTimer();
        for (const contentSourceInstance of this.contentSources) {
            contentSourceInstance.stopWatchingContentUpdates?.();
            await contentSourceInstance.destroy?.();
        }
        // TODO: add destroy() method to the contentEngine to ensure it cleans
        //  and stops any servers, listeners and timeouts.
        // this.contentEngine?.destroy();
    }
    async onFilesChange(updatedFiles, dryRun) {
        this.logger.debug('onFilesChange');
        const result = {
            contentChanged: false,
            codeChanged: false,
            contentFiles: []
        };
        if (this.stackbitConfig && !this.stackbitConfig.modelExtensions) {
            // Check if any of the yaml models files were changed. If yaml model files were changed,
            // reload them and merge them with models defined in stackbit config.
            const modelDirs = (0, sdk_1.getYamlModelDirs)(this.stackbitConfig);
            const yamlModelsChanged = updatedFiles.find((updatedFile) => lodash_1.default.some(modelDirs, (modelDir) => updatedFile.startsWith(modelDir)));
            if (yamlModelsChanged) {
                result.codeChanged = true;
                if (!dryRun && !this.isDevServer) {
                    this.logger.debug('identified change in stackbit model files');
                    this.yamlModels = await this.loadYamlModels({ stackbitConfig: this.stackbitConfig });
                    this.configModels = this.mergeConfigModels(this.stackbitConfig.models ?? [], this.yamlModels);
                    this.pushContentSourceEvent({
                        eventName: types_2.ContentStoreEventType.YamlModelFilesChange
                    });
                }
            }
        }
        let totalContentFiles = 0;
        if (this.stackbitConfig) {
            // Check if any of the preset files were changed. If presets were changed, reload them.
            const presetDirs = (0, sdk_1.getPresetDirs)(this.stackbitConfig);
            const presetsChanged = updatedFiles.filter((updatedFile) => lodash_1.default.some(presetDirs, (presetDir) => updatedFile.startsWith(presetDir)));
            if (presetsChanged.length && !this.usesContentSourcePresets()) {
                totalContentFiles += presetsChanged.length;
                result.contentChanged = true;
                result.contentFiles.push(...presetsChanged);
                if (!dryRun) {
                    this.logger.debug('identified change in stackbit preset files');
                    this.presets = await this.loadPresetsFromConfig({ stackbitConfig: this.stackbitConfig });
                    this.pushContentSourceEvent({
                        eventName: types_2.ContentStoreEventType.PresetFilesChange
                    });
                }
            }
        }
        for (const contentSourceInstance of this.contentSources) {
            const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(contentSourceInstance);
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (contentSourceData?.destroyed) {
                this.logger.debug(`contentSource '${contentSourceId}' was destroyed, don't call onFilesChange`);
                continue;
            }
            this.logger.debug(`call onFilesChange for contentSource: ${contentSourceId}`);
            // isGitCms is internal flag which used to show us it's a git/fs content source
            const isGitCS = contentSourceInstance.isGitCms;
            // dont execute on dev servers unless it's git
            const shouldExecute = !this.isDevServer || isGitCS;
            const onFilesChangeResult = shouldExecute ? await contentSourceInstance.onFilesChange({ updatedFiles }) : undefined;
            const changedContentFiles = (onFilesChangeResult?.contentChanges?.documents?.length ?? 0) +
                (onFilesChangeResult?.contentChanges?.assets?.length ?? 0) +
                (onFilesChangeResult?.contentChanges?.deletedDocumentIds?.length ?? 0) +
                (onFilesChangeResult?.contentChanges?.deletedAssetIds?.length ?? 0);
            totalContentFiles += changedContentFiles;
            if (changedContentFiles > 0) {
                result.contentChanged = true;
                const allChangedEntities = [...(onFilesChangeResult?.contentChanges?.documents ?? []), ...(onFilesChangeResult?.contentChanges?.assets ?? [])];
                [...(onFilesChangeResult?.contentChanges?.deletedDocumentIds ?? []), ...(onFilesChangeResult?.contentChanges?.deletedAssetIds ?? [])].forEach((documentId) => {
                    const document = contentSourceData?.csiDocumentMap[documentId];
                    if (document) {
                        allChangedEntities.push(document);
                    }
                });
                allChangedEntities.forEach((entity) => {
                    if (typeof entity.context === 'object' && entity.context && 'filePath' in entity.context && typeof entity.context.filePath === 'string') {
                        result.contentFiles.push(entity.context.filePath);
                    }
                });
            }
            if (onFilesChangeResult?.invalidateSchema) {
                result.codeChanged = true;
            }
            // If the schema was changed in a specific content source, there is no need to process and notify for content changes.
            // Because the schema changes will trigger loadContentSourcesAndProcessData and reload all models and content of that
            // content source and send the schemaChanged notification that will cause the Studio to reload the schema and documents.
            if (!dryRun && shouldExecute) {
                if (onFilesChangeResult?.invalidateSchema) {
                    this.logger.debug(`schema was invalidated for contentSource: ${contentSourceId}`);
                    this.pushContentSourceEvent({
                        eventName: types_2.ContentStoreEventType.ContentSourceInvalidateSchema,
                        contentSourceId: contentSourceId
                    });
                }
                else if (onFilesChangeResult && !(0, content_store_utils_1.isContentChangesEmpty)(onFilesChangeResult.contentChanges)) {
                    this.logger.debug(`content was changed for contentSource: ${contentSourceId}`);
                    this.pushContentSourceEvent({
                        eventName: types_2.ContentStoreEventType.ContentSourceContentChange,
                        contentSourceId: contentSourceId,
                        contentChanges: onFilesChangeResult.contentChanges
                    });
                }
            }
        }
        if (totalContentFiles < updatedFiles.length) {
            result.codeChanged = true;
        }
        if (!dryRun) {
            await this.processContentStoreEvents();
        }
        return result;
    }
    async loadYamlModels({ stackbitConfig }) {
        const yamlModelsResult = await (0, sdk_1.loadYamlModelsFromFiles)(stackbitConfig);
        for (const error of yamlModelsResult.errors) {
            this.userLogger.warn(error.message);
        }
        return yamlModelsResult.models;
    }
    mergeConfigModels(configModels, modelsFromFiles) {
        const configModelsResult = (0, sdk_1.mergeConfigModelsWithModelsFromFiles)(configModels, modelsFromFiles);
        for (const error of configModelsResult.errors) {
            this.userLogger.warn(error.message);
        }
        return configModelsResult.models;
    }
    async loadPresetsFromConfig({ stackbitConfig }) {
        const contentSources = stackbitConfig?.contentSources ?? [];
        const singleContentSource = contentSources.length === 1 ? contentSources[0] : null;
        const presetResult = await (0, sdk_1.loadPresets)({
            config: stackbitConfig,
            ...(singleContentSource
                ? {
                    fallbackSrcType: singleContentSource.getContentSourceType(),
                    fallbackSrcProjectId: singleContentSource.getProjectId()
                }
                : null)
        });
        for (const error of presetResult.errors) {
            this.userLogger.warn(error.message);
        }
        const { presets } = await this.handleConfigAssets({ presets: presetResult.presets });
        return presets;
    }
    async loadPresetsFromContentSource(contentSourceData) {
        const presets = lodash_1.default.reduce(contentSourceData.csiDocuments, (result, csiDocument) => {
            if (csiDocument.modelName === consts_1.STACKBIT_PRESET_MODEL_NAME) {
                const preset = (0, preset_utils_1.getPresetFromDocument)({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    csiDocument,
                    csiAssetMap: contentSourceData.csiAssetMap,
                    logger: this.logger
                });
                if (preset) {
                    result[csiDocument.id] = preset;
                }
            }
            return result;
        }, {});
        return presets;
    }
    /**
     * If any content sources implement the `getContentEngineConfig` method then this function gets all
     * of these plugin definitions and creates the content engine.
     */
    async createContentEngineIfNeeded() {
        const logger = this.userLogger.createLogger({ label: 'content-engine' });
        // TODO: The stackbit.config.ts can be updated with new connectors, or
        //  new connector options. In this case, we need to destroy existing
        //  contentEngine and create a new one.
        if (this.contentEngine) {
            logger.debug(`Content Engine already exists, cannot recreate it as it's running in this process. To recreate it with updated config options the current process must be restarted.`);
            return;
        }
        const contentSources = this.contentSources || [];
        const plugins = Array.from(new Set(contentSources.flatMap((contentSource) => contentSource.getContentEngineConfig?.()?.plugins).filter(Boolean)));
        if (plugins.length < 1) {
            return;
        }
        logger.info('Creating content engine');
        this.contentEngine = (0, content_engine_1.contentEngine)({
            directory: this.stackbitConfig?.dirPath,
            pluginDirectories: [path_1.default.join(this.stackbitConfig?.dirPath || process.cwd(), `.stackbit/.cache/remote-content-sources`)],
            port: this.stackbitConfig?.contentEngine?.port,
            host: this.stackbitConfig?.contentEngine?.host,
            engineConfig: {
                plugins
            },
            // content engine must run in the same process so that unified connectors can share state in memory
            runInSubProcess: false
            // TODO: pass the logger and the userLogger to the contentEngine to
            //  allow printing internal and user-facing logs.
            // logger
            // userLogger
        });
    }
    /**
     * This function reloads the data of the specified content-sources, while
     * reusing the cached data of the rest of the content-sources, then processes
     * the content sources' data by merging it with models defined in
     * stackbit.config.js and yaml-model files.
     *
     * This function is wrapped by `deferWhileRunning` ensuring this method is
     * invoked one at a time.
     *
     * @param {boolean} init Flag specifying if the content sources need to be initialized or reset.
     *   The content sources need to be (re-)initialized only when the stackbit.config.js was reloaded.
     *   In all other cases content sources can be reset.
     * @param {string[] | undefined} invalidateSchemaForContentSourceIds Array of content source IDs to reload.
     *   If not provided or set to "undefined", will reload all content sources.
     *   If set to empty array will not reload any content sources and only process their cached data.
     * @private
     */
    async loadContentSourcesAndProcessData({ init, startWatchingContentUpdates, invalidateSchemaForContentSourceIds }) {
        this.logger.debug('loadContentSourcesAndProcessData', { init, invalidateSchemaForContentSourceIds });
        if (this.processingContentSourcesPromise) {
            // for internal monitoring
            this.logger.error('ALERT, called loadContentSourcesAndProcessData while still processing the previous call');
        }
        this.processingContentSourcesPromise = (0, utils_1.deferredPromise)();
        // On init, get the new content source instances from the config and wrap them with backward compatibility Proxy.
        // Otherwise, reuse existing proxy wrapped backward compatible content sources.
        const contentSources = init || this.contentSources.length === 0
            ? (this.stackbitConfig?.contentSources ?? []).map((contentSource) => {
                return (0, backward_compatibility_1.backwardCompatibleContentSource)(contentSource);
            })
            : this.contentSources;
        this.contentSources = contentSources;
        if (init) {
            this.logger.debug('init content sources');
            await this.createContentEngineIfNeeded();
        }
        const promises = contentSources.map((contentSourceInstance) => {
            const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(contentSourceInstance);
            if (init || !invalidateSchemaForContentSourceIds || invalidateSchemaForContentSourceIds.includes(contentSourceId)) {
                return this.loadContentSourceData({ contentSourceInstance, init, startWatchingContentUpdates });
            }
            else {
                return Promise.resolve(lodash_1.default.omit(this.contentSourceDataById[contentSourceId], ['models', 'modelMap', 'documents', 'documentMap']));
            }
        });
        const contentSourceRawDataArr = await Promise.all(promises);
        // find first content source that supports presets
        for (let i = 0; i < contentSources.length; i++) {
            const contentSourceDataRaw = contentSourceRawDataArr[i];
            if (contentSourceDataRaw?.csiModelMap?.[consts_1.STACKBIT_PRESET_MODEL_NAME]) {
                this.presetsContentSource = contentSourceDataRaw.instance;
                // reload presets from content source only if needed
                if (init || !invalidateSchemaForContentSourceIds || invalidateSchemaForContentSourceIds.includes(contentSourceDataRaw.id)) {
                    this.presets = await this.loadPresetsFromContentSource(contentSourceDataRaw);
                }
                break;
            }
        }
        // fallback to loading presets from config as usual
        if (init && this.stackbitConfig && !this.presetsContentSource) {
            this.presets = await this.loadPresetsFromConfig({ stackbitConfig: this.stackbitConfig });
        }
        // update all content sources at once to prevent race conditions
        this.contentSourceDataById = await this.processData({
            stackbitConfig: this.stackbitConfig,
            configModels: this.modelExtensions ?? this.configModels ?? [],
            presets: this.presets,
            contentSourceRawDataArr: contentSourceRawDataArr
        });
        const configDelegate = (0, config_delegate_1.createConfigDelegate)({
            contentSourceDataById: this.contentSourceDataById,
            logger: this.userLogger
        });
        // generate create site map entries
        this.siteMapEntryGroups = await (0, site_map_1.getSiteMapEntriesFromStackbitConfig)({
            stackbitConfig: this.stackbitConfig,
            contentSourceDataById: this.contentSourceDataById,
            configDelegate
        });
        this.treeViews = await (0, tree_views_1.getSanitizedTreeViews)({
            configDelegate,
            stackbitConfig: this.stackbitConfig,
            contentSourceDataById: this.contentSourceDataById,
            logger: this.userLogger
        });
        this.calculateReferenceMap();
        if (!init) {
            this.onSchemaChangeCallback();
        }
        this.logger.debug('loadContentSourcesAndProcessData finished', { init, invalidateSchemaForContentSourceIds });
        const processingPromise = this.processingContentSourcesPromise;
        this.processingContentSourcesPromise = null;
        processingPromise.resolve();
    }
    async processContentStoreEvents() {
        // If the ContentStore is loading content sources, i.e., the loadContentSourcesAndProcessData() is running,
        // wait for it to finish to prevent parallel data updates.
        if (this.processingContentSourcesPromise) {
            this.logger.debug('processContentStoreEvents, processing content sources, delaying execution');
            await this.processingContentSourcesPromise.promise;
        }
        if (this.contentStoreEventQueue.length === 0) {
            return;
        }
        const contentSourceEvents = this.contentStoreEventQueue;
        this.contentStoreEventQueue = [];
        this.logger.debug('processContentStoreEvents: ' +
            contentSourceEvents.map((event) => event.eventName + ('contentSourceId' in event ? ` (${event.contentSourceId})` : '')).join(', '));
        const invalidateSchemaForContentSourceIds = [];
        const contentChanges = {
            createdDocuments: [],
            createdAssets: [],
            createdScheduledActions: [],
            updatedDocuments: [],
            updatedAssets: [],
            updatedScheduledActions: [],
            deletedDocuments: [],
            deletedAssets: [],
            deletedScheduledActions: []
        };
        let invalidateSchema = false;
        let presetsUpdated = false;
        for (const contentSourceEvent of contentSourceEvents) {
            if (contentSourceEvent.eventName === types_2.ContentStoreEventType.YamlModelFilesChange ||
                contentSourceEvent.eventName === types_2.ContentStoreEventType.PresetFilesChange) {
                invalidateSchema = true;
            }
            else if (contentSourceEvent.eventName === types_2.ContentStoreEventType.ContentSourceInvalidateSchema) {
                invalidateSchema = true;
                invalidateSchemaForContentSourceIds.push(contentSourceEvent.contentSourceId);
            }
            else if (contentSourceEvent.eventName === types_2.ContentStoreEventType.ContentSourceContentChange ||
                contentSourceEvent.eventName === types_2.ContentStoreEventType.ContentSourceRequestSync) {
                let result;
                if (contentSourceEvent.eventName === types_2.ContentStoreEventType.ContentSourceRequestSync) {
                    const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceEvent.contentSourceId);
                    const { contentChangesData, syncContext } = await (0, content_store_data_manager_1.syncContentSource)({ contentSourceData, contentSourceEvent });
                    result = this.onContentChange(contentSourceEvent.contentSourceId, contentChangesData);
                    contentSourceData.syncContext = syncContext;
                    // Sync results to disk
                    const syncFieldCache = new file_cache_1.FileCache({
                        dirPath: (0, content_store_utils_1.getCacheDir)(this.stackbitConfig),
                        keyPrefix: `${contentSourceEvent.contentSourceId}/sync.`
                    });
                    if (syncContext?.documentsSyncContext || syncContext?.assetsSyncContext) {
                        await syncFieldCache.set('context', syncContext);
                        if (result.contentChangeResult.createdDocuments.length ||
                            result.contentChangeResult.updatedDocuments.length ||
                            result.contentChangeResult.deletedDocuments.length) {
                            await syncFieldCache.set('documents', contentSourceData.csiDocuments);
                        }
                        if (result.contentChangeResult.createdAssets.length ||
                            result.contentChangeResult.updatedAssets.length ||
                            result.contentChangeResult.deletedAssets.length) {
                            await syncFieldCache.set('assets', contentSourceData.csiAssets);
                        }
                    }
                    else {
                        await syncFieldCache.remove('context');
                        await syncFieldCache.remove('schema');
                        await syncFieldCache.remove('documents');
                        await syncFieldCache.remove('assets');
                    }
                }
                else {
                    result = this.onContentChange(contentSourceEvent.contentSourceId, contentSourceEvent.contentChanges);
                }
                contentChanges.createdDocuments = contentChanges.createdDocuments.concat(result.contentChangeResult.createdDocuments);
                contentChanges.createdAssets = contentChanges.createdAssets.concat(result.contentChangeResult.createdAssets);
                contentChanges.createdScheduledActions = contentChanges.createdScheduledActions.concat(result.contentChangeResult.createdScheduledActions);
                contentChanges.updatedDocuments = contentChanges.updatedDocuments.concat(result.contentChangeResult.updatedDocuments);
                contentChanges.updatedAssets = contentChanges.updatedAssets.concat(result.contentChangeResult.updatedAssets);
                contentChanges.updatedScheduledActions = contentChanges.updatedScheduledActions.concat(result.contentChangeResult.updatedScheduledActions);
                contentChanges.deletedDocuments = contentChanges.deletedDocuments.concat(result.contentChangeResult.deletedDocuments);
                contentChanges.deletedAssets = contentChanges.deletedAssets.concat(result.contentChangeResult.deletedAssets);
                contentChanges.deletedScheduledActions = contentChanges.deletedScheduledActions.concat(result.contentChangeResult.deletedScheduledActions);
                if (result.presetsUpdated) {
                    presetsUpdated = true;
                }
            }
        }
        // If the schema was changed, call loadContentSourcesAndProcessData method, this will reload all the SiteMapEntries and call the onSchemaChangeCallback.
        // As soon as the Studio receives the schemaChanged notification it will reload all the models and the documents.
        if (invalidateSchema) {
            this.logger.debug('processContentStoreEvents => invalidateSchema');
            await this.loadContentSourcesAndProcessData({
                init: false,
                invalidateSchemaForContentSourceIds
            });
        }
        else {
            this.logger.debug('processContentStoreEvents => content changes', { ...(0, content_store_utils_1.contentChangeResultCounts)(contentChanges), presetsUpdated });
            const configDelegate = (0, config_delegate_1.createConfigDelegate)({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            // If the schema wasn't changed, update SiteMapEntries with the changed content.
            this.siteMapEntryGroups = await (0, site_map_1.updateSiteMapEntriesWithContentChanges)({
                siteMapEntryGroups: this.siteMapEntryGroups,
                contentChanges: contentChanges,
                stackbitConfig: this.stackbitConfig,
                contentSourceDataById: this.contentSourceDataById,
                configDelegate
            });
            this.treeViews = await (0, tree_views_1.getSanitizedTreeViews)({
                configDelegate,
                stackbitConfig: this.stackbitConfig,
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            // If presets were updated, call onSchemaChangeCallback to notify the Studio.
            // The Studio will refresh the models and the documents, so no need to notify
            // content changes in this case.
            if (presetsUpdated) {
                this.onSchemaChangeCallback();
            }
            else if (!(0, content_store_utils_1.isContentChangeResultEmpty)(contentChanges)) {
                this.calculateReferenceMap();
                this.onContentChangeCallback(contentChanges);
            }
        }
    }
    pushContentSourceEvent(contentStoreEvent) {
        if (contentStoreEvent.eventName === types_2.ContentStoreEventType.ContentSourceContentChange ||
            contentStoreEvent.eventName === types_2.ContentStoreEventType.ContentSourceRequestSync) {
            // If a content source enqueued the 'contentSourceInvalidateSchema' event,
            // don't push the 'contentSourceContentChange' or the 'contentSourceRequestSync' events,
            // because 'contentSourceInvalidateSchema' will reload all the content source data anyway.
            const hasContentSourceSchemaChangeEvent = this.contentStoreEventQueue.find((event) => event.eventName === types_2.ContentStoreEventType.ContentSourceInvalidateSchema && event.contentSourceId === contentStoreEvent.contentSourceId);
            if (!hasContentSourceSchemaChangeEvent) {
                this.contentStoreEventQueue.push(contentStoreEvent);
            }
        }
        else if (contentStoreEvent.eventName === types_2.ContentStoreEventType.ContentSourceInvalidateSchema) {
            // Clear any 'contentSourceContentChange' and 'contentSourceRequestSync' events for a content source,
            // the 'contentSourceInvalidateSchema' will reload all the content source data.
            this.clearEventsForContentSourceId(contentStoreEvent.contentSourceId);
            this.contentStoreEventQueue.push(contentStoreEvent);
        }
        else if (contentStoreEvent.eventName === types_2.ContentStoreEventType.YamlModelFilesChange) {
            this.contentStoreEventQueue = this.contentStoreEventQueue.filter((event) => event.eventName !== types_2.ContentStoreEventType.YamlModelFilesChange);
            this.contentStoreEventQueue.push(contentStoreEvent);
        }
        else if (contentStoreEvent.eventName === types_2.ContentStoreEventType.PresetFilesChange) {
            this.contentStoreEventQueue = this.contentStoreEventQueue.filter((event) => event.eventName !== types_2.ContentStoreEventType.PresetFilesChange);
            this.contentStoreEventQueue.push(contentStoreEvent);
        }
    }
    clearEventsForContentSourceId(contentSourceId) {
        this.contentStoreEventQueue = this.contentStoreEventQueue.filter((contentSourceEvent) => {
            if (contentSourceEvent.eventName === types_2.ContentStoreEventType.ContentSourceContentChange ||
                contentSourceEvent.eventName === types_2.ContentStoreEventType.ContentSourceRequestSync ||
                contentSourceEvent.eventName === types_2.ContentStoreEventType.ContentSourceInvalidateSchema) {
                return contentSourceEvent.contentSourceId !== contentSourceId;
            }
            return true;
        });
    }
    async loadContentSourceData({ contentSourceInstance, init, startWatchingContentUpdates }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(contentSourceInstance);
        const contentEngineConfig = contentSourceInstance.getContentEngineConfig?.();
        // If contentEngine is available, start its sync(), store its promise,
        // and await for it at the end of this function instead of awaiting here.
        // Unified connectors are synchronized on the CSI methods such as the
        // getSchema() which is called below, so the promise returned by the
        // sync() method is resolved after the getSchema() method is called.
        // Waiting for this promise before calling the CSI methods will result
        // in a dead-lock.
        const contentEngineSyncPromise = contentEngineConfig && this.contentEngine
            ? this.contentEngine.sync({
                buildSchema: true,
                connector: contentEngineConfig.connector
            })
            : Promise.resolve();
        this.logger.debug('loadContentSourceData', { contentSourceId, init });
        // clear content source events emitted by this content source because all the content source data is reloaded
        this.clearEventsForContentSourceId(contentSourceId);
        const syncFieldCache = new file_cache_1.FileCache({
            dirPath: (0, content_store_utils_1.getCacheDir)(this.stackbitConfig),
            keyPrefix: `${contentSourceId}/sync.`
        });
        const cachedSyncContext = (await syncFieldCache.get('context'));
        const cachedSchema = (await syncFieldCache.get('schema'));
        const cachedDocuments = (await syncFieldCache.get('documents'));
        const cachedAssets = (await syncFieldCache.get('assets'));
        const provisionalData = {
            srcType: contentSourceInstance.getContentSourceType(),
            srcProjectId: contentSourceInstance.getProjectId(),
            syncContext: cachedSyncContext,
            ...(cachedSchema
                ? {
                    csiSchema: cachedSchema,
                    csiModelMap: lodash_1.default.keyBy(cachedSchema.models, 'name')
                }
                : null),
            ...(cachedDocuments
                ? {
                    csiDocuments: cachedDocuments,
                    csiDocumentMap: lodash_1.default.keyBy(cachedDocuments, 'id')
                }
                : null),
            ...(cachedAssets
                ? {
                    csiAssets: cachedAssets,
                    csiAssetMap: lodash_1.default.keyBy(cachedAssets, 'id')
                }
                : null)
        };
        const getContentSourceDataForCurrentInstance = (methodName) => {
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (!contentSourceData) {
                // When loading the content sources for the first time, this.contentSourceDataById will be empty.
                // However, while being loaded, content sources may call cache methods, for example a content
                // source may call getModelByName from within getDocuments. In this case, return locally cached data.
                if (this.processingContentSourcesPromise) {
                    return provisionalData;
                }
                const atLine = (0, content_store_utils_1.getErrorAtLine)(2, getContentSourceDataForCurrentInstance);
                const errorMessage = `Error executing 'cache.${methodName}' method${atLine}. The content source with id '${contentSourceId}' was not found.`;
                this.logger.error(errorMessage);
                return;
            }
            if (!this.contentSources.includes(contentSourceInstance)) {
                const atLine = (0, content_store_utils_1.getErrorAtLine)(2, getContentSourceDataForCurrentInstance);
                const errorMessage = `Content source life cycle error! The content source with id '${contentSourceId}' called the 'cache.${methodName}' ` +
                    `method${atLine} after the destroy() method was called.`;
                this.logger.error(errorMessage);
                return;
            }
            // While loading the content source, it may call cache methods, when this happens, return the
            // stale data overridden with the most frequent loaded data
            if (this.processingContentSourcesPromise) {
                return Object.assign(contentSourceData, provisionalData);
            }
            return contentSourceData;
        };
        const fileCache = this.isLocalDev
            ? new file_cache_1.FileCache({
                dirPath: (0, content_store_utils_1.getCacheDir)(this.stackbitConfig),
                keyPrefix: `${contentSourceId}/src.`
            })
            : new file_cache_1.NoopFileCache();
        const cache = {
            getSchema: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getSchema');
                return contentSourceData?.csiSchema ?? { models: [], locales: [], context: null };
            },
            getModelByName: (modelName) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getModelByName');
                return contentSourceData?.csiModelMap?.[modelName];
            },
            getDocuments: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getDocuments');
                return contentSourceData?.csiDocuments ?? [];
            },
            getDocumentById: (documentId) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getDocumentById');
                return contentSourceData?.csiDocumentMap?.[documentId];
            },
            getAssets: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getAssets');
                return contentSourceData?.csiAssets ?? [];
            },
            getAssetById: (assetId) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getAssetById');
                return contentSourceData?.csiAssetMap?.[assetId];
            },
            getScheduledActions: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActions');
                return contentSourceData?.scheduledActions ?? [];
            },
            getScheduledActionsForDocumentId: (documentId) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActionsForDocumentId');
                return contentSourceData?.scheduledActions?.filter((scheduledAction) => scheduledAction.documentIds.includes(documentId)) ?? [];
            },
            getSyncContext: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActionsForDocumentId');
                return contentSourceData?.syncContext ?? {};
            },
            clearSyncContext: async (options) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActionsForDocumentId');
                if (contentSourceData?.syncContext) {
                    if (typeof options?.clearDocumentsSyncContext === 'undefined' || options.clearDocumentsSyncContext) {
                        delete contentSourceData.syncContext.documentsSyncContext;
                    }
                    if (typeof options?.clearAssetsSyncContext === 'undefined' || options.clearAssetsSyncContext) {
                        delete contentSourceData.syncContext.assetsSyncContext;
                    }
                    if (contentSourceData.syncContext.documentsSyncContext || contentSourceData.syncContext.assetsSyncContext) {
                        await syncFieldCache.set('context', contentSourceData.syncContext);
                        if (!contentSourceData.syncContext.documentsSyncContext) {
                            await syncFieldCache.set('documents', []);
                        }
                        if (!contentSourceData.syncContext.assetsSyncContext) {
                            await syncFieldCache.set('assets', []);
                        }
                    }
                    else {
                        await syncFieldCache.remove('context');
                        await syncFieldCache.remove('schema');
                        await syncFieldCache.remove('documents');
                        await syncFieldCache.remove('assets');
                    }
                }
            },
            requestSync: async (options) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('requestSync');
                if (!contentSourceData) {
                    return;
                }
                this.pushContentSourceEvent({
                    eventName: types_2.ContentStoreEventType.ContentSourceRequestSync,
                    contentSourceId: contentSourceId,
                    options: options
                });
                await this.processContentStoreEvents();
            },
            updateContent: async (contentChanges) => {
                if ((0, content_store_utils_1.isContentChangesEmpty)(contentChanges)) {
                    return;
                }
                const contentSourceData = getContentSourceDataForCurrentInstance('updateContent');
                if (!contentSourceData) {
                    return;
                }
                this.logger.debug('content source called updateContent', { contentSourceId });
                this.pushContentSourceEvent({
                    eventName: types_2.ContentStoreEventType.ContentSourceContentChange,
                    contentSourceId: contentSourceId,
                    contentChanges: contentChanges
                });
                await this.processContentStoreEvents();
            },
            invalidateSchema: async () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('invalidateSchema');
                if (!contentSourceData) {
                    return;
                }
                this.logger.debug('content source called invalidateSchema', { contentSourceId });
                // TODO: reset schemaContext/syncContext
                this.pushContentSourceEvent({
                    eventName: types_2.ContentStoreEventType.ContentSourceInvalidateSchema,
                    contentSourceId: contentSourceId
                });
                await this.processContentStoreEvents();
            },
            get: async (key) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('get');
                if (!contentSourceData) {
                    return;
                }
                return fileCache.get(key);
            },
            set: async (key, value) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('set');
                if (!contentSourceData) {
                    return;
                }
                return fileCache.set(key, value);
            },
            remove: async (key) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('remove');
                if (!contentSourceData) {
                    return;
                }
                return fileCache.remove(key);
            }
        };
        if (init) {
            this.userLogger.info(`Initializing content source: ${contentSourceInstance.getContentSourceType()} (project: ${contentSourceInstance.getProjectId()})`);
            // When stackbit.config.js reloads, it loads new content source instances.
            // Previously loaded content source instances must be destroyed.
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (contentSourceData && contentSourceData.instance !== contentSourceInstance) {
                this.logger.debug('destroy previous content source instance', { contentSourceId });
                try {
                    contentSourceData.instance.stopWatchingContentUpdates?.();
                    await contentSourceData.instance.destroy();
                }
                catch (error) {
                    this.logger.debug('error destroying content source instance', { error });
                }
                contentSourceData.destroyed = true;
            }
            // If an instance that wasn't destroyed calls one of the InitOptions method don't return any data.
            await contentSourceInstance.init({
                logger: this.logger,
                userLogger: this.userLogger,
                localDev: this.isLocalDev,
                stackbitConfigFilePath: this.stackbitConfig.filePath,
                webhookUrl: this.getWebhookUrl(contentSourceInstance.getContentSourceType(), contentSourceInstance.getProjectId()),
                userCommandSpawner: this.userCommandSpawner,
                devAppRestartNeeded: this.devAppRestartNeeded,
                cache: cache,
                runCommand: this.runCommand,
                git: this.git
            });
        }
        else {
            this.userLogger.info(`Resetting content source: ${contentSourceInstance.getContentSourceType()} (project: ${contentSourceInstance.getProjectId()})`);
            await contentSourceInstance.reset();
        }
        const version = await contentSourceInstance.getVersion();
        const csiSchema = await contentSourceInstance.getSchema();
        const csiModels = csiSchema.models;
        const csiModelMap = lodash_1.default.keyBy(csiModels, 'name');
        const locales = csiSchema.locales;
        const defaultLocaleCode = locales?.find((locale) => locale.default)?.code;
        provisionalData.csiSchema = csiSchema;
        provisionalData.csiModelMap = csiModelMap;
        // TODO: if schema was changed, invalidate syncContext - or provide utility to compare schemas
        const { csiDocuments, csiDocumentMap, csiAssets, csiAssetMap, syncContext } = await (0, content_store_data_manager_1.updateProvisionalDataFromContentSource)({
            contentSourceInstance,
            csiModelMap,
            provisionalData
        });
        let scheduledActions = [];
        try {
            scheduledActions = (await contentSourceInstance.getScheduledActions?.()) ?? [];
            provisionalData.scheduledActions = scheduledActions;
        }
        catch (err) {
            this.userLogger.warn('Failed to fetch scheduled actions:', { error: err });
        }
        if (syncContext?.documentsSyncContext || syncContext?.assetsSyncContext) {
            await syncFieldCache.set('context', syncContext);
            await syncFieldCache.set('schema', csiSchema);
            await syncFieldCache.set('documents', csiDocuments);
            await syncFieldCache.set('assets', csiAssets);
        }
        else {
            await syncFieldCache.remove('context');
            await syncFieldCache.remove('schema');
            await syncFieldCache.remove('documents');
            await syncFieldCache.remove('assets');
        }
        const enabledScheduledActions = !!(contentSourceInstance.createScheduledAction &&
            contentSourceInstance.updateScheduledAction &&
            contentSourceInstance.cancelScheduledAction &&
            contentSourceInstance.getScheduledActions);
        const enabledDocumentVersions = !!contentSourceInstance.getDocumentVersions;
        const enabledUnpublish = !!contentSourceInstance.unpublishDocuments;
        const enabledArchive = !!contentSourceInstance.archiveDocument;
        const enabledUnarchive = !!contentSourceInstance.unarchiveDocument;
        const enabledAssetsEditing = !!contentSourceInstance.updateAsset;
        const contentStoreAssets = (0, csi_to_store_docs_converter_1.mapCSIAssetsToStoreAssets)({
            csiAssets: csiAssets,
            contentSourceInstance,
            defaultLocaleCode
        });
        const assetMap = lodash_1.default.keyBy(contentStoreAssets, 'srcObjectId');
        this.logger.debug('loaded content source data', {
            contentSourceId,
            defaultLocaleCode,
            localesCount: locales?.length ?? 0,
            modelCount: csiModels.length,
            documentCount: csiDocuments.length,
            assetCount: csiAssets.length
        });
        this.userLogger.info(`→ Loaded ${contentSourceInstance.getContentSourceType()} content source data (project: ${contentSourceInstance.getProjectId()}): ` +
            `${csiModels.length} ${(0, user_log_utils_1.pluralize)('model', csiModels.length)}, ` +
            `${csiDocuments.length} ${(0, user_log_utils_1.pluralize)('document', csiDocuments.length)} and ` +
            `${csiAssets.length} ${(0, user_log_utils_1.pluralize)('asset', csiAssets.length)}`);
        if (init || startWatchingContentUpdates) {
            // backward compatibility
            contentSourceInstance.startWatchingContentUpdates?.({
                getModelMap: () => {
                    const contentSourceData = getContentSourceDataForCurrentInstance('getModelMap');
                    return contentSourceData?.csiModelMap ?? {};
                },
                getDocument: ({ documentId }) => {
                    const contentSourceData = getContentSourceDataForCurrentInstance('getDocument');
                    return contentSourceData?.csiDocumentMap?.[documentId];
                },
                getAsset: ({ assetId }) => {
                    const contentSourceData = getContentSourceDataForCurrentInstance('getAsset');
                    return contentSourceData?.csiAssetMap?.[assetId];
                },
                onContentChange: cache.updateContent,
                onSchemaChange: cache.invalidateSchema
            });
        }
        await contentEngineSyncPromise;
        return {
            id: contentSourceId,
            version: version,
            srcType: contentSourceInstance.getContentSourceType(),
            srcProjectId: contentSourceInstance.getProjectId(),
            instance: contentSourceInstance,
            destroyed: false,
            locales: locales,
            defaultLocaleCode: defaultLocaleCode,
            csiSchema: csiSchema,
            csiModels: csiModels,
            csiModelMap: csiModelMap,
            csiDocuments: csiDocuments,
            csiDocumentMap: csiDocumentMap,
            csiAssets: csiAssets,
            csiAssetMap: csiAssetMap,
            assets: contentStoreAssets,
            assetMap: assetMap,
            scheduledActions: scheduledActions,
            syncContext: syncContext,
            enabledFeatures: {
                unpublish: enabledUnpublish,
                archive: enabledArchive,
                unarchive: enabledUnarchive,
                scheduledActions: enabledScheduledActions,
                documentVersions: enabledDocumentVersions,
                assetsEditing: enabledAssetsEditing
            }
        };
    }
    onContentChange(contentSourceId, contentChanges) {
        // certain content changes, like preset changes are interpreted as schema changes
        let presetsUpdated = false;
        const contentChangesFull = {
            documents: contentChanges.documents ?? [],
            assets: contentChanges.assets ?? [],
            scheduledActions: contentChanges.scheduledActions ?? [],
            deletedDocumentIds: contentChanges.deletedDocumentIds ?? [],
            deletedAssetIds: contentChanges.deletedAssetIds ?? [],
            deletedScheduledActionIds: contentChanges.deletedScheduledActionIds ?? []
        };
        this.logger.debug('onContentChange', {
            contentSourceId,
            documentCount: contentChangesFull.documents.length,
            assetCount: contentChangesFull.assets.length,
            scheduledActionCount: contentChangesFull.scheduledActions.length,
            deletedDocumentCount: contentChangesFull.deletedDocumentIds.length,
            deletedAssetCount: contentChangesFull.deletedAssetIds.length,
            deletedScheduledActionCount: contentChangesFull.deletedScheduledActionIds.length
        });
        const result = {
            createdDocuments: [],
            createdAssets: [],
            createdScheduledActions: [],
            updatedDocuments: [],
            updatedAssets: [],
            updatedScheduledActions: [],
            deletedDocuments: [],
            deletedAssets: [],
            deletedScheduledActions: []
        };
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        // update contentSourceData with deleted documents
        contentChangesFull.deletedDocumentIds.forEach((docId) => {
            // remove preset, make sure there is something to remove first because
            // were explicitly calling onContentChange from deletePreset as well
            if (this.presets[docId] && contentSourceData.csiDocumentMap[docId]?.modelName === consts_1.STACKBIT_PRESET_MODEL_NAME) {
                presetsUpdated = true;
                const preset = this.presets[docId];
                const model = contentSourceData.modelMap[preset.modelName];
                delete this.presets[docId];
                if (model && model.presets) {
                    const presetIdIndex = model.presets.findIndex((presetId) => presetId === docId);
                    model.presets.splice(presetIdIndex, 1);
                }
            }
            // delete document from documents map
            delete contentSourceData.documentMap[docId];
            delete contentSourceData.csiDocumentMap[docId];
            // delete document from document array
            const index = contentSourceData.documents.findIndex((document) => document.srcObjectId === docId);
            if (index !== -1) {
                // the indexes of documents and csiDocuments are always the same as they are always updated at the same time
                contentSourceData.documents.splice(index, 1);
                contentSourceData.csiDocuments.splice(index, 1);
            }
            result.deletedDocuments.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: docId
            });
        });
        // update contentSourceData with deleted assets
        contentChangesFull.deletedAssetIds.forEach((assetId) => {
            // delete document from asset map
            delete contentSourceData.assetMap[assetId];
            delete contentSourceData.csiAssetMap[assetId];
            // delete document from asset array
            const index = contentSourceData.assets.findIndex((asset) => asset.srcObjectId === assetId);
            if (index !== -1) {
                // the indexes of assets and csiAssets are always the same as they are always updated at the same time
                contentSourceData.assets.splice(index, 1);
                contentSourceData.csiAssets.splice(index, 1);
            }
            result.deletedAssets.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: assetId
            });
        });
        // update contentSourceData with deleted scheduledActions
        contentChangesFull.deletedScheduledActionIds.forEach((scheduledActionId) => {
            // delete scheduledAction from scheduledActions array
            const index = contentSourceData.scheduledActions.findIndex((scheduledAction) => scheduledAction.id === scheduledActionId);
            if (index !== -1) {
                contentSourceData.scheduledActions.splice(index, 1);
            }
            result.deletedScheduledActions.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                scheduledActionId: scheduledActionId
            });
        });
        // map csi documents through stackbitConfig.mapDocuments
        let mappedDocs = contentChangesFull.documents;
        if (this.stackbitConfig?.mapDocuments) {
            const csiDocumentsWithSource = contentChangesFull.documents.map((csiDocument) => ({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                ...csiDocument
            }));
            const modelsWithSource = contentSourceData.models.map((model) => {
                return {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...model
                };
            });
            mappedDocs =
                this.stackbitConfig?.mapDocuments?.({
                    documents: lodash_1.default.cloneDeep(csiDocumentsWithSource),
                    models: lodash_1.default.cloneDeep(modelsWithSource)
                }) ?? csiDocumentsWithSource;
        }
        // map csi documents and assets to content store documents and assets
        const documents = (0, csi_to_store_docs_converter_1.mapCSIDocumentsToStoreDocuments)({
            csiDocuments: mappedDocs,
            contentSourceInstance: contentSourceData.instance,
            modelMap: contentSourceData.modelMap,
            defaultLocaleCode: contentSourceData.defaultLocaleCode,
            assetSources: this.stackbitConfig?.assetSources ?? [],
            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            }),
            logger: this.userLogger
        });
        const assets = (0, csi_to_store_docs_converter_1.mapCSIAssetsToStoreAssets)({
            csiAssets: contentChangesFull.assets,
            contentSourceInstance: contentSourceData.instance,
            defaultLocaleCode: contentSourceData.defaultLocaleCode
        });
        // update contentSourceData with new or updated documents and assets
        Object.assign(contentSourceData.csiDocumentMap, lodash_1.default.keyBy(contentChangesFull.documents, 'id'));
        Object.assign(contentSourceData.csiAssetMap, lodash_1.default.keyBy(contentChangesFull.assets, 'id'));
        Object.assign(contentSourceData.documentMap, lodash_1.default.keyBy(documents, 'srcObjectId'));
        Object.assign(contentSourceData.assetMap, lodash_1.default.keyBy(assets, 'srcObjectId'));
        for (let idx = 0; idx < documents.length; idx++) {
            // the indexes of mapped documents and documents from changeEvent are the same
            const document = documents[idx];
            const csiDocument = contentChangesFull.documents[idx];
            const dataIndex = contentSourceData.documents.findIndex((existingDoc) => existingDoc.srcObjectId === document.srcObjectId);
            const isNewDoc = dataIndex === -1;
            if (isNewDoc) {
                contentSourceData.documents.push(document);
                contentSourceData.csiDocuments.push(csiDocument);
            }
            else {
                contentSourceData.documents.splice(dataIndex, 1, document);
                contentSourceData.csiDocuments.splice(dataIndex, 1, csiDocument);
            }
            if (csiDocument.modelName === consts_1.STACKBIT_PRESET_MODEL_NAME) {
                presetsUpdated = true;
                const preset = (0, preset_utils_1.getPresetFromDocument)({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    csiDocument,
                    csiAssetMap: contentSourceData.csiAssetMap,
                    logger: this.logger
                });
                if (preset) {
                    this.presets[csiDocument.id] = preset;
                    if (dataIndex === -1) {
                        //TODO recalculate assets as well
                        contentSourceData.modelMap[preset.modelName]?.presets?.push(csiDocument.id);
                    }
                }
            }
            result[isNewDoc ? 'createdDocuments' : 'updatedDocuments'].push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: document.srcObjectId
            });
        }
        for (let idx = 0; idx < assets.length; idx++) {
            // the indexes of mapped assets and assets from changeEvent are the same
            const asset = assets[idx];
            const csiAsset = contentChangesFull.assets[idx];
            const index = contentSourceData.assets.findIndex((existingAsset) => existingAsset.srcObjectId === asset.srcObjectId);
            const isNewAsset = index === -1;
            if (isNewAsset) {
                contentSourceData.assets.push(asset);
                contentSourceData.csiAssets.push(csiAsset);
            }
            else {
                // the indexes of assets and csiAssets are always the same as they are always updated at the same time
                contentSourceData.assets.splice(index, 1, asset);
                contentSourceData.csiAssets.splice(index, 1, csiAsset);
            }
            result[isNewAsset ? 'createdAssets' : 'updatedAssets'].push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: asset.srcObjectId
            });
        }
        const scheduledActions = contentChangesFull.scheduledActions;
        for (let idx = 0; idx < scheduledActions.length; idx++) {
            // the indexes of mapped assets and assets from changeEvent are the same
            const scheduledAction = scheduledActions[idx];
            const index = contentSourceData.scheduledActions.findIndex((existingScheduledAction) => existingScheduledAction.id === scheduledAction.id);
            const isNewAction = index === -1;
            if (isNewAction) {
                contentSourceData.scheduledActions.push(scheduledAction);
            }
            else {
                contentSourceData.scheduledActions.splice(index, 1, scheduledAction);
            }
            result[isNewAction ? 'createdScheduledActions' : 'updatedScheduledActions'].push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                scheduledActionId: scheduledAction.id
            });
        }
        return {
            contentChangeResult: result,
            presetsUpdated
        };
    }
    async processData({ stackbitConfig, configModels, presets, contentSourceRawDataArr }) {
        this.logger.debug('processData');
        // Group models from all content sources by their names
        const csiModelGroups = contentSourceRawDataArr.reduce((modelGroups, csData) => {
            return csData.csiModels.reduce((modelGroups, model) => {
                if (!(model.name in modelGroups)) {
                    modelGroups[model.name] = [];
                }
                modelGroups[model.name].push({
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...model
                });
                return modelGroups;
            }, modelGroups);
        }, {});
        // Match config models to the group of content source models with the same name.
        // Then, match the config model to content source model by comparing srcType and
        // srcProjectId. If after the comparison, there are more than one model left,
        // log a warning and filter out that config model so it won't be merged with any
        // of the content source models.
        const nonMatchedModels = [];
        const configModelsByContentSourceId = configModels.reduce((modelGroups, configModel) => {
            const csiModels = csiModelGroups[configModel.name];
            if (!csiModels) {
                nonMatchedModels.push({
                    configModel,
                    matchedCSIModels: []
                });
                return modelGroups;
            }
            const matchedCSIModels = csiModels.filter((model) => {
                const matchesType = !configModel.srcType || model.srcType === configModel.srcType;
                const matchesId = !configModel.srcProjectId || model.srcProjectId === configModel.srcProjectId;
                return matchesType && matchesId;
            });
            if (matchedCSIModels.length !== 1) {
                nonMatchedModels.push({
                    configModel,
                    matchedCSIModels
                });
                return modelGroups;
            }
            const contentSource = matchedCSIModels[0];
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(contentSource.srcType, contentSource.srcProjectId);
            (0, utils_1.append)(modelGroups, contentSourceId, configModel);
            return modelGroups;
        }, {});
        // Log model matching warnings using user logger
        for (const { configModel, matchedCSIModels } of nonMatchedModels) {
            let configModelMessage = `model name: '${configModel.name}'`;
            if (configModel.srcType) {
                configModelMessage += `, srcType: '${configModel.srcType}'`;
            }
            if (configModel.srcProjectId) {
                configModelMessage += `, srcProjectId: '${configModel.srcProjectId}'`;
            }
            configModelMessage = configModelMessage + ` defined in stackbit config`;
            let contentSourceModelsMessage;
            if (matchedCSIModels.length) {
                const matchesModelsMessage = matchedCSIModels.map((model) => `srcType: '${model.srcType}', srcProjectId: '${model.srcProjectId}'`).join('; ');
                contentSourceModelsMessage = ` matches more that 1 model in the following content sources: ${matchesModelsMessage}`;
            }
            else {
                contentSourceModelsMessage = ' does not match any content source model';
            }
            this.userLogger.warn(configModelMessage + contentSourceModelsMessage);
        }
        const modelsWithSource = contentSourceRawDataArr.reduce((accum, csData) => {
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(csData.srcType, csData.srcProjectId);
            const mergedModels = (0, sdk_1.mergeConfigModelsWithExternalModels)({
                configModels: configModelsByContentSourceId[contentSourceId] ?? [],
                externalModels: csData.csiModels,
                logger: this.userLogger
            });
            const modelsWithSource = mergedModels.map((model) => {
                return {
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...model
                };
            });
            return accum.concat(modelsWithSource);
        }, []);
        // TODO: Is there a better way than deep cloning objects before passing them to user methods?
        //   Not cloning mutable objects will break the internal state if user mutates the objects.
        const mappedModels = stackbitConfig?.mapModels?.({ models: lodash_1.default.cloneDeep(modelsWithSource) }) ?? modelsWithSource;
        const normalizedModels = (0, model_utils_1.normalizeModels)({ models: mappedModels, logger: this.userLogger });
        const validatedModels = (0, model_utils_1.validateModels)({ models: normalizedModels, logger: this.userLogger });
        const modelsWithPresetsIds = (0, sdk_1.extendModelsWithPresetsIds)({ models: validatedModels, presets });
        const { models } = await this.handleConfigAssets({ models: modelsWithPresetsIds });
        let documentMapByContentSource = null;
        if (stackbitConfig?.mapDocuments) {
            const csiDocumentsWithSource = contentSourceRawDataArr.reduce((accum, csData) => {
                const csiDocumentsWithSource = csData.csiDocuments.map((csiDocument) => ({
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...csiDocument
                }));
                return accum.concat(csiDocumentsWithSource);
            }, []);
            // TODO: Is there a better way than deep cloning objects before passing them to user methods?
            //   Not cloning mutable objects will break the internal state if user mutates the objects.
            const mappedDocs = stackbitConfig?.mapDocuments?.({
                documents: lodash_1.default.cloneDeep(csiDocumentsWithSource),
                models: lodash_1.default.cloneDeep(models)
            }) ?? csiDocumentsWithSource;
            documentMapByContentSource = (0, content_store_utils_1.groupDocumentsByContentSource)({ documents: mappedDocs });
        }
        const modelMapByContentSource = (0, content_store_utils_1.groupModelsByContentSource)({ models: models });
        const contentSourceDataArr = contentSourceRawDataArr.map((csData) => {
            const modelMap = lodash_1.default.get(modelMapByContentSource, [csData.srcType, csData.srcProjectId], {});
            const csiDocuments = documentMapByContentSource
                ? lodash_1.default.get(documentMapByContentSource, [csData.srcType, csData.srcProjectId], [])
                : csData.csiDocuments;
            const documents = (0, csi_to_store_docs_converter_1.mapCSIDocumentsToStoreDocuments)({
                csiDocuments: csiDocuments,
                contentSourceInstance: csData.instance,
                modelMap: modelMap,
                defaultLocaleCode: csData.defaultLocaleCode,
                assetSources: this.stackbitConfig?.assetSources ?? [],
                createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                    getContentSourceDataById: () => this.contentSourceDataById,
                    logger: this.userLogger
                }),
                logger: this.userLogger
            });
            return {
                ...csData,
                models: Object.values(modelMap),
                modelMap,
                documents,
                documentMap: lodash_1.default.keyBy(documents, 'srcObjectId')
            };
        });
        this.logger.debug('processData finished');
        return lodash_1.default.keyBy(contentSourceDataArr, 'id');
    }
    calculateReferenceMap() {
        const documents = [...this.getDocuments(), ...this.getAssets()];
        this.referenceMap = _1.utils.deepFreeze((0, references_utils_1.getReferenceMap)(documents));
    }
    getReferenceMap() {
        return this.referenceMap;
    }
    getContentSourceMeta() {
        return lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            return result.concat({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcVersion: contentSourceData.version.contentSourceVersion,
                csiVersion: contentSourceData.version.interfaceVersion,
                supportsUnpublish: contentSourceData?.enabledFeatures.unpublish ?? false,
                supportsArchive: contentSourceData?.enabledFeatures.archive ?? false,
                supportsUnarchive: contentSourceData?.enabledFeatures.unarchive ?? false,
                supportsScheduledActions: contentSourceData?.enabledFeatures.scheduledActions ?? false,
                supportsDocumentVersions: contentSourceData?.enabledFeatures.documentVersions ?? false,
                supportsAssetsEditing: contentSourceData?.enabledFeatures.assetsEditing ?? false
            });
        }, []);
    }
    getAssetSources() {
        return (0, asset_sources_utils_1.getAssetSourcesForClient)(this.stackbitConfig);
    }
    getModels({ user } = {}) {
        const configDelegate = (0, config_delegate_1.createConfigDelegate)({
            contentSourceDataById: this.contentSourceDataById,
            logger: this.userLogger
        });
        return lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            const contentSourceType = contentSourceData.instance.getContentSourceType();
            const srcProjectId = contentSourceData.instance.getProjectId();
            const filteredModels = (0, filtered_entities_1.getContentSourceFilteredModelsForUser)({
                user,
                configDelegate,
                contentSourceData,
                permissionsForModel: this.stackbitConfig?.permissionsForModel
            });
            const modelsMap = (0, model_utils_1.getModelMap)({ models: filteredModels });
            // if `projectId` is number (even as string) e.g., '1234', _.set() will create an array of length 1235 and insert the item at the end.
            // _.setWith(..., Object) ensures the values are always created as object keys, not as array indexes.
            lodash_1.default.setWith(result, [contentSourceType, srcProjectId], modelsMap, Object);
            lodash_1.default.setWith(result, [contentSourceType, srcProjectId, '__image_model'], common_schema_1.IMAGE_MODEL, Object);
            lodash_1.default.setWith(result, [contentSourceType, srcProjectId, '__asset_model'], common_schema_1.ASSET_MODEL, Object);
            return result;
        }, {});
    }
    getLocales() {
        return lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            return result.concat({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                locales: contentSourceData.locales?.map((locale) => locale.code) ?? [],
                defaultLocale: contentSourceData.defaultLocaleCode
            });
        }, []);
    }
    async getGlobalActions({ pageUrl, user, locale, currentPageDocument }) {
        return (0, custom_actions_1.getGlobalAndBulkAPIActions)({
            stackbitConfig: this.stackbitConfig,
            customActionRunStateMap: this.customActionRunStateMap,
            contentSourceDataById: this.contentSourceDataById,
            userLogger: this.userLogger,
            locale,
            pageUrl,
            user,
            currentPageDocument
        });
    }
    async getCustomActions(getActionRequest) {
        return (0, custom_actions_1.resolveCustomActionsById)({
            getActionRequest,
            customActionRunStateMap: this.customActionRunStateMap,
            contentSourceDataById: this.contentSourceDataById,
            stackbitConfig: this.stackbitConfig,
            userLogger: this.userLogger
        });
    }
    async getRunningCustomActionsForUser(getRunningActionsRequest) {
        return (0, custom_actions_1.getRunningActions)({
            getRunningActionsRequest,
            customActionRunStateMap: this.customActionRunStateMap,
            contentSourceDataById: this.contentSourceDataById,
            stackbitConfig: this.stackbitConfig,
            userLogger: this.userLogger
        });
    }
    async runCustomAction(runActionRequest) {
        // This method runs the action but doesn't wait for the action to finish and returns.
        // The result is delivered asynchronously via "customActionStateChanged" notification.
        const { actionId } = await (0, custom_actions_1.runCustomAction)({
            runActionRequest: runActionRequest,
            contentSourceDataById: this.contentSourceDataById,
            customActionRunStateMap: this.customActionRunStateMap,
            userLogger: this.userLogger,
            stackbitConfig: this.stackbitConfig,
            presets: this.presets,
            onProgress: (actionStateChange) => {
                this.onActionStateChangeCallback(actionStateChange);
            }
        });
        return { actionId };
    }
    getPresets({ locale } = {}) {
        if (!this.presets || !locale) {
            return this.presets ?? {};
        }
        return lodash_1.default.pickBy(this.presets, (preset) => !preset.locale || preset.locale === locale);
    }
    getContentSourceEnvironment({ srcProjectId, srcType }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.instance.getProjectEnvironment();
    }
    usesContentSourcePresets() {
        return Boolean(this.presetsContentSource);
    }
    async hasAccess({ srcType, srcProjectId, user }) {
        let contentSourceDataArr;
        if (srcType && srcProjectId) {
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            contentSourceDataArr = [contentSourceData];
        }
        else {
            contentSourceDataArr = Object.values(this.contentSourceDataById);
        }
        return (0, utils_1.reducePromise)(contentSourceDataArr, async (accum, contentSourceData) => {
            const srcType = contentSourceData.srcType;
            const srcProjectId = contentSourceData.srcProjectId;
            const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
            const result = await contentSourceData.instance.hasAccess({ userContext });
            return {
                hasConnection: accum.hasConnection && result.hasConnection,
                hasPermissions: accum.hasPermissions && result.hasPermissions,
                contentSources: accum.contentSources.concat({
                    srcType,
                    srcProjectId,
                    ...result
                })
            };
        }, {
            hasConnection: true,
            hasPermissions: true,
            contentSources: []
        });
    }
    hasChanges({ srcType, srcProjectId, documents }) {
        let result;
        if (srcType && srcProjectId) {
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            result = [...contentSourceData.documents, ...contentSourceData.assets];
        }
        else if (documents && documents.length > 0) {
            const documentsBySourceId = lodash_1.default.groupBy(documents, (document) => (0, content_store_utils_1.getContentSourceId)(document.srcType, document.srcProjectId));
            result = lodash_1.default.reduce(documentsBySourceId, (result, documents, contentSourceId) => {
                const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
                for (const document of documents) {
                    if (document.srcObjectId in contentSourceData.documentMap) {
                        result.push(contentSourceData.documentMap[document.srcObjectId]);
                    }
                    else if (document.srcObjectId in contentSourceData.assetMap) {
                        result.push(contentSourceData.assetMap[document.srcObjectId]);
                    }
                }
                return result;
            }, []);
        }
        else {
            result = lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
                return result.concat(contentSourceData.documents, contentSourceData.assets);
            }, []);
        }
        const changedDocuments = result.filter((document) => document.status === 'added' || document.status === 'modified');
        return {
            hasChanges: !lodash_1.default.isEmpty(changedDocuments),
            changedObjects: changedDocuments.map((item) => ({
                srcType: item.srcType,
                srcProjectId: item.srcProjectId,
                srcObjectId: item.srcObjectId
            }))
        };
    }
    getSiteMapEntries({ locale, user } = {}) {
        const siteMapEntries = lodash_1.default.reduce(this.siteMapEntryGroups, (accum, siteMapEntryGroup) => {
            return lodash_1.default.reduce(siteMapEntryGroup, (accum, siteMapEntry) => {
                if (!lodash_1.default.isEmpty(locale)) {
                    // filter out in wrong locale
                    if (siteMapEntry.locale && siteMapEntry.locale !== locale) {
                        return accum;
                    }
                }
                if ('document' in siteMapEntry) {
                    // check for hidden documents
                    const contentSourceId = (0, content_store_utils_1.getContentSourceId)(siteMapEntry.document.srcType, siteMapEntry.document.srcProjectId);
                    const document = (0, content_store_utils_1.getContentSourceDataByIdOrThrow)(contentSourceId, this.contentSourceDataById)?.documentMap[siteMapEntry.document.id];
                    if (document) {
                        const [filteredDocument] = (0, filtered_entities_1.getFilteredDocumentsForUser)({
                            user,
                            documents: [document],
                            permissionsForModel: this.stackbitConfig?.permissionsForModel,
                            permissionsForDocument: this.stackbitConfig?.permissionsForDocument,
                            contentSourceDataById: this.contentSourceDataById,
                            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                                getContentSourceDataById: () => this.contentSourceDataById,
                                logger: this.userLogger
                            }),
                            logger: this.userLogger
                        });
                        if (filteredDocument && filteredDocument.hidden) {
                            return accum;
                        }
                    }
                }
                if (!siteMapEntry.label) {
                    const fieldLabelValue = (0, site_map_1.getDocumentFieldLabelValueForSiteMapEntry)({
                        siteMapEntry,
                        locale,
                        contentSourceDataById: this.contentSourceDataById
                    });
                    siteMapEntry = {
                        ...siteMapEntry,
                        label: fieldLabelValue ?? siteMapEntry.urlPath
                    };
                }
                accum.push(siteMapEntry);
                return accum;
            }, accum);
        }, []);
        if (user && this.stackbitConfig?.transformSitemap) {
            const configDelegate = (0, config_delegate_1.createConfigDelegate)({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            return this.stackbitConfig.transformSitemap({ ...configDelegate, sitemap: lodash_1.default.cloneDeep(siteMapEntries), userContext: user });
        }
        return siteMapEntries;
    }
    getTreeViews({ user } = {}) {
        let treeViews = this.treeViews;
        if (this.stackbitConfig?.transformTreeViews && user) {
            const configDelegate = (0, config_delegate_1.createConfigDelegate)({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            treeViews = this.stackbitConfig.transformTreeViews({ ...configDelegate, treeViews: lodash_1.default.cloneDeep(treeViews), userContext: user });
        }
        return (0, tree_views_1.removeHiddenTreeViews)({
            treeViews,
            getDocumentForUser: (opts) => {
                const contentSourceId = (0, content_store_utils_1.getContentSourceId)(opts.srcType, opts.srcProjectId);
                const document = (0, content_store_utils_1.getContentSourceDataByIdOrThrow)(contentSourceId, this.contentSourceDataById)?.documentMap[opts.srcDocumentId];
                if (!document || !user) {
                    return document;
                }
                const [filteredDocument] = (0, filtered_entities_1.getFilteredDocumentsForUser)({
                    user,
                    documents: [document],
                    permissionsForModel: this.stackbitConfig?.permissionsForModel,
                    permissionsForDocument: this.stackbitConfig?.permissionsForDocument,
                    contentSourceDataById: this.contentSourceDataById,
                    createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                        getContentSourceDataById: () => this.contentSourceDataById,
                        logger: this.userLogger
                    }),
                    logger: this.userLogger
                });
                return filteredDocument;
            }
        });
    }
    getSiteMapEntriesForDocument({ srcType, srcProjectId, srcDocumentId, locale }) {
        const key = (0, content_store_utils_1.getObjectId)(srcType, srcProjectId, srcDocumentId);
        const siteMapEntryGroup = this.siteMapEntryGroups[key];
        const siteMapEntries = lodash_1.default.values(siteMapEntryGroup);
        return lodash_1.default.isEmpty(locale) ? siteMapEntries : siteMapEntries.filter((siteMapEntry) => !siteMapEntry.locale || siteMapEntry.locale === locale);
    }
    getDocument({ srcDocumentId, srcProjectId, srcType, user }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const document = contentSourceData.documentMap[srcDocumentId];
        if (!document) {
            return document;
        }
        const [filteredDocument] = (0, filtered_entities_1.getFilteredDocumentsForUser)({
            user,
            documents: [document],
            permissionsForModel: this.stackbitConfig?.permissionsForModel,
            permissionsForDocument: this.stackbitConfig?.permissionsForDocument,
            contentSourceDataById: this.contentSourceDataById,
            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            }),
            logger: this.userLogger
        });
        return filteredDocument ?? document;
    }
    getDocumentsByContext({ context, srcProjectId, srcType }) {
        const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
            contentSourceDataById: this.contentSourceDataById,
            srcType,
            srcProjectId
        });
        return lodash_1.default.reduce(contentSourcesData, (documents, csData) => {
            const matchingDocuments = lodash_1.default.filter(csData.csiDocuments, { context })
                .map((document) => csData.documentMap[document.id])
                .filter(Boolean);
            return [...documents, ...matchingDocuments];
        }, []);
    }
    getDocuments({ locale, user } = {}) {
        const documents = lodash_1.default.reduce(this.contentSourceDataById, (documents, contentSourceData) => {
            const currentDocuments = lodash_1.default.isEmpty(locale)
                ? contentSourceData.documents
                : contentSourceData.documents.filter((document) => !document.locale || document.locale === locale);
            const filteredDocuments = currentDocuments.filter((document) => document.srcModelName !== consts_1.STACKBIT_PRESET_MODEL_NAME);
            return documents.concat(filteredDocuments);
        }, []);
        const filteredDocuments = (0, filtered_entities_1.getFilteredDocumentsForUser)({
            user,
            documents,
            permissionsForModel: this.stackbitConfig?.permissionsForModel,
            permissionsForDocument: this.stackbitConfig?.permissionsForDocument,
            contentSourceDataById: this.contentSourceDataById,
            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            }),
            logger: this.userLogger
        });
        return filteredDocuments;
    }
    getApiDocuments({ documentSpecs, user } = {}) {
        let filteredDocuments;
        const deleteFieldsObjects = [];
        if (documentSpecs?.length) {
            // filter over documentSpecs
            filteredDocuments = documentSpecs?.reduce((acc, docSpec) => {
                const contentSourceId = (0, content_store_utils_1.getContentSourceId)(docSpec.srcType, docSpec.srcProjectId);
                const document = this.contentSourceDataById[contentSourceId]?.documentMap[docSpec.srcDocumentId];
                if (document && document.srcModelName !== consts_1.STACKBIT_PRESET_MODEL_NAME) {
                    if (docSpec.omitFields) {
                        deleteFieldsObjects.push((0, content_store_utils_1.getObjectId)(document.srcType, document.srcProjectId, document.srcObjectId));
                    }
                    acc.push(document);
                }
                return acc;
            }, []);
        }
        else {
            // filter over all documents
            filteredDocuments = lodash_1.default.reduce(this.contentSourceDataById, (accDocuments, contentSourceData) => {
                return accDocuments.concat(contentSourceData.documents.filter((document) => document.srcModelName !== consts_1.STACKBIT_PRESET_MODEL_NAME));
            }, []);
        }
        filteredDocuments = (0, filtered_entities_1.getFilteredDocumentsForUser)({
            user,
            documents: filteredDocuments,
            permissionsForModel: this.stackbitConfig?.permissionsForModel,
            permissionsForDocument: this.stackbitConfig?.permissionsForDocument,
            contentSourceDataById: this.contentSourceDataById,
            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            }),
            logger: this.userLogger
        });
        const documents = (0, store_to_api_v2_docs_converter_1.mapDocumentsToApiDocuments)({
            documents: filteredDocuments,
            contentSourceDataById: this.contentSourceDataById,
            delegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger }),
            referenceMap: this.referenceMap
        });
        deleteFieldsObjects.forEach((objectId) => {
            const document = documents.find((document) => objectId === (0, content_store_utils_1.getObjectId)(document.srcType, document.srcProjectId, document.srcObjectId));
            delete document?.fields;
        });
        return {
            documents
        };
    }
    getCSIDocuments({ documentSpecs, srcType, srcProjectId, limit = 100, offset = 0 } = {}) {
        // If document specs provided, return the specified documents. Don't use limit or offset.
        if (documentSpecs?.length) {
            const documents = documentSpecs.reduce((csiDocuments, docSpec) => {
                const contentSourceId = (0, content_store_utils_1.getContentSourceId)(docSpec.srcType, docSpec.srcProjectId);
                const document = this.contentSourceDataById[contentSourceId]?.csiDocumentMap[docSpec.srcDocumentId];
                if (document && document.modelName !== consts_1.STACKBIT_PRESET_MODEL_NAME) {
                    csiDocuments.push(document);
                }
                return csiDocuments;
            }, []);
            return {
                total: documents.length,
                offset: 0,
                documents
            };
        }
        else {
            // Filter content sources by srcType and srcProjectId, then accumulate all their
            // csiDocuments and return sliced array according to offset and limit.
            const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
                contentSourceDataById: this.contentSourceDataById,
                srcType,
                srcProjectId
            });
            const documents = lodash_1.default.reduce(contentSourcesData, (csiDocuments, contentSourceData) => {
                return csiDocuments.concat(contentSourceData.csiDocuments.filter((document) => document.modelName !== consts_1.STACKBIT_PRESET_MODEL_NAME));
            }, []);
            return {
                total: documents.length,
                offset,
                documents: documents.slice(offset, offset + limit)
            };
        }
    }
    async getStagedChanges({ scope, locale, shallow, objects, user }) {
        const documents = this.getDocuments({ user, locale });
        const assets = this.getAssets({ user, locale });
        const allObjects = [...documents, ...assets];
        const isPublishingSpecificDocuments = scope === 'content' && objects.length;
        let publishableObjects;
        // filter content only if scope is content, if scope is all ignore objects
        if (isPublishingSpecificDocuments) {
            const objectIds = objects.map((object) => object.srcObjectId);
            // also add all images which has 'added' status to the list
            publishableObjects = [
                ...lodash_1.default.filter(documents, (document) => objectIds.includes(document.srcObjectId)),
                ...lodash_1.default.filter(assets, (asset) => objectIds.includes(asset.srcObjectId) || asset.status === 'added')
            ];
        }
        else {
            // scope === 'all' or scope === 'content' with empty objects
            publishableObjects = allObjects;
        }
        const visited = publishableObjects.map((object) => (0, content_store_utils_1.getObjectId)(object.srcType, object.srcProjectId, object.srcObjectId));
        const findUsedChangedObjects = (rootObject, fields) => {
            return lodash_1.default.flatMap(fields, (field) => {
                const localizedField = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale);
                if (localizedField?.type === 'list') {
                    return findUsedChangedObjects(rootObject, localizedField.items);
                }
                else if (localizedField?.type === 'object' || localizedField?.type === 'model') {
                    return localizedField.isUnset ? [] : findUsedChangedObjects(rootObject, Object.values(localizedField.fields));
                }
                else if (localizedField?.type === 'reference') {
                    if (localizedField.isUnset) {
                        return [];
                    }
                    const { refId } = localizedField;
                    const objectStrId = (0, content_store_utils_1.getObjectId)(rootObject.srcType, rootObject.srcProjectId, refId);
                    if (visited.includes(objectStrId)) {
                        return [];
                    }
                    visited.push(objectStrId);
                    const refObject = lodash_1.default.find(allObjects, {
                        srcObjectId: refId,
                        srcType: rootObject.srcType,
                        srcProjectId: rootObject.srcProjectId
                    });
                    if (refObject) {
                        if (refObject.type === 'asset') {
                            return refObject.isChanged ? [refObject] : [];
                        }
                        return [...(refObject.isChanged ? [refObject] : []), ...findUsedChangedObjects(refObject, Object.values(refObject.fields))];
                    }
                }
                return [];
            });
        };
        const changes = publishableObjects.reduce((result, object) => {
            const changedObjects = [];
            if (object.isChanged) {
                changedObjects.push(object);
            }
            if (isPublishingSpecificDocuments && object.type !== 'asset' && !shallow) {
                // when publishing specific documents, go over changed fields and see if their reference objects are not changed in case
                // it's not already in the publishableObjects list;
                changedObjects.push(...findUsedChangedObjects(object, Object.values(object.fields)));
            }
            result.push(...changedObjects.map((object) => ({
                changeId: object.srcObjectId,
                changeType: object.type === 'document' ? 'content' : 'asset',
                label: object.type === 'asset' ? object.srcObjectLabel : object.getPreview({ locale }).previewTitle,
                status: object.status,
                srcModelName: object.srcModelName,
                srcObjectId: object.srcObjectId,
                srcProjectId: object.srcProjectId,
                srcEnvironment: object.srcEnvironment,
                srcType: object.srcType,
                createdAt: object.createdAt,
                createdBy: object.createdBy,
                updatedAt: object.updatedAt,
                updatedBy: object.updatedBy || [],
                locale: object.locale,
                ...('permissions' in object ? { permissions: object.permissions } : {})
            })));
            return result;
        }, []);
        return changes;
    }
    getAsset({ srcAssetId, srcProjectId, srcType }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.assetMap[srcAssetId];
    }
    getAssets({ locale, user } = {}) {
        const assets = lodash_1.default.reduce(this.contentSourceDataById, (assets, contentSourceData) => {
            const currentAssets = lodash_1.default.isEmpty(locale)
                ? contentSourceData.assets
                : contentSourceData.assets.filter((asset) => !asset.locale || asset.locale === locale);
            return assets.concat(currentAssets);
        }, []);
        const filteredAssets = (0, filtered_entities_1.getFilteredAssetsForUser)({
            user,
            assets,
            filterAsset: this.stackbitConfig?.filterAsset,
            contentSourceDataById: this.contentSourceDataById,
            configDelegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
        });
        return filteredAssets;
    }
    getLocalizedApiObjects({ locale, objectIds, user }) {
        const hasExplicitLocale = !lodash_1.default.isEmpty(locale);
        return lodash_1.default.reduce(this.contentSourceDataById, (objects, contentSourceData) => {
            let documents = objectIds
                ? contentSourceData.documents.filter((document) => objectIds.includes(document.srcObjectId))
                : contentSourceData.documents;
            documents = hasExplicitLocale ? documents.filter((document) => !document.locale || document.locale === locale) : documents;
            let assets = objectIds ? contentSourceData.assets.filter((asset) => objectIds.includes(asset.srcObjectId)) : contentSourceData.assets;
            assets = hasExplicitLocale ? assets.filter((asset) => !asset.locale || asset.locale === locale) : assets;
            const currentLocale = locale ?? contentSourceData.defaultLocaleCode;
            let filteredDocuments = documents.filter((document) => document.srcModelName !== consts_1.STACKBIT_PRESET_MODEL_NAME);
            filteredDocuments = (0, filtered_entities_1.getFilteredDocumentsForUser)({
                user,
                documents: filteredDocuments,
                permissionsForModel: this.stackbitConfig?.permissionsForModel,
                permissionsForDocument: this.stackbitConfig?.permissionsForDocument,
                contentSourceDataById: this.contentSourceDataById,
                createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                    getContentSourceDataById: () => this.contentSourceDataById,
                    logger: this.userLogger
                }),
                logger: this.userLogger
            });
            assets = (0, filtered_entities_1.getFilteredAssetsForUser)({
                user,
                assets,
                filterAsset: this.stackbitConfig?.filterAsset,
                contentSourceDataById: this.contentSourceDataById,
                configDelegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
            });
            const documentObjects = (0, store_to_api_docs_converter_1.mapDocumentsToLocalizedApiObjects)({
                documents: filteredDocuments,
                locale: currentLocale,
                delegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
            });
            const imageObjects = (0, store_to_api_docs_converter_1.mapAssetsToLocalizedApiImages)(assets, this.staticAssetsPublicPath, currentLocale);
            return objects.concat(documentObjects, imageObjects);
        }, []);
    }
    getApiAssets(options = {}) {
        let assets;
        const { pageSize = 20, pageNum = 1, searchQuery, user } = options;
        if ('version' in options && options.version === 'v2') {
            const { assetSpecs, locale } = options;
            return this.getApiAssetsV2({
                assetSpecs,
                pageSize,
                pageNum,
                searchQuery,
                user,
                locale
            });
        }
        if ('srcProjectId' in options && options.srcProjectId && options.srcType) {
            const { srcProjectId, srcType } = options;
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            const filteredAssets = (0, filtered_entities_1.getFilteredAssetsForUser)({
                user,
                assets: contentSourceData.assets,
                filterAsset: this.stackbitConfig?.filterAsset,
                contentSourceDataById: this.contentSourceDataById,
                configDelegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
            });
            assets = (0, store_to_api_docs_converter_1.mapStoreAssetsToAPIAssets)(filteredAssets, this.staticAssetsPublicPath, contentSourceData.defaultLocaleCode);
        }
        else {
            assets = lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
                const filteredAssets = (0, filtered_entities_1.getFilteredAssetsForUser)({
                    user,
                    assets: contentSourceData.assets,
                    filterAsset: this.stackbitConfig?.filterAsset,
                    contentSourceDataById: this.contentSourceDataById,
                    configDelegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
                });
                const assets = (0, store_to_api_docs_converter_1.mapStoreAssetsToAPIAssets)(filteredAssets, this.staticAssetsPublicPath, contentSourceData.defaultLocaleCode);
                return result.concat(assets);
            }, []);
        }
        let filteredFiles = assets;
        if (searchQuery) {
            const sanitizedSearchQuery = (0, sanitize_filename_1.default)(searchQuery).toLowerCase();
            filteredFiles = assets.filter((asset) => asset.fileName && path_1.default.basename(asset.fileName).toLowerCase().includes(sanitizedSearchQuery));
        }
        const sortedAssets = lodash_1.default.orderBy(filteredFiles, ['fileName'], ['asc']);
        const skip = (pageNum - 1) * pageSize;
        const totalPages = Math.ceil(filteredFiles.length / pageSize);
        const pagesAssets = sortedAssets.slice(skip, skip + pageSize);
        return {
            assets: pagesAssets,
            pageSize: pageSize,
            pageNum: pageNum,
            totalPages: totalPages
        };
    }
    getApiAssetsV2({ assetSpecs, user, pageSize = 20, pageNum = 1, searchQuery, locale } = {}) {
        let contentSourceAssets;
        if (assetSpecs?.length) {
            contentSourceAssets = assetSpecs?.reduce((acc, assetSpec) => {
                const contentSourceId = (0, content_store_utils_1.getContentSourceId)(assetSpec.srcType, assetSpec.srcProjectId);
                const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
                const asset = contentSourceData?.assetMap[assetSpec.srcDocumentId];
                if (asset) {
                    acc.push(asset);
                }
                return acc;
            }, []);
        }
        else {
            contentSourceAssets = lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => result.concat(...contentSourceData.assets), []);
        }
        let filteredAssets = (0, filtered_entities_1.getFilteredAssetsForUser)({
            user,
            assets: contentSourceAssets,
            filterAsset: this.stackbitConfig?.filterAsset,
            contentSourceDataById: this.contentSourceDataById,
            configDelegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
        });
        if (searchQuery) {
            const sanitizedSearchQuery = (0, sanitize_filename_1.default)(searchQuery).toLowerCase();
            filteredAssets = filteredAssets.filter((asset) => {
                const assetField = Object.values(asset.fields).find((field) => field.type === 'assetFile');
                if (!assetField) {
                    return;
                }
                let fileName;
                if (assetField.localized) {
                    fileName = locale ? assetField.locales[locale]?.fileName : undefined;
                }
                else {
                    fileName = assetField.fileName;
                }
                return fileName && path_1.default.basename(fileName).toLowerCase().includes(sanitizedSearchQuery);
            });
        }
        filteredAssets = filteredAssets.map((asset) => {
            const assetField = Object.values(asset.fields).find((field) => field.type === 'assetFile');
            if (!assetField) {
                return asset;
            }
            if (assetField.localized) {
                if (locale && assetField.locales[locale]) {
                    assetField.locales[locale] = {
                        ...assetField.locales[locale],
                        locale,
                        url: (0, store_to_api_docs_converter_1.replaceAssetUrlIfNeeded)(this.staticAssetsPublicPath, assetField.locales[locale].url) ?? this.staticAssetsPublicPath
                    };
                }
            }
            else {
                assetField.url = (0, store_to_api_docs_converter_1.replaceAssetUrlIfNeeded)(this.staticAssetsPublicPath, assetField.url) ?? this.staticAssetsPublicPath;
            }
            return asset;
        });
        const sortedAssets = lodash_1.default.orderBy(filteredAssets, ['fileName'], ['asc']);
        let skip;
        let totalPages;
        let pagesAssets;
        // don't sort out assets in case assetsSpecs defined
        if (assetSpecs?.length) {
            skip = 0;
            totalPages = 1;
            pageNum = 1;
            pagesAssets = sortedAssets;
            pageSize = sortedAssets.length;
        }
        else {
            skip = (pageNum - 1) * pageSize;
            totalPages = Math.ceil(filteredAssets.length / pageSize);
            pagesAssets = assetSpecs?.length ? sortedAssets : sortedAssets.slice(skip, skip + pageSize);
        }
        return {
            assets: pagesAssets,
            pageSize: pageSize,
            pageNum: pageNum,
            totalPages: totalPages
        };
    }
    async createAndLinkDocument({ srcType, srcProjectId, srcDocumentId, fieldPath, modelName, refSrcType, refProjectId, object, index, locale, user }) {
        this.logger.debug('createAndLinkDocument', { srcType, srcProjectId, srcDocumentId, fieldPath, modelName, refSrcType, refProjectId, index, locale });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        // get the document that is being updated
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}'. Source: '${contentSourceData.id}'.`);
        }
        const modelMap = contentSourceData.modelMap;
        const csiModelMap = contentSourceData.csiModelMap;
        // get the 'reference' model field in the updated document that will be used to link the new document
        locale = locale ?? contentSourceData.defaultLocaleCode;
        const modelField = (0, field_path_utils_1.getModelFieldAtFieldPath)({ document, fieldPath, modelMap, locale });
        const csiModelField = (0, field_path_utils_1.getModelFieldAtFieldPath)({ document, fieldPath, modelMap: csiModelMap, locale });
        if (!modelField || !csiModelField) {
            throw Error(`Field path not found:'${fieldPath.join('.')}'.`);
        }
        const fieldProps = modelField.type === 'list' ? modelField.items : modelField;
        const csiFieldProps = csiModelField.type === 'list' ? csiModelField.items : csiModelField;
        if (fieldProps.type !== 'reference' && fieldProps.type !== 'cross-reference') {
            throw new Error(`createAndLinkDocument can only be used on fields of type reference at field path: '${fieldPath.join('.')}'`);
        }
        // get the model name for the new document
        if (!modelName && fieldProps.models.length === 1) {
            if (fieldProps.type === 'reference') {
                modelName = fieldProps.models[0];
            }
            else if (fieldProps.type === 'cross-reference') {
                modelName = fieldProps.models[0].modelName;
            }
        }
        if (!modelName) {
            throw new Error(`modelName is required for createAndLinkDocument. Field path: '${fieldPath.join('.')}'.`);
        }
        if (fieldProps.type === 'reference') {
            refSrcType = srcType;
            refProjectId = srcProjectId;
        }
        else if (!refSrcType || !refProjectId) {
            throw new Error(`refSrcType and refProjectId are required for linking fields of type cross-reference for field path: '${fieldPath.join('.')}'.`);
        }
        // create the new document
        const result = await this.createDocument({
            object: object,
            srcProjectId: refProjectId,
            srcType: refSrcType,
            modelName: modelName,
            locale: locale,
            user: user
        });
        // update the document by linking the field to the created document
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        let field;
        if (fieldProps.type === 'reference') {
            field = {
                type: 'reference',
                refType: 'document',
                refId: result.srcDocumentId
            };
        }
        else {
            if (!(0, types_1.isOneOfFieldTypes)(csiFieldProps.type, ['string', 'text', 'json', 'cross-reference'])) {
                throw new Error(`Invalid type for cross-reference field: ${csiFieldProps.type}. Must be one of: string, text, json, cross-reference. Field path: '${fieldPath.join('.')}'.`);
            }
            field = (0, content_store_utils_1.updateOperationValueFieldWithCrossReference)(csiFieldProps.type, {
                refId: result.srcDocumentId,
                refSrcType: refSrcType,
                refProjectId: refProjectId
            });
        }
        const operations = [
            modelField.type === 'list'
                ? {
                    opType: 'insert',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    index: index,
                    item: field
                }
                : {
                    opType: 'set',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    field: field
                }
        ];
        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext: userContext,
                operations: operations
            },
            contentSourceData: contentSourceData,
            user: user
        });
        return { srcDocumentId: srcDocumentId, createdDocumentId: result.srcDocumentId };
    }
    async createPreset({ preset, thumbnailAsset, user }) {
        if (!this.presetsContentSource) {
            throw new Error('Error saving preset: No content source available.');
        }
        let thumbnail;
        if (thumbnailAsset) {
            const assets = await this.uploadAssets({
                srcType: this.presetsContentSource.getContentSourceType(),
                srcProjectId: this.presetsContentSource.getProjectId(),
                assets: [thumbnailAsset],
                user
            });
            thumbnail = assets[0]?.objectId;
        }
        const contentSourceData = this.getContentSourceDataByIdOrThrow((0, content_store_utils_1.getContentSourceIdForContentSource)(this.presetsContentSource));
        const document = await this.createDocument({
            srcType: this.presetsContentSource.getContentSourceType(),
            srcProjectId: this.presetsContentSource.getProjectId(),
            modelName: consts_1.STACKBIT_PRESET_MODEL_NAME,
            object: {
                ...(0, preset_utils_1.getDocumentObjectFromPreset)(preset, contentSourceData.modelMap[consts_1.STACKBIT_PRESET_MODEL_NAME]),
                thumbnail
            },
            user
        });
        return { srcDocumentId: document.srcDocumentId };
    }
    async deletePreset({ presetId, user }) {
        if (!this.presetsContentSource) {
            throw new Error('Error deleting preset: No content source available.');
        }
        await this.deleteDocument({
            srcType: this.presetsContentSource.getContentSourceType(),
            srcProjectId: this.presetsContentSource.getProjectId(),
            srcDocumentId: presetId,
            user
        });
        // we delete presets immediately because some CMSs don't notify us
        // when documents have been deleted.
        const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(this.presetsContentSource);
        this.pushContentSourceEvent({
            eventName: types_2.ContentStoreEventType.ContentSourceContentChange,
            contentSourceId: contentSourceId,
            contentChanges: {
                documents: [],
                deletedDocumentIds: [presetId],
                assets: [],
                deletedAssetIds: []
            }
        });
        await this.processContentStoreEvents();
    }
    async uploadAndLinkAsset({ srcType, srcProjectId, srcDocumentId, fieldPath, asset, index, locale, user }) {
        this.logger.debug('uploadAndLinkAsset', { srcType, srcProjectId, srcDocumentId, fieldPath, index, locale });
        // get the document that is being updated
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}'. Source: '${contentSourceData.id}'.`);
        }
        const csiModelMap = contentSourceData.csiModelMap;
        // get the 'reference' model field in the updated document that will be used to link the new asset
        locale = locale ?? contentSourceData.defaultLocaleCode;
        const csiModelField = (0, field_path_utils_1.getModelFieldAtFieldPath)({
            document,
            fieldPath,
            modelMap: csiModelMap,
            locale
        });
        if (!csiModelField) {
            throw Error(`Field path not found: '${fieldPath.join('.')}'.`);
        }
        const fieldProps = csiModelField.type === 'list' ? csiModelField.items : csiModelField;
        if (fieldProps.type !== 'reference' && fieldProps.type !== 'image') {
            throw Error(`uploadAndLinkAsset can only be used on fields of type: reference, image. Field path: '${fieldPath.join('.')}'.`);
        }
        // upload the new asset
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const result = await contentSourceData.instance.uploadAsset({
            url: asset.url,
            fileName: asset.metadata.name,
            mimeType: asset.metadata.type,
            locale: locale,
            userContext: userContext
        });
        // update the document by linking the field to the created asset
        const field = {
            type: 'reference',
            refType: 'asset',
            refId: result.id
        };
        const operations = [
            csiModelField.type === 'list'
                ? {
                    opType: 'insert',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    index: index,
                    item: field
                }
                : {
                    opType: 'set',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    field: field
                }
        ];
        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext: userContext,
                operations: operations
            },
            contentSourceData: contentSourceData,
            user: user
        });
        return { srcDocumentId: srcDocumentId };
    }
    async createDocument({ srcType, srcProjectId, modelName, object, locale, defaultLocaleDocumentId, user }) {
        this.logger.debug('createDocument', { srcType, srcProjectId, modelName, locale });
        (0, user_log_utils_1.logCreateDocument)({ userLogger: this.userLogger, srcType, srcProjectId, modelName, locale, object });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const resolvedLocale = locale ?? contentSourceData.defaultLocaleCode;
        const csiModel = contentSourceData.csiModelMap[modelName];
        if (!csiModel) {
            throw new Error(`Error creating document: model not found: '${modelName}' (source: ${contentSourceId}).`);
        }
        if (this.stackbitConfig?.onContentCreate) {
            object = await this.stackbitConfig.onContentCreate({
                object: object ?? {},
                locale,
                model: {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiModel
                },
                ...(0, config_delegate_1.createConfigDelegate)({
                    contentSourceDataById: this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
            if ('$$type' in object) {
                // onContentCreate changed the type of the object
                if (object.$$type !== modelName) {
                    modelName = object.$$type;
                }
                delete object.$$type;
            }
        }
        const result = await (0, create_update_csi_docs_1.createDocumentRecursively)({
            object,
            locale: resolvedLocale,
            userLogger: this.userLogger,
            modelName,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            assetSources: this.stackbitConfig?.assetSources ?? [],
            createDocument: this.getCreateDocumentThunk({
                defaultLocaleDocumentId,
                user
            })
        });
        this.logger.debug('created document', { srcType, srcProjectId, srcDocumentId: result.documentId, modelName });
        return { srcDocumentId: result.documentId };
    }
    async updateDocument({ srcType, srcProjectId, srcDocumentId, updateOperations, user }) {
        this.logger.debug('updateDocument');
        (0, user_log_utils_1.logUpdateDocument)({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId, updateOperations });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        const modelMap = contentSourceData.modelMap;
        const csiModelMap = contentSourceData.csiModelMap;
        const documentModelName = document.srcModelName;
        const csiModel = csiModelMap[documentModelName];
        if (!csiModel) {
            throw new Error(`Error updating document: could not find document model '${documentModelName}'.`);
        }
        const operations = await (0, utils_1.mapPromise)(updateOperations, async (updateOperation) => {
            const locale = updateOperation.locale ?? contentSourceData.defaultLocaleCode;
            const modelField = (0, field_path_utils_1.getModelFieldAtFieldPath)({
                document,
                fieldPath: updateOperation.fieldPath,
                modelMap,
                locale
            });
            const csiModelField = (0, field_path_utils_1.getModelFieldAtFieldPath)({
                document,
                fieldPath: updateOperation.fieldPath,
                modelMap: csiModelMap,
                locale
            });
            switch (updateOperation.opType) {
                case 'set': {
                    const field = await (0, create_update_csi_docs_1.convertOperationField)({
                        operationField: updateOperation.field,
                        fieldPath: [csiModel.name, ...updateOperation.fieldPath],
                        modelField,
                        csiModelField,
                        locale,
                        modelMap,
                        csiModelMap,
                        contentSourceId,
                        contentSourceDataById: this.contentSourceDataById,
                        assetSources: this.stackbitConfig?.assetSources ?? [],
                        createDocument: this.getCreateDocumentThunk({ user }),
                        userLogger: this.userLogger
                    });
                    return {
                        ...updateOperation,
                        modelField: csiModelField,
                        field
                    };
                }
                case 'unset':
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
                case 'insert': {
                    if (modelField.type !== 'list' || csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Insert operations can be performed on list fields only.');
                    }
                    const item = (await (0, create_update_csi_docs_1.convertOperationField)({
                        operationField: updateOperation.item,
                        fieldPath: [csiModel.name, ...updateOperation.fieldPath],
                        modelField: modelField.items,
                        csiModelField: csiModelField.items,
                        locale,
                        modelMap,
                        csiModelMap,
                        contentSourceId,
                        contentSourceDataById: this.contentSourceDataById,
                        assetSources: this.stackbitConfig?.assetSources ?? [],
                        createDocument: this.getCreateDocumentThunk({ user }),
                        userLogger: this.userLogger
                    }));
                    return {
                        ...updateOperation,
                        modelField: csiModelField,
                        item
                    };
                }
                case 'remove':
                    if (csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Remove operations can be performed on list fields only.');
                    }
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
                case 'reorder':
                    if (csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Reorder operations can be performed on list fields only.');
                    }
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
            }
        });
        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext,
                operations
            },
            contentSourceData: contentSourceData,
            user: user
        });
        return { srcDocumentId: srcDocumentId };
    }
    async updateAsset({ srcType, srcProjectId, srcAssetId, updateOperations, user }) {
        this.logger.debug('updateAsset');
        (0, user_log_utils_1.logUpdateAsset)({ userLogger: this.userLogger, srcType, srcProjectId, srcAssetId, updateOperations });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const asset = contentSourceData.assetMap[srcAssetId];
        const csiAsset = contentSourceData.csiAssetMap[srcAssetId];
        if (!asset || !csiAsset) {
            throw new Error(`Asset not found: '${srcAssetId}' (Source: '${contentSourceData.id}'.)`);
        }
        const operations = await (0, utils_1.mapPromise)(updateOperations, async (updateOperation) => {
            const locale = updateOperation.locale ?? contentSourceData.defaultLocaleCode;
            const fieldPath = updateOperation.fieldPath;
            const fieldName = lodash_1.default.head(fieldPath);
            if (typeof fieldName !== 'string') {
                throw new Error('the first fieldPath must be string');
            }
            const modelField = lodash_1.default.find(common_schema_1.ASSET_MODEL.fields, { name: fieldName });
            if (!modelField) {
                throw new Error(`field ${fieldName} doesn't exist`);
            }
            if (modelField.type === 'assetFile') {
                throw new Error('Update for assetFile is not supported');
            }
            switch (updateOperation.opType) {
                case 'set': {
                    const field = await (0, create_update_csi_docs_1.convertOperationField)({
                        operationField: updateOperation.field,
                        fieldPath: [common_schema_1.ASSET_MODEL.name, ...updateOperation.fieldPath],
                        modelField,
                        csiModelField: modelField,
                        locale,
                        modelMap: {},
                        csiModelMap: {},
                        contentSourceId,
                        contentSourceDataById: this.contentSourceDataById,
                        assetSources: this.stackbitConfig?.assetSources ?? [],
                        createDocument: this.getCreateDocumentThunk({ user }),
                        userLogger: this.userLogger
                    });
                    return {
                        ...updateOperation,
                        modelField,
                        field
                    };
                }
                case 'unset':
                    return {
                        ...updateOperation,
                        modelField
                    };
                default:
                    throw new Error('Invalid operation.');
            }
        });
        await contentSourceData.instance.updateAsset?.({
            asset: csiAsset,
            operations,
            userContext
        });
        return { srcAssetId };
    }
    async duplicateDocument({ srcType, srcProjectId, srcDocumentId, object, locale, user }) {
        this.logger.debug('duplicateDocument', { srcType, srcProjectId, srcDocumentId, locale });
        (0, user_log_utils_1.logDuplicateDocument)({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId, locale });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const document = contentSourceData.documentMap[srcDocumentId];
        if (!document) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        const model = contentSourceData.modelMap[document.srcModelName];
        const csiModel = contentSourceData.csiModelMap[document.srcModelName];
        if (!model || !csiModel) {
            throw new Error(`Model not found: '${document.srcModelName}' (source: ${contentSourceId})`);
        }
        const resolvedLocale = locale ?? contentSourceData.defaultLocaleCode;
        let extendedObject = (0, duplicate_document_1.mergeObjectWithDocument)({
            object,
            document,
            locale: resolvedLocale,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            referenceBehavior: this.stackbitConfig?.presetReferenceBehavior,
            duplicatableModels: this.stackbitConfig?.duplicatableModels,
            nonDuplicatableModels: this.stackbitConfig?.nonDuplicatableModels
        });
        if (this.stackbitConfig?.onContentCreate) {
            extendedObject = await this.stackbitConfig.onContentCreate({
                object: extendedObject ?? {},
                locale,
                model: {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiModel
                },
                ...(0, config_delegate_1.createConfigDelegate)({
                    contentSourceDataById: this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
        }
        const result = await (0, create_update_csi_docs_1.createDocumentRecursively)({
            object: extendedObject,
            locale: resolvedLocale,
            userLogger: this.userLogger,
            modelName: model.name,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            assetSources: this.stackbitConfig?.assetSources ?? [],
            createDocument: this.getCreateDocumentThunk({ user })
        });
        this.logger.debug('duplicated document', { srcType, srcProjectId, srcDocumentId, newDocumentId: result.documentId, modelName: model.name });
        return { srcDocumentId: result.documentId };
    }
    getCreateDocumentThunk({ defaultLocaleDocumentId, user }) {
        return (0, create_update_csi_docs_1.getCreateDocumentThunk)({
            stackbitConfig: this.stackbitConfig,
            getContentSourceDataById: () => this.contentSourceDataById,
            logger: this.userLogger,
            defaultLocaleDocumentId: defaultLocaleDocumentId,
            user: user
        });
    }
    async updateDocumentHooked(options) {
        await (0, document_validations_1.validateUpdateOperations)({
            updateOperations: options.updateDocumentOptions.operations,
            csiDocument: options.updateDocumentOptions.document,
            contentSourceData: options.contentSourceData,
            configDelegate: (0, config_delegate_1.createConfigDelegate)({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            })
        });
        return (0, document_hooks_1.updateDocumentHooked)({
            actionOptions: options.updateDocumentOptions,
            stackbitConfig: this.stackbitConfig,
            contentSourceData: options.contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: options.user,
            logger: this.userLogger
        });
    }
    async uploadAssets({ srcType, srcProjectId, assets, locale, user }) {
        this.logger.debug('uploadAssets');
        (0, user_log_utils_1.logUploadAssets)({ userLogger: this.userLogger, srcType, srcProjectId, assets, locale });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const sourceAssets = [];
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        locale = locale ?? contentSourceData.defaultLocaleCode;
        for (const asset of assets) {
            let base64 = undefined;
            if (asset.data) {
                const matchResult = asset.data.match(/;base64,([\s\S]+)$/);
                if (matchResult) {
                    base64 = matchResult[1];
                }
            }
            const sourceAsset = await contentSourceData.instance.uploadAsset({
                url: asset.url,
                base64: base64,
                fileName: asset.metadata.name,
                mimeType: asset.metadata.type,
                locale: locale,
                userContext: userContext
            });
            sourceAssets.push(sourceAsset);
        }
        const storeAssets = (0, csi_to_store_docs_converter_1.mapCSIAssetsToStoreAssets)({
            csiAssets: sourceAssets,
            contentSourceInstance: contentSourceData.instance,
            defaultLocaleCode: contentSourceData.defaultLocaleCode
        });
        return (0, store_to_api_docs_converter_1.mapStoreAssetsToAPIAssets)(storeAssets, this.staticAssetsPublicPath, locale);
    }
    async deleteDocument({ srcType, srcProjectId, srcDocumentId, user }) {
        this.logger.debug('deleteDocument');
        (0, user_log_utils_1.logDocumentEvent)('Delete', { userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId });
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        await (0, document_hooks_1.deleteDocumentHooked)({
            actionOptions: { document: csiDocument, userContext },
            stackbitConfig: this.stackbitConfig,
            contentSourceData: contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: user,
            logger: this.userLogger
        });
    }
    async archiveDocument({ srcType, srcProjectId, srcDocumentId, user }) {
        this.logger.debug('archiveDocument');
        (0, user_log_utils_1.logDocumentEvent)('Archive', { userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId });
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        await (0, document_hooks_1.archiveDocumentHooked)({
            actionOptions: { document: csiDocument, userContext },
            stackbitConfig: this.stackbitConfig,
            contentSourceData: contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: user,
            logger: this.userLogger
        });
    }
    async unarchiveDocument({ srcType, srcProjectId, srcDocumentId, user }) {
        this.logger.debug('unarchiveDocument');
        (0, user_log_utils_1.logDocumentEvent)('Unarchive', { userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId });
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        await (0, document_hooks_1.unarchiveDocumentHooked)({
            actionOptions: { document: csiDocument, userContext },
            stackbitConfig: this.stackbitConfig,
            contentSourceData: contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: user,
            logger: this.userLogger
        });
    }
    getScheduledActions() {
        const scheduledActions = lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            return result.concat(contentSourceData.scheduledActions.map((scheduledAction) => ({
                ...scheduledAction,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId
            })));
        }, []);
        return scheduledActions;
    }
    async updateScheduledAction({ srcType, srcProjectId, scheduledActionId, documentIds, name, executeAt, user }) {
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('updateScheduledAction', { srcType, srcProjectId, scheduledActionId });
        if (!contentSourceData.instance.updateScheduledAction) {
            this.logger.error('Trying to call updateScheduledAction, but it is not implemented', { srcType, srcProjectId, scheduledActionId });
            throw new Error('Content source plugin missing required method: updateScheduledAction');
        }
        return contentSourceData.instance.updateScheduledAction({ scheduledActionId, documentIds, name, executeAt, userContext });
    }
    async cancelScheduledAction({ srcType, srcProjectId, scheduledActionId, user }) {
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('cancelScheduledAction', { srcType, srcProjectId, scheduledActionId });
        if (!contentSourceData.instance.cancelScheduledAction) {
            this.logger.error('Trying to call cancelScheduledAction, but it is not implemented', { srcType, srcProjectId, scheduledActionId });
            throw new Error('Content source plugin missing required method: cancelScheduledAction');
        }
        return contentSourceData.instance.cancelScheduledAction({ scheduledActionId, userContext });
    }
    async createScheduledAction({ srcType, srcProjectId, documentIds, name, action, executeAt, user }) {
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('createScheduledAction', { srcType, srcProjectId, documentIds, name, action, executeAt });
        if (!contentSourceData.instance.createScheduledAction) {
            this.logger.error('Trying to call createScheduledAction, but it is not implemented', {
                srcType,
                srcProjectId,
                documentIds,
                name,
                action,
                executeAt
            });
            throw new Error('Content source plugin missing required method: createScheduledAction');
        }
        return contentSourceData.instance.createScheduledAction({ documentIds, name, action, executeAt, userContext });
    }
    async validateDocuments({ objects, locale, user }) {
        this.logger.debug('validateDocuments');
        const objectsBySourceId = lodash_1.default.groupBy(objects, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
        let errors = [];
        for (const [contentSourceId, contentSourceObjects] of Object.entries(objectsBySourceId)) {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            locale = locale ?? contentSourceData.defaultLocaleCode;
            const { documents, assets } = (0, content_store_utils_1.getCSIDocumentsAndAssetsFromContentSourceDataByIds)(contentSourceData, contentSourceObjects);
            const userContext = (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user);
            const internalValidationErrors = (0, document_validations_1.internalValidateContent)(documents, assets, contentSourceData, locale);
            const validationResult = await contentSourceData.instance.validateDocuments({ documents, assets, locale, userContext });
            errors = errors.concat(internalValidationErrors, validationResult.errors.map((validationError) => ({
                message: validationError.message,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectType: validationError.objectType,
                srcObjectId: validationError.objectId,
                fieldPath: validationError.fieldPath,
                isUniqueValidation: validationError.isUniqueValidation
            })));
        }
        return { errors };
        /* validate for multiple sources
        const objectsBySourceId = _.groupBy(objects, (document) => getContentSourceId(document.srcType, document.srcProjectId));
        const contentSourceIds = Object.keys(objectsBySourceId);
        return reducePromise(
            contentSourceIds,
            async (result: ContentStoreTypes.ValidationError[], contentSourceId) => {
                const documents = documentsBySourceId[contentSourceId]!;
                const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
                const validationErrors = await contentSourceData.instance.validateDocuments({ documentIds: documents.map((document) => document.srcObjectId) });
                return result.concat(validationErrors);
            },
            []
        );
         */
    }
    async searchDocuments(data) {
        this.logger.debug('searchDocuments');
        const locale = data.locale;
        const objectsBySourceId = lodash_1.default.groupBy(data.models, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
        const contentSourceIds = Object.keys(objectsBySourceId);
        const documents = [];
        const schema = {};
        const scheduledActions = [];
        const defaultLocales = {};
        contentSourceIds.forEach((contentSourceId) => {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            lodash_1.default.set(schema, [contentSourceData.srcType, contentSourceData.srcProjectId], contentSourceData.modelMap);
            const contentSourceDocuments = lodash_1.default.isEmpty(locale)
                ? contentSourceData.documents
                : contentSourceData.documents.filter((document) => !document.locale || document.locale === locale);
            const contentSourceScheduledActions = contentSourceData.scheduledActions;
            const filteredDocuments = contentSourceDocuments.filter((document) => document.srcModelName !== consts_1.STACKBIT_PRESET_MODEL_NAME);
            const userDocuments = (0, filtered_entities_1.getFilteredDocumentsForUser)({
                user: data.user,
                documents: filteredDocuments,
                permissionsForModel: this.stackbitConfig?.permissionsForModel,
                permissionsForDocument: this.stackbitConfig?.permissionsForDocument,
                contentSourceDataById: this.contentSourceDataById,
                createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                    getContentSourceDataById: () => this.contentSourceDataById,
                    logger: this.userLogger
                }),
                logger: this.userLogger
            });
            // filter out hidden documents from the search
            const visibleDocuments = userDocuments.filter((document) => !document.hidden);
            documents.push(...visibleDocuments);
            scheduledActions.push(...contentSourceScheduledActions);
            if (contentSourceData.defaultLocaleCode) {
                defaultLocales[contentSourceId] = contentSourceData.defaultLocaleCode;
            }
        });
        return (0, search_utils_1.searchDocuments)({
            ...data,
            documents,
            schema,
            locale,
            scheduledActions,
            defaultLocales
        });
    }
    async getDocumentVersions({ srcType, srcProjectId, documentId, locale, user }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        locale = locale ?? contentSourceData.defaultLocaleCode;
        this.logger.debug('getDocumentVersions', { srcType, srcProjectId, documentId });
        if (!contentSourceData.instance.getDocumentVersions) {
            this.logger.error('Trying to call getDocumentVersions, but it is not implemented', {
                srcType,
                srcProjectId,
                documentId
            });
            throw new Error('Content source plugin missing required method: getDocumentVersions');
        }
        const { versions } = await contentSourceData.instance.getDocumentVersions({ documentId });
        const models = (0, filtered_entities_1.getContentSourceFilteredModelsForUser)({
            user,
            contentSourceData,
            configDelegate: (0, config_delegate_1.createConfigDelegate)({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            }),
            permissionsForModel: this.stackbitConfig?.permissionsForModel
        });
        const apiVersions = (0, csi_to_api_docs_converter_1.mapDocumentVersionsToApiDocumentVersions)({
            assetSources: this.stackbitConfig?.assetSources ?? [],
            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            }),
            versions,
            contentSourceData,
            contentSourceDataById: this.contentSourceDataById,
            locale,
            modelMap: (0, model_utils_1.getModelMap)({ models })
        });
        return { versions: apiVersions };
    }
    async getDocumentForVersion({ srcType, srcProjectId, documentId, versionId, locale, user }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        locale = locale ?? contentSourceData.defaultLocaleCode;
        this.logger.debug('getDocumentForVersion', { srcType, srcProjectId, documentId, versionId });
        if (!contentSourceData.instance.getDocumentForVersion) {
            this.logger.error('Trying to call getDocumentForVersion, but it is not implemented', {
                srcType,
                srcProjectId,
                documentId,
                versionId
            });
            throw new Error('Content source plugin missing required method: getDocumentForVersion');
        }
        const { version } = await contentSourceData.instance.getDocumentForVersion({ documentId, versionId });
        const models = (0, filtered_entities_1.getContentSourceFilteredModelsForUser)({
            user,
            contentSourceData,
            configDelegate: (0, config_delegate_1.createConfigDelegate)({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            }),
            permissionsForModel: this.stackbitConfig?.permissionsForModel
        });
        const [apiVersion] = (0, csi_to_api_docs_converter_1.mapDocumentVersionsToApiDocumentVersions)({
            versions: [version],
            assetSources: this.stackbitConfig?.assetSources ?? [],
            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            }),
            contentSourceData,
            locale,
            contentSourceDataById: this.contentSourceDataById,
            modelMap: (0, model_utils_1.getModelMap)({ models })
        });
        if (!apiVersion || !apiVersion.object || !apiVersion.document || !apiVersion.apiDocument) {
            throw new Error(`getDocumentForVersion could not transform document into api object for document ${version.documentId}`);
        }
        // unwrap TS types
        const { object, document, apiDocument } = apiVersion;
        return {
            version: {
                ...apiVersion,
                object,
                document,
                apiDocument
            }
        };
    }
    async publishDocuments({ objects, user }) {
        this.logger.debug('publishDocuments');
        (0, user_log_utils_1.logDocumentsEvent)('Publish', { userLogger: this.userLogger, objects });
        const objectsBySourceId = lodash_1.default.groupBy(objects, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
        for (const [contentSourceId, contentSourceObjects] of Object.entries(objectsBySourceId)) {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            const userContext = (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user);
            const { documents, assets } = (0, content_store_utils_1.getCSIDocumentsAndAssetsFromContentSourceDataByIds)(contentSourceData, contentSourceObjects);
            await (0, document_hooks_1.publishDocumentHooked)({
                actionOptions: { documents, assets, userContext },
                stackbitConfig: this.stackbitConfig,
                contentSourceData: contentSourceData,
                getContentSourceDataById: () => this.contentSourceDataById,
                user: user,
                logger: this.userLogger
            });
        }
    }
    async unpublishDocuments({ objects, user }) {
        this.logger.debug('unpublishDocuments');
        (0, user_log_utils_1.logDocumentsEvent)('Unpublish', { userLogger: this.userLogger, objects });
        const objectsBySourceId = lodash_1.default.groupBy(objects, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
        for (const [contentSourceId, contentSourceObjects] of Object.entries(objectsBySourceId)) {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            const userContext = (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user);
            const { documents, assets } = (0, content_store_utils_1.getCSIDocumentsAndAssetsFromContentSourceDataByIds)(contentSourceData, contentSourceObjects);
            await (0, document_hooks_1.unpublishDocumentHooked)({
                actionOptions: { documents, assets, userContext },
                stackbitConfig: this.stackbitConfig,
                contentSourceData: contentSourceData,
                getContentSourceDataById: () => this.contentSourceDataById,
                user: user,
                logger: this.userLogger
            });
        }
    }
    getContentSourceDataByIdOrThrow(contentSourceId) {
        return (0, content_store_utils_1.getContentSourceDataByIdOrThrow)(contentSourceId, this.contentSourceDataById);
    }
    async onWebhook({ srcType, srcProjectId, data, headers }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const contentEngineConfig = contentSourceData.instance.getContentEngineConfig?.();
        // If the current content source has a content-engine config,
        // then it is a unified connector, so we need to call contentEngine's sync().
        if (contentEngineConfig && this.contentEngine) {
            // if there's a content-engine always pass the webhook body to it
            await this.contentEngine.sync({
                webhookBody: data,
                connector: contentEngineConfig.connector
            });
        }
        else {
            return contentSourceData.instance.onWebhook?.({ data, headers });
        }
    }
    getWebhookUrl(contentSourceType, projectId) {
        if (!this.webhookUrl) {
            return undefined;
        }
        return `${this.webhookUrl}/${encodeURIComponent(contentSourceType)}/${encodeURIComponent(projectId)}`;
    }
    async pullContent() {
        const hasGitCS = this.contentSources.some((contentSource) => contentSource.isGitCms);
        this.logger.debug(`pullContent requested - ${hasGitCS ? 'has git content source' : 'no git content source'}`);
        if (!hasGitCS) {
            return { didPull: false };
        }
        try {
            const changedFiles = await this.git.diffFilesWithFetchHead();
            const filePaths = changedFiles.map((changedFile) => changedFile.filePath);
            const filesChangeResult = await this.onFilesChange(filePaths, true);
            if (filesChangeResult.codeChanged) {
                // when there are code files - pull files one by one and create a shadow repo for committing diffs
                const contentFiles = filesChangeResult.contentFiles.map((filePath) => changedFiles.find((file) => file.filePath === filePath)).filter(utils_1.isTruthy);
                this.logger.debug(`pullContent code changed, ${changedFiles.length} total changed files, ${contentFiles.length} content changed files`, {
                    changedFiles,
                    contentFiles
                });
                await this.git.pullFilesFromFetchHead(contentFiles);
                await this.git.createShadowRepo();
                return { didPull: false };
            }
            // when it's only content - just pull
            this.logger.debug(`pullContent content changed only, pulling git`);
            await this.git.pull();
            return { didPull: true };
        }
        catch (err) {
            this.logger.error('Could not pullContent', err);
            return { didPull: false };
        }
    }
}
exports.ContentStore = ContentStore;
//# sourceMappingURL=content-store.js.map