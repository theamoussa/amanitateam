import { Config, Model as SDKModel } from '@stackbit/sdk';
import { FieldSpecificProps } from '@stackbit/types';
import * as CSITypes from '@stackbit/types';
import * as ContentStoreTypes from '../types';
export type CreateDocumentThunk = ({ updateOperationFields, contentSourceData, modelName, locale }: {
    updateOperationFields: Record<string, CSITypes.UpdateOperationField>;
    contentSourceData: ContentStoreTypes.ContentSourceData;
    modelName: string;
    locale: string | undefined;
}) => Promise<{
    documentId: string;
}>;
export declare function getCreateDocumentThunk({ stackbitConfig, getContentSourceDataById, logger, defaultLocaleDocumentId, user }: {
    stackbitConfig: Config | null;
    getContentSourceDataById: () => Record<string, ContentStoreTypes.ContentSourceData>;
    logger: CSITypes.Logger;
    defaultLocaleDocumentId?: string;
    user?: ContentStoreTypes.User;
}): CreateDocumentThunk;
/**
 * Receives a plain `object`, and creates a map of `CSITypes.UpdateOperationField`
 * by recursively iterating the `object` fields. Then invokes the `createDocument`
 * callback to delegate the creation of the document to a CSI module.
 *
 * If the `object` has fields of type `reference`, `cross-reference` or `model`
 * with the special `$$type` property holding the model name of the nested object,
 * this function will recursively create new documents and nested objects for
 * these fields. Other fields within the object will be used to populate the
 * fields of the new document or nested object.
 *
 * @example
 * {
 *     title: 'hello world',
 *     button: {
 *         $$type: 'Button',   // a new nested object of type Button will be
 *         label: 'Click me'   // created with 'label' field set to 'Click me'
 *     }
 * }
 *
 * If the `object` has fields of type `reference` or `image` with the special
 * `$$ref` property holding an ID of an existing document, this function will
 * link an existing documents or assets with that ID.
 *
 * @example
 * {
 *     title: 'hello world',
 *     author: {
 *         $$ref: 'xyz'        // the 'author' field will be linked to a document
 *                             // with ID 'xyz'
 *     }
 * }
 *
 * Returns an object with two fields:
 * 1. `document` holding the created CSITypes.Document for the passed object.
 * 2. `newRefDocumentIds` containing the list of the created document IDs that
 *    were created recursively for `reference` fields having the `$$type` property.
 */
export declare function createDocumentRecursively({ object, locale, modelName, contentSourceId, contentSourceDataById, assetSources, createDocument, userLogger }: {
    object?: Record<string, any>;
    locale: string | undefined;
    modelName: string;
    contentSourceId: string;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    assetSources: CSITypes.AssetSource[];
    createDocument: CreateDocumentThunk;
    userLogger: CSITypes.Logger;
}): Promise<{
    documentId: string;
    newRefDocumentIds: string[];
}>;
export declare function convertOperationField({ operationField, fieldPath, modelField, csiModelField, locale, modelMap, csiModelMap, contentSourceId, contentSourceDataById, assetSources, createDocument, userLogger }: {
    operationField: ContentStoreTypes.UpdateOperationField;
    fieldPath: (string | number)[];
    modelField: FieldSpecificProps;
    csiModelField: FieldSpecificProps;
    locale: string | undefined;
    modelMap: Record<string, SDKModel>;
    csiModelMap: Record<string, SDKModel>;
    contentSourceId: string;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    assetSources: CSITypes.AssetSource[];
    createDocument: CreateDocumentThunk;
    userLogger: CSITypes.Logger;
}): Promise<CSITypes.UpdateOperationField>;
//# sourceMappingURL=create-update-csi-docs.d.ts.map