/**
 * Iterates over array items and invokes callback function for each of them.
 * The callback must return a promise and is called with three parameters: array item,
 * item index, array itself. Callbacks are invoked serially, such that callback for the
 * following item will not be called until the promise returned from the previous callback
 * is not fulfilled.
 *
 * @param {array} array
 * @param {function} callback
 * @param {object} [thisArg]
 * @return {Promise<any>}
 */
export function forEachPromise(array: any, callback: Function, thisArg?: object | undefined): Promise<any>;
export function mapPromise(array: any, callback: any, thisArg: any): Promise<any>;
export function reducePromise(array: any, callback: any, initValue: any, thisArg: any): Promise<any>;
export function findPromise(array: any, callback: any, thisArg: any): Promise<any>;
export function promiseAllMap(array: any, limit: any, interval: any, callback: any, thisArg: any): Promise<any>;
/**
 * Recursively copies files from source to target directories.
 * The optional "options" argument is an object with an optional "processNunjucksFile"
 * and "filePathMap" fields.
 *
 * If "processNunjucksFile" function is passed, it will be invoked for every file with ".njk"
 * extension with a filepath relative to the sourceDir as its single argument.
 * This function should return the result of processing Nunjucks template.
 *
 * Files named _gitignore will be copied as .gitignore
 *
 * @param {string} sourceDir
 * @param {string} targetDir
 * @param {object} [options]
 * @param {Function} options.processNunjucksFile Function that receives filePath
 *   relative to sourceDir and returns processed file data to be stored inside targetDir
 * @param {object} options.filePathMap Map between source and target file paths.
 *   If mapped value is null, the file will not be copied.
 */
export function copyFilesRecursively(sourceDir: string, targetDir: string, options?: {
    processNunjucksFile: Function;
    filePathMap: object;
} | undefined, _internalOptions: any): void;
/**
 * Copies the value at a sourcePath of the sourceObject to a targetPath of the targetObject.
 *
 * @param {Object} sourceObject
 * @param {String} sourcePath
 * @param {Object} targetObject
 * @param {String} targetPath
 * @param {Function} [transform]
 */
export function copy(sourceObject: Object, sourcePath: string, targetObject: Object, targetPath: string, transform?: Function | undefined): void;
export function copyDefault(sourceObject: any, sourcePath: any, targetObject: any, targetPath: any, transform: any): void;
export function mergeAtPath(object: any, path: any, source: any): any;
export function omitByNil(object: any): Partial<any>;
export function rename(object: any, oldPath: any, newPath: any): void;
export function append(object: any, path: any, value: any): void;
export function concat(object: any, path: any, value: any): void;
export function indent(str: any, indent: any, indentFirst?: boolean): any;
export function pascalCase(str: any): string;
export function readDirRec(dir: any, options: any): Promise<any[]>;
export function readDirRecSync(dir: any, options: any): any[];
export function readDirGlob(dir: any, options: any): Promise<any>;
export function fieldPathToString(fieldPath: any): string;
export function hrtimeAndPrint(time: any): string;
export function printHRTime(time: any): string;
/**
 * Recursively iterates over elements of a collection and invokes iteratee for each element.
 *
 * @param {*} value The value to iterate
 * @param {Function} iteratee The iteratee function
 * @param {string|number} key The key of the `value` if the `object` is an Object, or the index of the `value` if the `object` is an Array
 * @param {Object} object The parent object of `value`.
 */
export function forEachDeep(value: any, iteratee: Function, key: string | number, object: Object): void;
/**
 * Gets the value at the first path of object having non undefined value.
 * If all paths resolve to undefined values, the defaultValue is returned.
 *
 * @param {Object} object The object to query.
 * @param {Array<String | Array<String>>} paths The property paths to search for.
 * @param {*} [defaultValue] The value returned if all paths resolve to undefined values
 * @returns {*}
 */
export function getFirst(object: Object, paths: Array<string | Array<string>>, defaultValue?: any): any;
export function getFirstExistingFile(fileNames: any, inputDir: any): Promise<any>;
export function parseFirstExistingFile(fileNames: any, inputDir: any): Promise<any>;
export function getFirstExistingFileSync(fileNames: any, inputDir: any): string;
export function parseFirstExistingFileSync(fileNames: any, inputDir: any): any;
export function parseFile(filePath: any): Promise<any>;
export function parseFileSync(filePath: any): any;
export function parseDataByFilePath(string: any, filePath: any): any;
export function outputData(filePath: any, data: any): Promise<void>;
export function outputDataSync(filePath: any, data: any): void;
export function outputDataIfNeeded(filePath: any, data: any): Promise<boolean>;
export function stringifyDataByFilePath(data: any, filePath: any): any;
export function parseMarkdownWithFrontMatter(string: any): {
    frontmatter: null;
    markdown: any;
};
export function deepFreeze(obj: any): any;
export function failFunctionWithTag(tag: any): (message: any) => never;
export function assertFunctionWithFail(fail: any): (value: any, message: any) => void;
export function createLogger(scope: any, transport: any): {};
export function logObject(object: any, title: any): void;
export function joinPathAndGlob(pathStr: any, glob: any): string[];
export function globToArray(glob: any): never[];
/**
 * Inverse of _.toPath()
 *
 * fromPath(['foo', 'hello.world', 'bar'])
 * => 'foo["hello.world"].bar'
 *
 * @param {Array} pathArray
 * @return {String}
 */
export function fromPath(pathArray: any[]): string;
export function omitDeep(object: any, paths: any): any;
/**
 * Reduces the provided `data` using the provided reducer function `reducerFunc`
 * into an object with `data` and `errors` attributes.
 *
 * For every item in the provided `data, the reducer function is invoked with
 * `value` and `key` arguments. The reducer function should return an object
 * with optional `data` and `error` properties, or `null`.
 *
 * ```
 * reducerFunc(value, key) => { data, errors }
 * ```
 *
 * When reducer function returns an object with a `data` property, its value
 * is added to the `data` property of final result. If the original `data` is an
 * object, then the `data` returned by the reducer function is added under the
 * same `key` that was passed to the reducer function. If the original `data` is
 * an array, then the value is pushed to the reduced data.
 * If `data` property is missing, the reduced data will not include that item.
 *
 * When reducer function returns an object with `errors`, which can be an array
 * of error messages or a single error message, these errors are added to the
 * reduced result under `errors` property.
 *
 * @param {Array|Object} data
 * @param {Function} reducerFunc
 * @return {{data: Array|Object, errors: Array}}
 */
export function dataReducerSync(data: any[] | Object, reducerFunc: Function): {
    data: any[] | Object;
    errors: any[];
};
/**
 * Same as dataReducerSync but receives asynchronous reducerFunc
 *
 * @param {Array|Object} data
 * @param {Function} reducerFunc
 * @return {{data: Array|Object, errors: Array}}
 */
export function dataReducer(data: any[] | Object, reducerFunc: Function): {
    data: any[] | Object;
    errors: any[];
};
export function encodeJsx(data: any): any;
export function decodeJsx(data: any): any;
export function replaceInRange(str: any, range: any, stringToInsert: any): any;
export function isRelevantReactData(data: any): any;
export function convertToPosixFilePath(filePath: any): any;
//# sourceMappingURL=index.d.ts.map