"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContentSourceActionsForSourceThunk = exports.unarchiveDocumentHooked = exports.archiveDocumentHooked = exports.unpublishDocumentHooked = exports.publishDocumentHooked = exports.deleteDocumentHooked = exports.updateDocumentHooked = exports.createDocumentHooked = void 0;
const content_store_utils_1 = require("../content-store-utils");
const config_delegate_1 = require("./config-delegate");
const create_update_csi_docs_1 = require("./create-update-csi-docs");
async function createDocumentHooked(options) {
    // If no onDocumentCreate defined in the config, call the original content
    // source createDocument method with the provided actionOptions.
    if (!options.stackbitConfig?.onDocumentCreate) {
        return options.contentSourceData.instance.createDocument(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentCreate({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        createDocumentOptions: { ...options.actionOptions },
        createDocument: async (actionOptions) => {
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.createDocument({
                ...actionOptions,
                userContext: actionOptions.userContext ?? options.actionOptions.userContext,
                modelMap: options.actionOptions.modelMap
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.createDocumentHooked = createDocumentHooked;
async function updateDocumentHooked(options) {
    // If no onDocumentUpdate defined in the config, call the original content
    // source updateDocument method with the provided actionOptions.
    if (!options.stackbitConfig?.onDocumentUpdate) {
        return options.contentSourceData.instance.updateDocument(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentUpdate({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        updateDocumentOptions: { ...options.actionOptions },
        updateDocument: async (actionOptions) => {
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.updateDocument({
                ...actionOptions,
                userContext: actionOptions.userContext ?? options.actionOptions.userContext,
                modelMap: options.actionOptions.modelMap
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.updateDocumentHooked = updateDocumentHooked;
async function deleteDocumentHooked(options) {
    // If no onDocumentDelete defined in the config, call the original content
    // source deleteDocument method with the provided actionOptions.
    if (!options.stackbitConfig?.onDocumentDelete) {
        return options.contentSourceData.instance.deleteDocument(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentDelete({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        deleteDocumentOptions: { ...options.actionOptions },
        deleteDocument: async (actionOptions) => {
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.deleteDocument({
                ...actionOptions,
                userContext: actionOptions.userContext ?? options.actionOptions.userContext
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.deleteDocumentHooked = deleteDocumentHooked;
async function publishDocumentHooked(options) {
    // If no onDocumentsPublish defined in the config, call the original content
    // source publishDocuments method with the provided actionOptions.
    if (!options.stackbitConfig?.onDocumentsPublish) {
        return options.contentSourceData.instance.publishDocuments(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentsPublish({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        publishDocumentsOptions: { ...options.actionOptions },
        publishDocuments: async (actionOptions) => {
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.publishDocuments({
                ...actionOptions,
                userContext: actionOptions.userContext ?? options.actionOptions.userContext
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.publishDocumentHooked = publishDocumentHooked;
async function unpublishDocumentHooked(options) {
    // If no onDocumentsUnpublish defined in the config, call the original content
    // source publishDocuments method with the provided actionOptions.
    if (!options.stackbitConfig?.onDocumentsUnpublish) {
        return options.contentSourceData.instance.unpublishDocuments?.(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentsUnpublish({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        unpublishDocumentsOptions: { ...options.actionOptions },
        unpublishDocuments: async (actionOptions) => {
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.unpublishDocuments?.({
                ...actionOptions,
                userContext: actionOptions.userContext ?? options.actionOptions.userContext
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.unpublishDocumentHooked = unpublishDocumentHooked;
async function archiveDocumentHooked(options) {
    // If no onDocumentArchive defined in the config, call the original content
    // source archiveDocument method with the provided actionOptions.
    if (!options.stackbitConfig?.onDocumentArchive) {
        return options.contentSourceData.instance.archiveDocument?.(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentArchive({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        archiveDocumentOptions: { ...options.actionOptions },
        archiveDocument: async (actionOptions) => {
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.archiveDocument?.({
                ...actionOptions,
                userContext: actionOptions.userContext ?? options.actionOptions.userContext
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.archiveDocumentHooked = archiveDocumentHooked;
async function unarchiveDocumentHooked(options) {
    // If no onDocumentUnarchive defined in the config, call the original content
    // source unarchiveDocument method with the provided actionOptions.
    if (!options.stackbitConfig?.onDocumentUnarchive) {
        return options.contentSourceData.instance.unarchiveDocument?.(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentUnarchive({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        unarchiveDocumentOptions: { ...options.actionOptions },
        unarchiveDocument: async (actionOptions) => {
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.unarchiveDocument?.({
                ...actionOptions,
                userContext: actionOptions.userContext ?? options.actionOptions.userContext
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.unarchiveDocumentHooked = unarchiveDocumentHooked;
function getDocumentHookOptions(options) {
    const srcType = options.contentSourceData.srcType;
    const srcProjectId = options.contentSourceData.srcProjectId;
    const contentSourceDataById = options.getContentSourceDataById();
    const configDelegate = (0, config_delegate_1.createConfigDelegate)({
        contentSourceDataById,
        logger: options.logger
    });
    return {
        srcType: srcType,
        srcProjectId: srcProjectId,
        contentSourceActions: getContentSourceActionsForContentSourceData({
            contentSourceData: options.contentSourceData,
            user: options.user,
            stackbitConfig: options.stackbitConfig,
            getContentSourceDataById: options.getContentSourceDataById,
            logger: options.logger
        }),
        getContentSourceActionsForSource: getContentSourceActionsForSourceThunk({
            getContentSourceDataById: options.getContentSourceDataById,
            logger: options.logger,
            user: options.user,
            stackbitConfig: options.stackbitConfig
        }),
        getUserContextForContentSourceType: (0, content_store_utils_1.getUserContextForSrcTypeThunk)(options.user),
        ...configDelegate
    };
}
function getContentSourceActionsForSourceThunk({ getContentSourceDataById, logger, user, stackbitConfig }) {
    return (options) => {
        return getContentSourceActionsForSource({
            logger: logger,
            srcType: options.srcType,
            srcProjectId: options.srcProjectId,
            user: user,
            stackbitConfig,
            getContentSourceDataById
        });
    };
}
exports.getContentSourceActionsForSourceThunk = getContentSourceActionsForSourceThunk;
function getContentSourceActionsForSource({ srcType, srcProjectId, logger, user, stackbitConfig, getContentSourceDataById }) {
    const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
        contentSourceDataById: getContentSourceDataById(),
        srcType,
        srcProjectId
    });
    if (contentSourcesData.length === 0) {
        logger.warn(`The getContentSourceActionsForContentSource() did not find content sources for srcType: '${srcType}', srcProjectId:'${srcProjectId}'.`);
        return undefined;
    }
    else if (contentSourcesData.length > 1) {
        logger.warn(`The getContentSourceActionsForContentSource() found more than one content sources for '${srcType}'. ` +
            `Please specify 'srcType' and 'srcProjectId' to narrow down the search.`);
        return undefined;
    }
    const contentSourceData = contentSourcesData[0];
    return getContentSourceActionsForContentSourceData({
        contentSourceData,
        user,
        stackbitConfig,
        getContentSourceDataById,
        logger
    });
}
function getContentSourceActionsForContentSourceData({ contentSourceData, user, stackbitConfig, getContentSourceDataById, logger }) {
    return {
        createDocument: async (options) => {
            return createDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: options.userContext ?? (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user),
                    modelMap: contentSourceData.csiModelMap
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        },
        createDocumentFromObject: async (options) => {
            return (0, create_update_csi_docs_1.createDocumentRecursively)({
                object: options.object,
                locale: options.locale,
                modelName: options.modelName,
                contentSourceId: contentSourceData.id,
                contentSourceDataById: getContentSourceDataById(),
                assetSources: stackbitConfig?.assetSources ?? [],
                userLogger: logger,
                createDocument: (0, create_update_csi_docs_1.getCreateDocumentThunk)({
                    stackbitConfig,
                    getContentSourceDataById,
                    logger,
                    user
                })
            });
        },
        updateDocument: (options) => {
            return updateDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: options.userContext ?? (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user),
                    modelMap: contentSourceData.csiModelMap
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        },
        deleteDocument: (options) => {
            return deleteDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: options.userContext ?? (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user)
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        },
        publishDocuments: (options) => {
            return publishDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: options.userContext ?? (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user)
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        }
    };
}
//# sourceMappingURL=document-hooks.js.map