"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.internalValidateContent = exports.validateUpdateOperations = exports.validateUpdateOperationFields = exports.ContentValidationError = void 0;
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("@stackbit/types");
const field_path_utils_1 = require("./field-path-utils");
class ContentValidationError extends Error {
    constructor({ message, validation, fieldPath, value, relatedDocumentId }) {
        super(message);
        this.name = 'ContentValidationError';
        this.validation = validation;
        this.fieldPath = fieldPath;
        this.value = value;
        this.relatedDocumentId = relatedDocumentId;
        // redefine "message" as enumerable, this helps to compare the received and the expected error.message in Jest's toMatchObject() tests
        Object.defineProperty(this, 'message', { value: message, writable: true, enumerable: true, configurable: true });
    }
}
exports.ContentValidationError = ContentValidationError;
async function validateUpdateOperationFields({ updateOperationFields, modelName, locale, contentSourceData, configDelegate }) {
    const model = contentSourceData.modelMap[modelName];
    const csiModel = contentSourceData.csiModelMap[modelName];
    if (!model || !csiModel) {
        throw new Error(`Model '${modelName}' not found.`);
    }
    for (const [fieldName, updateOperationField] of Object.entries(updateOperationFields)) {
        const modelField = (model.fields ?? []).find((field) => field.name === fieldName);
        if (!modelField) {
            throw new ContentValidationError({
                message: `Model field '${fieldName}' of model '${csiModel.name}' not found.`
            });
        }
        // early return if this field has no validations
        if (lodash_1.default.isEmpty(modelField.validations)) {
            continue;
        }
        const updateOperation = {
            opType: 'set',
            fieldPath: [fieldName],
            locale,
            modelField,
            field: updateOperationField
        };
        validateUniqueness({
            updateOperation,
            modelName,
            contentSourceData
        });
        await customValidation({
            updateOperation,
            contentSourceData,
            csiModel,
            configDelegate
        });
    }
}
exports.validateUpdateOperationFields = validateUpdateOperationFields;
async function validateUpdateOperations({ updateOperations, csiDocument, contentSourceData, configDelegate }) {
    const modelName = csiDocument.modelName;
    const model = contentSourceData.modelMap[modelName];
    const csiModel = contentSourceData.csiModelMap[modelName];
    if (!model || !csiModel) {
        throw new Error(`Model '${modelName}' for document '${csiDocument.id}' not found.`);
    }
    const storeDocument = contentSourceData.documentMap[csiDocument.id];
    for (let updateOperation of updateOperations) {
        let modelField;
        try {
            modelField = (0, field_path_utils_1.getModelFieldAtFieldPath)({
                document: storeDocument,
                fieldPath: updateOperation.fieldPath,
                locale: updateOperation.locale,
                modelMap: contentSourceData.modelMap
            });
        }
        catch (error) {
            const fieldPathStr = updateOperation.fieldPath.join('.');
            throw new ContentValidationError({
                message: `Cannot find model field of model '${modelName}' at field path '${fieldPathStr}'.`
            });
        }
        // early return if this field has no validations
        if (lodash_1.default.isEmpty(modelField.validations)) {
            continue;
        }
        // Replace the modelField from the content-store models.
        // This modelField is extended with properties from modelExtensions
        updateOperation = {
            ...updateOperation,
            modelField
        };
        validateUniqueness({
            updateOperation,
            modelName,
            storeDocument,
            contentSourceData
        });
        await customValidation({
            updateOperation,
            contentSourceData,
            csiDocument,
            csiModel,
            configDelegate
        });
    }
}
exports.validateUpdateOperations = validateUpdateOperations;
function validateUniqueness({ updateOperation, modelName, storeDocument, contentSourceData }) {
    const fieldPath = updateOperation.fieldPath;
    const locale = updateOperation.locale;
    const modelField = updateOperation.modelField;
    const validations = modelField.validations;
    if (lodash_1.default.isEmpty(validations)) {
        return;
    }
    if (!('unique' in validations) || !validations.unique) {
        return;
    }
    if (!fieldTypeSupportsUniqueValidation(modelField.type)) {
        return;
    }
    if (modelField.type === 'list' && fieldTypeSupportsUniqueValidation(modelField.items.type)) {
        // If a field is of type list, then check that all items in list are unique
        if (updateOperation.opType === 'set' && updateOperation.field.type === 'list') {
            // If setting a new list, check that all its values unique
            if (lodash_1.default.uniq(updateOperation.field.items).length !== updateOperation.field.items.length) {
                throw new ContentValidationError({
                    message: validations.errors?.unique ?? `The list must have unique items`
                });
            }
        }
        else if (updateOperation.opType === 'insert' && 'value' in updateOperation.item && storeDocument) {
            // If inserting a new item into the list, check that there is no existing item with the same value.
            const insertedValue = updateOperation.item.value;
            const listField = (0, field_path_utils_1.getDocumentFieldAtFieldPath)({
                document: storeDocument,
                fieldPath,
                locale,
                returnUndefined: true
            });
            if (listField && listField.type === 'list') {
                for (const item of listField.items) {
                    if ('value' in item && item.value === insertedValue) {
                        throw new ContentValidationError({
                            message: validations.errors?.unique ?? `The list must have unique items`
                        });
                    }
                }
            }
        }
    }
    else if (updateOperation.opType === 'set') {
        // If a field is of type string, slug, url, number, enum,
        // then check that the value is unique across all documents of the same type.
        contentSourceData.documents.forEach((doc) => {
            if (doc.srcModelName !== modelName || (storeDocument && doc.srcObjectId === storeDocument.srcObjectId)) {
                return false;
            }
            const docField = (0, field_path_utils_1.getDocumentFieldAtFieldPath)({
                document: doc,
                fieldPath,
                locale,
                returnUndefined: true
            });
            if (docField && 'value' in docField && 'value' in updateOperation.field && docField.value === updateOperation.field.value) {
                throw new ContentValidationError({
                    validation: 'unique',
                    value: updateOperation.field.value,
                    fieldPath,
                    message: validations.errors?.unique ?? `The field '${fieldPath[fieldPath.length - 1]}' must be unique, another document has the same value`,
                    relatedDocumentId: doc.srcObjectId
                });
            }
        });
    }
}
async function customValidation({ updateOperation, csiDocument, csiModel, contentSourceData, configDelegate }) {
    const modelField = updateOperation.modelField;
    const validations = modelField.validations;
    if (lodash_1.default.isEmpty(validations)) {
        return;
    }
    // Check custom validate function
    if ('validate' in validations && validations.validate) {
        const customValidations = !Array.isArray(validations.validate) ? [validations.validate] : validations.validate;
        for (const customValidation of customValidations) {
            const validationResult = await customValidation({
                updateOperation: updateOperation,
                document: csiDocument
                    ? {
                        srcType: contentSourceData.srcType,
                        srcProjectId: contentSourceData.srcProjectId,
                        ...csiDocument
                    }
                    : undefined,
                model: {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiModel
                },
                ...configDelegate
            });
            if (typeof validationResult === 'string') {
                throw new ContentValidationError({
                    message: validationResult
                });
            }
        }
    }
}
function fieldTypeSupportsUniqueValidation(fieldType) {
    const fieldsWithUniqueValidation = ['string', 'slug', 'url', 'number', 'enum', 'list'];
    return lodash_1.default.includes(fieldsWithUniqueValidation, fieldType);
}
function fieldTypeSupportsRegexpValidation(fieldType) {
    const fieldsWithUniqueValidation = ['string', 'slug', 'url', 'text', 'markdown', 'html'];
    return lodash_1.default.includes(fieldsWithUniqueValidation, fieldType);
}
function internalValidateContent(documents, assets, contentSourceData, locale) {
    const errors = [];
    lodash_1.default.forEach(documents, (document) => {
        lodash_1.default.forEach(document.fields, (documentField, fieldName) => {
            const localizedField = (0, types_1.getLocalizedFieldForLocale)(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, [fieldName], contentSourceData, locale));
            }
        });
    });
    return errors;
}
exports.internalValidateContent = internalValidateContent;
function validateDocumentFields(document, documentField, fieldPath, contentSourceData, locale) {
    const errors = [];
    if (documentField.type === 'object') {
        lodash_1.default.forEach(documentField.fields, (documentField, fieldName) => {
            const localizedField = (0, types_1.getLocalizedFieldForLocale)(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, fieldPath.concat(fieldName), contentSourceData, locale));
            }
        });
    }
    else if (documentField.type === 'model') {
        lodash_1.default.forEach(documentField.fields, (documentField, fieldName) => {
            const localizedField = (0, types_1.getLocalizedFieldForLocale)(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, fieldPath.concat(fieldName), contentSourceData, locale));
            }
        });
    }
    else if (documentField.type === 'reference') {
        const objRef = documentField.refType === 'asset' ? contentSourceData.assetMap[documentField.refId] : contentSourceData.documentMap[documentField.refId];
        if (!objRef) {
            errors.push({
                fieldPath,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectType: documentField.refType,
                srcObjectId: document.id,
                message: `Can't find referenced ${documentField.refType}: ${documentField.refId}`
            });
        }
    }
    else if (documentField.type === 'list') {
        lodash_1.default.forEach(documentField.items, (documentField, i) => {
            errors.push(...validateDocumentFields(document, documentField, fieldPath.concat(i), contentSourceData, locale));
        });
    }
    return errors;
}
//# sourceMappingURL=document-validations.js.map