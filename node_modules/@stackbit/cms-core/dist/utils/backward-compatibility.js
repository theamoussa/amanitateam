"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDocument = exports.createDocument = exports.getDocuments = exports.hasAccess = exports.getSchema = exports.startWatchingContentUpdates = exports.onFilesChange = exports.destroy = exports.getVersion = exports.backwardCompatibleContentSource = void 0;
function backwardCompatibleContentSource(contentSource) {
    return new Proxy(contentSource, {
        get(target, prop) {
            switch (prop) {
                case 'getVersion':
                    return getVersion.bind(undefined, target);
                case 'destroy':
                    return destroy.bind(undefined, target);
                case 'onFilesChange':
                    return onFilesChange.bind(undefined, target);
                case 'startWatchingContentUpdates':
                    return startWatchingContentUpdates.bind(undefined, target);
                case 'getSchema':
                    return getSchema.bind(undefined, target);
                case 'hasAccess':
                    return hasAccess.bind(undefined, target);
                case 'getDocuments':
                    return getDocuments.bind(undefined, target);
                case 'createDocument':
                    return createDocument.bind(undefined, target);
                case 'updateDocument':
                    return updateDocument.bind(undefined, target);
                default:
                    return target[prop];
            }
        }
    });
}
exports.backwardCompatibleContentSource = backwardCompatibleContentSource;
async function getVersion(contentSource) {
    if ('getVersion' in contentSource) {
        return contentSource.getVersion();
    }
    return {
        interfaceVersion: '0.1.0',
        contentSourceVersion: ''
    };
}
exports.getVersion = getVersion;
async function destroy(contentSource) {
    if ('destroy' in contentSource) {
        return contentSource.destroy();
    }
}
exports.destroy = destroy;
/**
 * Converts the old onFilesChange API to the new one
 * OLD: onFilesChange?(options: { updatedFiles: string[]; }):
 *        Promise<{ schemaChanged?: boolean; contentChangeEvent?: ContentChangeEvent<DocumentContext, AssetContext> }>
 * NEW: onFilesChange?(options: { updatedFiles: string[]; }):
 *        Promise<{ invalidateSchema?: boolean; contentChanges?: ContentChanges<DocumentContext, AssetContext> }>
 */
async function onFilesChange(contentSource, options) {
    const value = await contentSource.onFilesChange?.(options);
    if (!value) {
        return {};
    }
    // if there are properties from the new API return the value as is
    if ('invalidateSchema' in value || 'contentChanges' in value) {
        return value;
    }
    // if there are properties from the old API return convert to the new API value
    const result = {};
    if ('schemaChanged' in value) {
        result.invalidateSchema = value.schemaChanged;
    }
    if ('contentChangeEvent' in value) {
        result.contentChanges = value.contentChangeEvent;
    }
    return result;
}
exports.onFilesChange = onFilesChange;
/**
 * Converts between the old startWatchingContentUpdates API and the new one.
 * OLD: startWatchingContentUpdates(options: startWatchingContentUpdatesOptionsOld): void;
 * NEW: startWatchingContentUpdates?(): void;
 */
function startWatchingContentUpdates(contentSource, options) {
    contentSource.startWatchingContentUpdates?.(options);
}
exports.startWatchingContentUpdates = startWatchingContentUpdates;
/**
 * Converts the old getModels() and getLocales() API methods to the new getSchema() API method.
 * OLD:
 *   getModels(): Promise<Model[]>;
 *   getLocales(): Promise<Locale[]>
 * NEW:
 *   getSchema(): Promise<Schema<SchemaContext>>
 */
async function getSchema(contentSource) {
    if ('getSchema' in contentSource) {
        return contentSource.getSchema();
    }
    const models = await contentSource.getModels();
    const locales = await contentSource.getLocales();
    return { models, locales, context: null };
}
exports.getSchema = getSchema;
/**
 * Converts the old hasAccess API to the new one
 * OLD: hasAccess(options: { userContext?: CSITypes.User }): Promise<boolean>
 * NEW: hasAccess(options: { userContext?: CSITypes.User }): Promise<{ hasConnection: boolean; hasPermissions: boolean }>
 */
async function hasAccess(contentSource, options) {
    const result = await contentSource.hasAccess(options);
    if (typeof result === 'boolean') {
        return {
            hasConnection: result,
            hasPermissions: result
        };
    }
    return result;
}
exports.hasAccess = hasAccess;
/**
 * Converts the old getDocuments API to the new one
 * OLD: getDocuments(options: { modelMap: ModelMap }): Promise<Document[]>
 * NEW: getDocuments(): Promise<Document[]>
 */
async function getDocuments(contentSource, options) {
    return contentSource.getDocuments(options);
}
exports.getDocuments = getDocuments;
/**
 * Converts the old createDocument API to the new one
 * OLD: createDocument(options: Options & { modelMap: ModelMap }): Promise<Document<DocumentContext>>
 * NEW: createDocument(options: Options): Promise<{ documentId: string }>
 */
async function createDocument(contentSource, options) {
    const result = await contentSource.createDocument(options);
    if ('id' in result) {
        return { documentId: result.id };
    }
    return result;
}
exports.createDocument = createDocument;
/**
 * Converts the old updateDocument API to the new one
 * OLD: updateDocument(options: Options & { modelMap: ModelMap }): Promise<CSITypes.Document>;
 * NEW: updateDocument(options: Options): Promise<void>
 */
async function updateDocument(contentSource, options) {
    await contentSource.updateDocument(options);
}
exports.updateDocument = updateDocument;
//# sourceMappingURL=backward-compatibility.js.map