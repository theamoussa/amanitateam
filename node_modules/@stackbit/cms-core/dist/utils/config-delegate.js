"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConfigDelegate = exports.getCreateConfigDelegateThunk = void 0;
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("@stackbit/types");
const content_store_utils_1 = require("../content-store-utils");
const store_to_csi_docs_converter_1 = require("./store-to-csi-docs-converter");
function getCreateConfigDelegateThunk({ getContentSourceDataById, logger }) {
    return () => createConfigDelegate({
        contentSourceDataById: getContentSourceDataById(),
        logger: logger
    });
}
exports.getCreateConfigDelegateThunk = getCreateConfigDelegateThunk;
function createConfigDelegate({ contentSourceDataById, logger }) {
    return {
        getLogger: () => logger,
        getDocumentById: ({ id, srcType, srcProjectId }) => {
            const document = findDocumentByIdAndSourceTypeOrId({
                contentSourceDataById,
                documentId: id,
                srcType,
                srcProjectId,
                logger
            });
            if (document) {
                const contentSourceId = (0, content_store_utils_1.getContentSourceId)(document.srcType, document.srcProjectId);
                const csiDocument = contentSourceDataById[contentSourceId].csiDocumentMap[document.srcObjectId];
                if (!csiDocument) {
                    return undefined;
                }
                return (0, store_to_csi_docs_converter_1.mapStoreDocumentToCSIDocumentWithSource)({
                    document,
                    csiDocument
                });
            }
            return undefined;
        },
        getDocuments: ({ srcType, srcProjectId } = {}) => {
            const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
                contentSourceDataById,
                srcType,
                srcProjectId
            });
            return contentSourcesData.reduce((matchingDocuments, contentSourceData) => {
                return matchingDocuments.concat((0, store_to_csi_docs_converter_1.mapStoreDocumentsToCSIDocumentsWithSource)({
                    documents: contentSourceData.documents,
                    csiDocumentMap: contentSourceData.csiDocumentMap
                }));
            }, []);
        },
        getModelByName: ({ modelName, srcType, srcProjectId }) => {
            return findModelByNameAndSourceTypeOrId({
                contentSourceDataById,
                modelName,
                srcType,
                srcProjectId,
                logger
            });
        },
        getSchemas: ({ srcType, srcProjectId } = {}) => {
            const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
                contentSourceDataById,
                srcType,
                srcProjectId
            });
            return contentSourcesData.reduce((schemas, contentSourceData) => {
                return schemas.concat({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    models: contentSourceData.models.map((model) => ({
                        ...model,
                        srcType: contentSourceData.srcType,
                        srcProjectId: contentSourceData.srcProjectId
                    })),
                    locales: contentSourceData.csiSchema.locales,
                    context: contentSourceData.csiSchema.context
                });
            }, []);
        },
        getDefaultLocaleBySource: ({ srcType, srcProjectId }) => {
            // if srcType and srcProjectId are provided, use them to get the specific contentSourceData without trying to infer the right model
            if (srcType && srcProjectId) {
                const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
                return contentSourceDataById[contentSourceId]?.defaultLocaleCode;
            }
            const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
                contentSourceDataById,
                srcType,
                srcProjectId
            });
            if (contentSourcesData.length === 1) {
                return contentSourcesData[0].defaultLocaleCode;
            }
            else if (contentSourcesData.length > 1) {
                logger.warn(`The getDefaultLocaleBySource() found more than one content sources for '${srcType}'. ` +
                    `Please specify 'srcType' and 'srcProjectId' to narrow down the search.`);
            }
            return undefined;
        },
        getDocumentFieldForFieldPath: ({ document, fromField, fieldPath, locale }) => {
            const fieldPathArr = lodash_1.default.toPath(fieldPath);
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(document.srcType, document.srcProjectId);
            const contentSource = contentSourceDataById[contentSourceId];
            if (!contentSource) {
                return undefined;
            }
            function getNestedFieldFromFieldsForPath(fields, fieldPathArr, currentContentSource) {
                const fieldName = fieldPathArr[0];
                fieldPathArr = fieldPathArr.slice(1);
                if (!fieldName) {
                    return undefined;
                }
                const field = fields[fieldName];
                if (!field) {
                    return undefined;
                }
                const resolvedLocale = locale ?? currentContentSource.defaultLocaleCode;
                const nonLocalizedField = (0, types_1.getLocalizedFieldForLocale)(field, resolvedLocale);
                if (!nonLocalizedField) {
                    return undefined;
                }
                if (fieldPathArr.length === 0) {
                    return nonLocalizedField;
                }
                return getNestedFieldFromLocalizedFieldForPath(nonLocalizedField, fieldPathArr, currentContentSource);
            }
            function getNestedFieldFromLocalizedFieldForPath(nonLocalizedField, fieldPathArr, currentContentSource) {
                if (nonLocalizedField.type === 'object' || nonLocalizedField.type === 'model') {
                    return getNestedFieldFromFieldsForPath(nonLocalizedField.fields, fieldPathArr, currentContentSource);
                }
                else if (nonLocalizedField.type === 'reference') {
                    const refDocument = currentContentSource.documentMap[nonLocalizedField.refId];
                    const refCSIDocument = currentContentSource.csiDocumentMap[nonLocalizedField.refId];
                    if (!refDocument || !refCSIDocument) {
                        return undefined;
                    }
                    const fields = (0, store_to_csi_docs_converter_1.mapStoreDocumentToCSIDocumentWithSource)({
                        document: refDocument,
                        csiDocument: refCSIDocument
                    }).fields;
                    return getNestedFieldFromFieldsForPath(fields, fieldPathArr, currentContentSource);
                }
                else if (nonLocalizedField.type === 'cross-reference') {
                    const contentSourceId = (0, content_store_utils_1.getContentSourceId)(nonLocalizedField.refSrcType, nonLocalizedField.refProjectId);
                    const contentSource = contentSourceDataById[contentSourceId];
                    if (!contentSource) {
                        return undefined;
                    }
                    const refDocument = contentSource.documentMap[nonLocalizedField.refId];
                    const refCSIDocument = contentSource.csiDocumentMap[nonLocalizedField.refId];
                    if (!refDocument || !refCSIDocument) {
                        return undefined;
                    }
                    const fields = (0, store_to_csi_docs_converter_1.mapStoreDocumentToCSIDocumentWithSource)({
                        document: refDocument,
                        csiDocument: refCSIDocument
                    }).fields;
                    return getNestedFieldFromFieldsForPath(fields, fieldPathArr, contentSource);
                }
                else if (nonLocalizedField.type === 'list') {
                    const index = lodash_1.default.toNumber(fieldPathArr[0]);
                    fieldPathArr = fieldPathArr.slice(1);
                    if (lodash_1.default.isNaN(index)) {
                        return undefined;
                    }
                    const localizedItem = nonLocalizedField.items[index];
                    if (!localizedItem) {
                        return undefined;
                    }
                    if (fieldPathArr.length === 0) {
                        return localizedItem;
                    }
                    return getNestedFieldFromLocalizedFieldForPath(localizedItem, fieldPathArr, currentContentSource);
                }
                return undefined;
            }
            if (fromField) {
                const resolvedLocale = locale ?? contentSource.defaultLocaleCode;
                const nonLocalizedField = (0, types_1.getLocalizedFieldForLocale)(fromField, resolvedLocale);
                if (!nonLocalizedField) {
                    return undefined;
                }
                return getNestedFieldFromLocalizedFieldForPath(nonLocalizedField, fieldPathArr, contentSource);
            }
            else {
                return getNestedFieldFromFieldsForPath(document.fields, fieldPathArr, contentSource);
            }
        }
    };
}
exports.createConfigDelegate = createConfigDelegate;
function findDocumentByIdAndSourceTypeOrId({ contentSourceDataById, documentId, srcType, srcProjectId, logger }) {
    // if srcType and srcProjectId are provided, use them to get the specific contentSourceData without trying to infer the right document
    if (srcType && srcProjectId) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        return contentSourceDataById[contentSourceId]?.documentMap[documentId];
    }
    const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
        contentSourceDataById,
        srcType,
        srcProjectId
    });
    const matchingDocuments = contentSourcesData.reduce((matchingDocuments, contentSourceData) => {
        const document = contentSourceData.documentMap[documentId];
        if (document) {
            matchingDocuments.push(document);
        }
        return matchingDocuments;
    }, []);
    if (matchingDocuments.length === 1) {
        return matchingDocuments[0];
    }
    else if (matchingDocuments.length > 1) {
        const matchedContentSources = matchingDocuments.map((document) => `srcType: ${document.srcType}, srcProjectId: ${document.srcProjectId}`).join('; ');
        logger.warn(`The getDocumentById() found more than one documents with ID '${documentId}' ` +
            `in the following content sources ${matchedContentSources}. ` +
            `Please specify 'srcType' and/or 'srcProjectId' to narrow down the search.`);
    }
    return;
}
function findModelByNameAndSourceTypeOrId({ contentSourceDataById, modelName, srcType, srcProjectId, logger }) {
    // if srcType and srcProjectId are provided, use them to get the specific contentSourceData without trying to infer the right model
    if (srcType && srcProjectId) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = contentSourceDataById[contentSourceId];
        const model = contentSourceData?.modelMap[modelName];
        if (model) {
            return {
                ...model,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId
            };
        }
        return undefined;
    }
    const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
        contentSourceDataById,
        srcType,
        srcProjectId
    });
    const matchingModels = contentSourcesData.reduce((matchingModels, contentSourceData) => {
        const model = contentSourceData.modelMap[modelName];
        if (model) {
            matchingModels.push({
                ...model,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId
            });
        }
        return matchingModels;
    }, []);
    if (matchingModels.length === 1) {
        return matchingModels[0];
    }
    else if (matchingModels.length > 1) {
        const matchedContentSources = matchingModels.map((model) => `srcType: ${model.srcType}, srcProjectId: ${model.srcProjectId}`).join('; ');
        logger.warn(`The getModelByName() found more than one model with name '${modelName}' ` +
            `in the following content sources ${matchedContentSources}. ` +
            `Please specify 'srcType' and/or 'srcProjectId' to narrow down the search.`);
    }
    return;
}
//# sourceMappingURL=config-delegate.js.map