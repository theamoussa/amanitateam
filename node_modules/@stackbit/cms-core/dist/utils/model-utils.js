"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModelMap = exports.validateModels = exports.normalizeModels = void 0;
const lodash_1 = __importDefault(require("lodash"));
const sdk_1 = require("@stackbit/sdk");
const utils_1 = require("@stackbit/utils");
function normalizeModels({ models, logger }) {
    return models.map((model) => {
        model = { ...model };
        if (!('name' in model)) {
            logger.warn('model does not have a name');
        }
        if (!('type' in model)) {
            logger.warn(`model '${model['name']}' does not have a type, using 'object'`);
            lodash_1.default.set(model, 'type', 'object');
        }
        // add model label if not set
        if (!('label' in model)) {
            model.label = lodash_1.default.startCase(model.name);
        }
        if (!('fields' in model) || !Array.isArray(model.fields)) {
            model.fields = [];
        }
        if ((0, sdk_1.isPageModel)(model)) {
            // set default urlPath if not set
            if (!model.urlPath) {
                model.urlPath = '/{slug}';
            }
        }
        (0, sdk_1.assignLabelFieldIfNeeded)(model);
        // Ensure that actions always have types and labels
        if ((model.type === 'data' || model.type === 'page') && model.actions) {
            model.actions = model.actions.map((action) => ({
                ...action,
                type: action.type ?? 'document',
                label: action.label ?? lodash_1.default.startCase(action.name)
            }));
        }
        else if (model.type === 'object' && model.actions) {
            model.actions = model.actions.map((action) => ({
                ...action,
                type: action.type ?? 'object',
                label: action.label ?? lodash_1.default.startCase(action.name)
            }));
        }
        model = (0, sdk_1.mapModelFieldsRecursively)(model, (field) => {
            field = { ...field };
            if (!('label' in field)) {
                field.label = lodash_1.default.startCase(field.name);
            }
            if (field.actions) {
                field.actions = field.actions.map((action) => ({
                    ...action,
                    type: action.type ?? 'field',
                    label: action.label ?? lodash_1.default.startCase(action.name)
                }));
            }
            (0, sdk_1.mapListItemsPropsOrSelfSpecificProps)(field, (listItemsPropsOrField) => {
                backwardCompatibleValidations(listItemsPropsOrField);
                extendRegExpValidationsFromPatterns(listItemsPropsOrField);
                extendFileTypeValidationsFromGroups(listItemsPropsOrField);
                if ((0, sdk_1.isObjectField)(listItemsPropsOrField)) {
                    (0, sdk_1.assignLabelFieldIfNeeded)(listItemsPropsOrField);
                }
                else if ((0, sdk_1.isCrossReferenceField)(listItemsPropsOrField)) {
                    listItemsPropsOrField.models = validateAndNormalizeCrossReferenceModels({
                        crossReferenceModels: listItemsPropsOrField.models,
                        models,
                        logger
                    });
                }
                return listItemsPropsOrField;
            });
            return field;
        });
        return model;
    });
}
exports.normalizeModels = normalizeModels;
function backwardCompatibleValidations(listItemsPropsOrField) {
    if (listItemsPropsOrField.type === 'number') {
        const validations = listItemsPropsOrField.validations;
        const min = validations?.min ?? listItemsPropsOrField.min;
        const max = validations?.max ?? listItemsPropsOrField.max;
        const step = validations?.step ?? listItemsPropsOrField.step;
        if (!lodash_1.default.isNil(min) || !lodash_1.default.isNil(max) || !lodash_1.default.isNil(step)) {
            if (!lodash_1.default.isNil(min)) {
                listItemsPropsOrField.min = min;
            }
            if (!lodash_1.default.isNil(max)) {
                listItemsPropsOrField.max = max;
            }
            if (!lodash_1.default.isNil(step)) {
                listItemsPropsOrField.step = step;
            }
            listItemsPropsOrField.validations = {
                ...listItemsPropsOrField.validations,
                ...(0, utils_1.undefinedIfEmpty)((0, utils_1.omitByNil)({ min, max, step }))
            };
        }
    }
}
const RegExpPatternMap = {
    email: { value: '^\\w[\\w.%+-]*@([\\w-]+\\.)+[\\w-]+$', message: 'The value must be an E-mail' },
    url: { value: '^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-/]))?$', message: 'The value must be a URL' },
    'date-eu': { value: '^(0?[1-9]|[12][0-9]|3[01])[- /.](0?[1-9]|1[012])[- /.](19|20)?\\d\\d$', message: 'The value must be a European Date' },
    'date-us': { value: '^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?\\d\\d$', message: 'The value must be a US Date' },
    'phone-us': { value: '^\\d[ -.]?\\(?\\d\\d\\d\\)?[ -.]?\\d\\d\\d[ -.]?\\d\\d\\d\\d$', message: 'The value must be a US Phone number' },
    'zip-code-us': { value: '^\\d{5}$|^\\d{5}-\\d{4}$', message: 'The value must be a US zip code' },
    'time-12h': { value: '^(0?[1-9]|1[012]):[0-5][0-9](:[0-5][0-9])?\\s*[aApP][mM]$', message: 'The value must be a 12h Time' },
    'time-24h': { value: '^(0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$', message: 'The value must be a 24h Time' }
};
const RegExpNotPatternMap = {
    lowercase: { value: '[A-Z]', message: 'All characters must be uppercase.' },
    uppercase: { value: '[a-z]', message: 'All characters must be lowercase.' }
};
function extendRegExpValidationsFromPatterns(listItemsPropsOrField) {
    if (listItemsPropsOrField.validations && 'regexpPattern' in listItemsPropsOrField.validations && listItemsPropsOrField.validations.regexpPattern) {
        const { regexpPattern, ...restValidations } = listItemsPropsOrField.validations;
        if (regexpPattern in RegExpPatternMap) {
            const regexp = RegExpPatternMap[regexpPattern];
            listItemsPropsOrField.validations = {
                ...restValidations,
                regexp: regexp.value,
                errors: {
                    regexp: listItemsPropsOrField.validations.errors?.regexpPattern ?? regexp.message
                }
            };
        }
        else if (regexpPattern in RegExpNotPatternMap) {
            const regexpNot = RegExpNotPatternMap[regexpPattern];
            listItemsPropsOrField.validations = {
                ...restValidations,
                regexpNot: regexpNot.value,
                errors: {
                    regexpNot: listItemsPropsOrField.validations.errors?.regexpPattern ?? regexpNot.message
                }
            };
        }
    }
}
function extendFileTypeValidationsFromGroups(listItemsPropsOrField) {
    if (listItemsPropsOrField.validations &&
        'fileTypeGroups' in listItemsPropsOrField.validations &&
        Array.isArray(listItemsPropsOrField.validations.fileTypeGroups)) {
        const { fileTypeGroups, ...restValidations } = listItemsPropsOrField.validations;
        const existingFileTypes = 'fileTypes' in restValidations ? restValidations.fileTypes : undefined;
        const fileTypesArr = Array.isArray(existingFileTypes) ? { value: existingFileTypes } : existingFileTypes;
        const groupedFileTypes = mapFileTypeGroupToFileType(fileTypeGroups);
        if (groupedFileTypes.length > 0) {
            const mergedFileTypes = [...(fileTypesArr?.value ?? []), ...groupedFileTypes];
            const message = `The file must be of the following types: ${mergedFileTypes.join(', ')}`;
            listItemsPropsOrField.validations = {
                ...restValidations,
                fileTypes: mergedFileTypes,
                errors: {
                    fileTypes: listItemsPropsOrField.validations.errors?.fileTypeGroups ?? message
                }
            };
        }
    }
}
const FileTypeGroupMap = {
    image: ['gif', 'jpg', 'jpeg', 'png', 'svg', 'webp', 'bmp', 'ico', 'tif', 'tiff', 'ps', 'eps'],
    video: ['flv', 'avi', '3gp', '3g2', 'h264', 'm4v', 'mkv', 'mov', 'mp4', 'mpg', 'mpeg', 'amv', 'rm', 'swf', 'vob', 'webm', 'wmv'],
    audio: ['aif', 'mid', 'midi', 'mp3', 'mpa', 'ogg', 'aac', 'wav', 'wma', 'wpl'],
    text: ['txt', 'log'],
    markup: ['md', 'mdx'],
    code: ['json', 'js', 'ts', 'html', 'htm', 'xhtml', 'css', 'xml', 'py', 'c', 'h', 'cpp', 'swift', 'java', 'class', 'php', 'sh', 'vb'],
    document: ['txt', 'doc', 'docx', 'odt', 'pdf', 'csv', 'rtf', 'tex', 'wpd'],
    presentation: ['key', 'odp', 'pps', 'ppt', 'pptx'],
    spreadsheet: ['ods', 'xls', 'xlsm', 'xlsx'],
    archive: ['7z', 'arj', 'deb', 'pkg', 'rar', 'rpm', 'tar', 'tar.gz', 'z', 'zip']
};
function mapFileTypeGroupToFileType(fileTypeGroups) {
    return lodash_1.default.uniq(fileTypeGroups.reduce((accum, group) => {
        if (group in FileTypeGroupMap) {
            accum = accum.concat(FileTypeGroupMap[group]);
        }
        return accum;
    }, []));
}
function validateAndNormalizeCrossReferenceModels({ crossReferenceModels, models, logger }) {
    const modelGroupsByModelName = models.reduce((modelGroups, model) => {
        if (!(model.name in modelGroups)) {
            modelGroups[model.name] = [];
        }
        modelGroups[model.name].push(model);
        return modelGroups;
    }, {});
    // Match cross-reference models to the group of content source models with
    // the same name. Then, match the cross-reference model to content source
    // model by comparing srcType and srcProjectId. If after the comparison,
    // there are more than one model left, log a warning and filter out that
    // cross-reference model so it won't cause any model ambiguity.
    const nonMatchedCrossReferenceModels = [];
    const normalizedCrossReferenceModels = crossReferenceModels.reduce((matchedCrossReferenceModels, crossReferenceModel) => {
        const models = modelGroupsByModelName[crossReferenceModel.modelName];
        if (!models) {
            nonMatchedCrossReferenceModels.push({ crossReferenceModel, matchedModels: [] });
            return matchedCrossReferenceModels;
        }
        const matchedModels = models.filter((model) => {
            const matchesType = !crossReferenceModel.srcType || model.srcType === crossReferenceModel.srcType;
            const matchesId = !crossReferenceModel.srcProjectId || model.srcProjectId === crossReferenceModel.srcProjectId;
            return matchesType && matchesId;
        });
        if (matchedModels.length !== 1) {
            nonMatchedCrossReferenceModels.push({ crossReferenceModel, matchedModels });
            return matchedCrossReferenceModels;
        }
        const matchedModel = matchedModels[0];
        matchedCrossReferenceModels.push({
            modelName: crossReferenceModel.modelName,
            srcType: matchedModel.srcType,
            srcProjectId: matchedModel.srcProjectId
        });
        return matchedCrossReferenceModels;
    }, []);
    // Log model matching warnings using user logger
    for (const { crossReferenceModel, matchedModels } of nonMatchedCrossReferenceModels) {
        let message = `a model of cross-reference field: '${crossReferenceModel.modelName}'`;
        if (crossReferenceModel.srcType) {
            message += `, srcType: '${crossReferenceModel.srcType}'`;
        }
        if (crossReferenceModel.srcProjectId) {
            message += `, srcProjectId: '${crossReferenceModel.srcProjectId}'`;
        }
        message = message + ` defined in stackbit config`;
        let contentSourceModelsMessage;
        if (matchedModels.length) {
            const matchesModelsMessage = matchedModels.map((model) => `srcType: '${model.srcType}', srcProjectId: '${model.srcProjectId}'`).join('; ');
            contentSourceModelsMessage = ` matches more that 1 model in the following content sources: ${matchesModelsMessage}`;
        }
        else {
            contentSourceModelsMessage = ' does not match any content source model';
        }
        logger.warn(message + contentSourceModelsMessage);
    }
    return normalizedCrossReferenceModels;
}
function validateModels({ models, logger }) {
    const { config, errors } = (0, sdk_1.validateConfig)({
        stackbitVersion: '0.5.0',
        models: models,
        dirPath: '.',
        filePath: 'stackbit.config.js'
    });
    for (const error of errors) {
        logger.warn(error.message);
    }
    return config.models;
}
exports.validateModels = validateModels;
function getModelMap({ models }) {
    return models.reduce((res, model) => {
        res[model.name] = model;
        return res;
    }, {});
}
exports.getModelMap = getModelMap;
//# sourceMappingURL=model-utils.js.map