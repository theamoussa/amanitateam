import * as CSITypes from '@stackbit/types';
/**
 * AnyContentSourceInterface is the union of the previous ContentSourceInterface
 * versions.
 *
 * When changing the ContentSourceInterface in a way that it may break previous
 * content source modules, create a new type by omitting the changed methods and
 * redefine them with their new signatures. Then add the new type to the union.
 */
export type AnyContentSourceInterface = ContentSourceInterface_v0_1_0 | ContentSourceInterface_v0_2_0;
export type ContentSourceInterface_v0_2_0 = CSITypes.ContentSourceInterface;
export type ContentSourceInterface_v0_1_0 = Omit<CSITypes.ContentSourceInterface, 'getVersion' | 'init' | 'destroy' | 'getSchema' | 'onFilesChange' | 'startWatchingContentUpdates' | 'stopWatchingContentUpdates' | 'hasAccess' | 'getDocuments' | 'createDocument' | 'updateDocument'> & {
    init(options: {
        logger: CSITypes.Logger;
        userLogger: CSITypes.Logger;
        userCommandSpawner?: CSITypes.UserCommandSpawner;
        localDev: boolean;
        webhookUrl?: string;
        devAppRestartNeeded?: () => void;
    }): Promise<void>;
    getModels(): Promise<CSITypes.Model[]>;
    getLocales(): Promise<CSITypes.Locale[]>;
    onFilesChange?(options: {
        updatedFiles: string[];
    }): Promise<{
        schemaChanged?: boolean;
        contentChangeEvent?: CSITypes.ContentChangeEvent;
    }>;
    startWatchingContentUpdates(options: {
        getModelMap: () => CSITypes.ModelMap;
        getDocument: ({ documentId }: {
            documentId: string;
        }) => CSITypes.Document | undefined;
        getAsset: ({ assetId }: {
            assetId: string;
        }) => CSITypes.Asset | undefined;
        onContentChange: (contentChangeEvent: CSITypes.ContentChangeEvent) => Promise<void>;
        onSchemaChange: () => void;
    }): void;
    stopWatchingContentUpdates(): void;
    hasAccess(options: {
        userContext?: CSITypes.User;
    }): boolean | Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    getDocuments(options: {
        modelMap: CSITypes.ModelMap;
    }): Promise<CSITypes.Document[]>;
    createDocument(options: {
        updateOperationFields: Record<string, CSITypes.UpdateOperationField>;
        model: CSITypes.Model;
        modelMap: CSITypes.ModelMap;
        locale?: string;
        defaultLocaleDocumentId?: string;
        userContext?: CSITypes.User;
    }): Promise<CSITypes.Document>;
    updateDocument(options: {
        document: CSITypes.Document;
        operations: CSITypes.UpdateOperation[];
        modelMap: CSITypes.ModelMap;
        userContext?: CSITypes.User;
    }): Promise<CSITypes.Document>;
};
/**
 * BackCompatContentSourceInterface redefines the ContentSourceInterface such
 * that when its methods are called, it can correctly invoke the previous
 * content source module versions.
 *
 * The parameters of its methods must be intersections of the parameters in the
 * previous versions. For example, if a method in an older version received
 * 'options.x', and a method in the newer version receives 'options.y', the
 * matching method should receive both options '{ x } & { y }' to ensure that
 * both the older and the newer content sources will receive what they need.
 *
 * The method return values must match the most recent content source versions.
 */
export type BackCompatContentSourceInterface = Omit<CSITypes.ContentSourceInterface, 'getVersion' | 'onFilesChange' | 'startWatchingContentUpdates' | 'hasAccess' | 'getDocuments' | 'createDocument' | 'updateDocument'> & {
    getVersion(): GetVersionReturn;
    onFilesChange(options: BCOnFilesChangeOptions): OnFilesChangeReturn;
    startWatchingContentUpdates?(options: BCStartWatchingOptions): StartWatchingReturn;
    hasAccess(options: BCHasAccessOptions): HasAccessReturn;
    getDocuments(options: BCGetDocumentsOptions): GetDocumentsReturn;
    createDocument(options: BCCreateDocumentOptions): CreateDocumentReturn;
    updateDocument(options: BCUpdateDocumentOptions): UpdateDocumentReturn;
};
export declare function backwardCompatibleContentSource(contentSource: AnyContentSourceInterface): BackCompatContentSourceInterface;
type ReturnTypeOfMethod<Method extends keyof CSITypes.ContentSourceInterface> = ReturnType<NonNullable<CSITypes.ContentSourceInterface[Method]>>;
type GetVersionReturn = Promise<{
    interfaceVersion: string;
    contentSourceVersion: string;
}>;
export declare function getVersion(contentSource: AnyContentSourceInterface): GetVersionReturn;
type DestroyReturn = ReturnTypeOfMethod<'destroy'>;
export declare function destroy(contentSource: AnyContentSourceInterface): DestroyReturn;
type BCOnFilesChangeOptions = {
    updatedFiles: string[];
};
type OnFilesChangeReturn = ReturnTypeOfMethod<'onFilesChange'>;
/**
 * Converts the old onFilesChange API to the new one
 * OLD: onFilesChange?(options: { updatedFiles: string[]; }):
 *        Promise<{ schemaChanged?: boolean; contentChangeEvent?: ContentChangeEvent<DocumentContext, AssetContext> }>
 * NEW: onFilesChange?(options: { updatedFiles: string[]; }):
 *        Promise<{ invalidateSchema?: boolean; contentChanges?: ContentChanges<DocumentContext, AssetContext> }>
 */
export declare function onFilesChange(contentSource: AnyContentSourceInterface, options: BCOnFilesChangeOptions): OnFilesChangeReturn;
type BCStartWatchingOptions = {
    getModelMap: () => CSITypes.ModelMap;
    getDocument: ({ documentId }: {
        documentId: string;
    }) => CSITypes.Document | undefined;
    getAsset: ({ assetId }: {
        assetId: string;
    }) => CSITypes.Asset | undefined;
    onContentChange: (contentChangeEvent: CSITypes.ContentChangeEvent) => Promise<void>;
    onSchemaChange: () => void;
};
type StartWatchingReturn = ReturnTypeOfMethod<'startWatchingContentUpdates'>;
/**
 * Converts between the old startWatchingContentUpdates API and the new one.
 * OLD: startWatchingContentUpdates(options: startWatchingContentUpdatesOptionsOld): void;
 * NEW: startWatchingContentUpdates?(): void;
 */
export declare function startWatchingContentUpdates(contentSource: AnyContentSourceInterface, options: BCStartWatchingOptions): StartWatchingReturn;
/**
 * Converts the old getModels() and getLocales() API methods to the new getSchema() API method.
 * OLD:
 *   getModels(): Promise<Model[]>;
 *   getLocales(): Promise<Locale[]>
 * NEW:
 *   getSchema(): Promise<Schema<SchemaContext>>
 */
export declare function getSchema(contentSource: AnyContentSourceInterface): Promise<CSITypes.Schema>;
type HasAccessReturn = ReturnTypeOfMethod<'hasAccess'>;
type BCHasAccessOptions = {
    userContext?: CSITypes.User;
};
/**
 * Converts the old hasAccess API to the new one
 * OLD: hasAccess(options: { userContext?: CSITypes.User }): Promise<boolean>
 * NEW: hasAccess(options: { userContext?: CSITypes.User }): Promise<{ hasConnection: boolean; hasPermissions: boolean }>
 */
export declare function hasAccess(contentSource: AnyContentSourceInterface, options: BCHasAccessOptions): HasAccessReturn;
type BCGetDocumentsOptions = {
    modelMap: CSITypes.ModelMap;
    syncContext?: unknown;
};
type GetDocumentsReturn = ReturnTypeOfMethod<'getDocuments'>;
/**
 * Converts the old getDocuments API to the new one
 * OLD: getDocuments(options: { modelMap: ModelMap }): Promise<Document[]>
 * NEW: getDocuments(): Promise<Document[]>
 */
export declare function getDocuments(contentSource: AnyContentSourceInterface, options: BCGetDocumentsOptions): GetDocumentsReturn;
type BCCreateDocumentOptions = {
    updateOperationFields: Record<string, CSITypes.UpdateOperationField>;
    model: CSITypes.Model;
    modelMap: CSITypes.ModelMap;
    locale?: string;
    defaultLocaleDocumentId?: string;
    userContext?: CSITypes.User;
};
type CreateDocumentReturn = ReturnTypeOfMethod<'createDocument'>;
/**
 * Converts the old createDocument API to the new one
 * OLD: createDocument(options: Options & { modelMap: ModelMap }): Promise<Document<DocumentContext>>
 * NEW: createDocument(options: Options): Promise<{ documentId: string }>
 */
export declare function createDocument(contentSource: AnyContentSourceInterface, options: BCCreateDocumentOptions): CreateDocumentReturn;
type UpdateDocumentReturn = ReturnTypeOfMethod<'updateDocument'>;
type BCUpdateDocumentOptions = {
    document: CSITypes.Document;
    operations: CSITypes.UpdateOperation[];
    modelMap: CSITypes.ModelMap;
    userContext?: CSITypes.User;
};
/**
 * Converts the old updateDocument API to the new one
 * OLD: updateDocument(options: Options & { modelMap: ModelMap }): Promise<CSITypes.Document>;
 * NEW: updateDocument(options: Options): Promise<void>
 */
export declare function updateDocument(contentSource: AnyContentSourceInterface, options: BCUpdateDocumentOptions): UpdateDocumentReturn;
export {};
//# sourceMappingURL=backward-compatibility.d.ts.map