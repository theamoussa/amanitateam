"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDocumentPreview = exports.getDocumentLocale = exports.mapCSIDocumentsToStoreDocuments = exports.mapCSIAssetsToStoreAssets = void 0;
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@stackbit/utils");
const types_1 = require("@stackbit/types");
const common_schema_1 = require("../common/common-schema");
const asset_sources_utils_1 = require("./asset-sources-utils");
function mapCSIAssetsToStoreAssets({ csiAssets, contentSourceInstance, defaultLocaleCode }) {
    const extra = getMetadataFromContentStore({ contentSourceInstance });
    return csiAssets.map((csiAsset) => sourceAssetToStoreAsset({
        csiAsset,
        defaultLocaleCode,
        extra
    }));
}
exports.mapCSIAssetsToStoreAssets = mapCSIAssetsToStoreAssets;
function sourceAssetToStoreAsset({ csiAsset, defaultLocaleCode, extra }) {
    return (0, utils_1.omitByNil)({
        type: 'asset',
        ...extra,
        srcObjectId: csiAsset.id,
        srcObjectUrl: csiAsset.manageUrl,
        srcObjectLabel: getAssetLabel(csiAsset, defaultLocaleCode),
        srcModelName: common_schema_1.ASSET_MODEL.name,
        srcModelLabel: common_schema_1.ASSET_MODEL.label ?? '',
        isChanged: csiAsset.status === 'added' || csiAsset.status === 'modified',
        status: csiAsset.status,
        createdAt: csiAsset.createdAt,
        createdBy: csiAsset.createdBy,
        updatedAt: csiAsset.updatedAt,
        updatedBy: csiAsset.updatedBy,
        locale: csiAsset.locale,
        hidden: csiAsset.hidden,
        fields: mapCSIAssetsFieldsToStoreFields({
            csiAssetFields: csiAsset.fields,
            modelFields: common_schema_1.ASSET_MODEL.fields ?? []
        })
    });
}
function mapCSIAssetsFieldsToStoreFields({ csiAssetFields, modelFields }) {
    return modelFields?.reduce((result, modelField) => {
        const csiAssetField = csiAssetFields[modelField.name];
        const docField = mapCSIAssetFieldToStoreField({
            csiAssetField,
            modelField,
            localized: modelField.localized
        });
        if ('label' in docField) {
            docField.label = modelField.label ?? docField.label;
        }
        result[modelField.name] = docField;
        return result;
    }, {});
}
function mapCSIAssetFieldToStoreField({ csiAssetField, modelField, localized }) {
    switch (modelField.type) {
        case 'string':
        case 'text':
            if (!csiAssetField) {
                if (localized) {
                    return {
                        type: modelField.type,
                        localized: true,
                        locales: {}
                    };
                }
                return {
                    type: modelField.type,
                    localized: false
                };
            }
            return {
                label: lodash_1.default.upperFirst(modelField.name),
                ...csiAssetField,
                type: modelField.type
            };
        case 'assetFile':
            if (!csiAssetField) {
                return {
                    type: modelField.type,
                    ...(localized ? { localized: true, locales: {} } : { url: '' })
                };
            }
            return {
                ...csiAssetField,
                type: modelField.type
            };
        default: {
            const _exhaustiveCheck = modelField;
            return _exhaustiveCheck;
        }
    }
}
/**
 * CSI documents do not specify unset fields. For example, if the "title" field
 * is not set in CMS, the CSI document will not have the title field in its
 * "fields" map.
 *
 * On the other hand, and for historical reasons, Stackbit client requires all
 * fields to be defined on the document, even the fields that are not set to any
 * value. Therefore, until this issue is solved and Stackbit client will be able
 * to infer unset document field from the model, every content store document
 * need to be extended and list all the fields from the matching model.
 *
 * Empty primitive fields like "string" are regarded empty when they have no
 * "value" property. Other more complex fields like objects and references have
 * the special "isUnset" property.
 *
 * @param csiDocuments
 * @param contentSourceInstance
 * @param modelMap
 * @param defaultLocaleCode
 * @param assetSources
 * @param createConfigDelegate
 */
function mapCSIDocumentsToStoreDocuments({ csiDocuments, contentSourceInstance, modelMap, defaultLocaleCode, assetSources, createConfigDelegate, logger }) {
    const meta = getMetadataFromContentStore({ contentSourceInstance });
    return csiDocuments.map((csiDocument) => mapCSIDocumentToStoreDocument({
        csiDocument,
        model: modelMap[csiDocument.modelName],
        modelMap,
        defaultLocaleCode,
        meta,
        assetSources,
        createConfigDelegate,
        logger
    }));
}
exports.mapCSIDocumentsToStoreDocuments = mapCSIDocumentsToStoreDocuments;
function mapCSIDocumentToStoreDocument({ csiDocument, model, modelMap, defaultLocaleCode, meta, assetSources, createConfigDelegate, logger }) {
    return (0, utils_1.omitByNil)({
        type: 'document',
        ...meta,
        srcObjectId: csiDocument.id,
        srcObjectUrl: csiDocument.manageUrl,
        getPreview: ({ delegate, locale }) => getDocumentPreview({
            csiDocument,
            model,
            srcType: meta.srcType,
            srcProjectId: meta.srcProjectId,
            delegate: delegate ?? createConfigDelegate(),
            locale
        }),
        srcModelLabel: model.label ?? lodash_1.default.startCase(csiDocument.modelName),
        srcModelName: csiDocument.modelName,
        isChanged: csiDocument.status === 'added' || csiDocument.status === 'modified',
        status: csiDocument.status,
        createdAt: csiDocument.createdAt,
        createdBy: csiDocument.createdBy,
        updatedAt: csiDocument.updatedAt,
        updatedBy: csiDocument.updatedBy,
        hidden: typeof csiDocument.hidden === 'boolean' ? csiDocument.hidden : model.hidden,
        locale: getDocumentLocale({ csiDocument, model }),
        fields: mapCSIFieldsToStoreFields({
            csiDocumentFields: csiDocument.fields,
            modelFields: model.fields ?? [],
            context: {
                srcType: meta.srcType,
                srcProjectId: meta.srcProjectId,
                parentDocument: csiDocument,
                modelMap,
                defaultLocaleCode,
                assetSources,
                createConfigDelegate,
                fieldPath: [],
                logger
            }
        }),
        permissions: csiDocument.permissions
    });
}
function mapCSIFieldsToStoreFields({ csiDocumentFields, modelFields, context }) {
    return modelFields.reduce((result, modelField) => {
        const csiDocumentField = csiDocumentFields[modelField.name];
        const fieldPath = context.fieldPath.concat(modelField.name);
        const docField = mapCSIFieldToStoreField({
            csiDocumentField,
            modelField,
            localized: modelField.localized,
            context: {
                ...context,
                fieldPath: fieldPath
            }
        });
        docField.label = modelField.label;
        result[modelField.name] = docField;
        return result;
    }, {});
}
function mapCSIFieldToStoreField({ csiDocumentField, modelField, localized, context }) {
    if (!csiDocumentField) {
        const shouldUseIsUnset = ['markdown', 'richText', 'image', 'file', 'json', 'object', 'model', 'reference', 'cross-reference'].includes(modelField.type);
        return {
            type: modelField.type,
            ...(localized
                ? { localized, locales: {} }
                : {
                    ...(shouldUseIsUnset ? { isUnset: true } : null),
                    ...(modelField.type === 'list' ? { items: [] } : null)
                })
        };
    }
    switch (modelField.type) {
        case 'string':
        case 'text':
        case 'html':
        case 'url':
        case 'boolean':
        case 'number':
        case 'date':
        case 'datetime':
        case 'enum':
        case 'json': // TODO: 'json' and 'style' fields can be remapped from 'string' and 'text', in this case parse the JSON object
        case 'style':
        case 'color':
        case 'slug':
            // Override document field types with model field types.
            // Developer can remap content-source model fields to different field using stackbit config.
            // For example, a 'string' field in a content-source can be mapped to 'color' field in stackbit config.
            return {
                ...csiDocumentField,
                type: modelField.type
            };
        case 'image':
            // The 'image' model field can be a 'reference' document field in CMSes like Sanity and Contentful.
            if (csiDocumentField.type === 'reference') {
                return csiDocumentField;
            }
            return mapImageField(csiDocumentField, modelField, context.assetSources, context.logger);
        // Don't override types of the following document fields.
        // Rest of the fields must have the same type across document and model fields.
        case 'file':
        case 'reference':
            return csiDocumentField;
        case 'cross-reference':
            return mapCrossReferenceField(csiDocumentField);
        case 'object':
            return mapObjectField(csiDocumentField, modelField, context);
        case 'model':
            return mapModelField(csiDocumentField, modelField, context);
        case 'list':
            // list can not be in list, so modelField must be FieldList
            return mapListField(csiDocumentField, modelField, context);
        case 'richText':
            return mapRichTextField(csiDocumentField);
        case 'markdown':
            return mapMarkdownField(csiDocumentField);
        default: {
            const _exhaustiveCheck = modelField;
            return _exhaustiveCheck;
        }
    }
}
function mapImageField(csiDocumentField, imageModelField, assetSources, logger) {
    // the image can be remapped from 'string', 'text' or 'json' fields
    if ((0, types_1.isDocumentFieldOneOfFieldTypes)(csiDocumentField, ['string', 'text', 'json'])) {
        try {
            if (!(0, types_1.isLocalizedField)(csiDocumentField)) {
                if (imageModelField.source) {
                    return (0, utils_1.omitByNil)({
                        type: 'image',
                        source: imageModelField.source,
                        sourceData: csiDocumentField.value,
                        fields: (0, asset_sources_utils_1.getImageFieldsFromSourceData)({
                            sourceData: csiDocumentField.value,
                            imageModelField: imageModelField,
                            assetSources,
                            logger
                        })
                    });
                }
            }
            else {
                return (0, utils_1.omitByNil)({
                    type: 'image',
                    source: imageModelField.source,
                    localized: true,
                    locales: lodash_1.default.mapValues(csiDocumentField.locales, (locale) => {
                        return {
                            locale: locale.locale,
                            sourceData: locale.value,
                            fields: (0, asset_sources_utils_1.getImageFieldsFromSourceData)({
                                sourceData: locale.value,
                                imageModelField: imageModelField,
                                assetSources,
                                logger
                            })
                        };
                    })
                });
            }
        }
        catch (e) {
            return {
                type: 'image',
                ...((0, types_1.isLocalizedField)(csiDocumentField) ? { localized: true, locales: {} } : { isUnset: true })
            };
        }
    }
    if (csiDocumentField.type !== 'image') {
        return {
            type: 'image',
            ...((0, types_1.isLocalizedField)(csiDocumentField) ? { localized: true, locales: {} } : { isUnset: true })
        };
    }
    if (!(0, types_1.isLocalizedField)(csiDocumentField)) {
        return (0, utils_1.omitByNil)({
            type: 'image',
            source: csiDocumentField.source,
            sourceData: csiDocumentField.sourceData,
            fields: csiDocumentField.fields ??
                (0, asset_sources_utils_1.getImageFieldsFromSourceData)({
                    sourceData: csiDocumentField.sourceData,
                    imageModelField: imageModelField,
                    assetSources,
                    logger
                })
        });
    }
    return (0, utils_1.omitByNil)({
        type: 'image',
        source: csiDocumentField.source,
        localized: true,
        locales: lodash_1.default.mapValues(csiDocumentField.locales, (locale) => {
            return {
                locale: locale.locale,
                sourceData: locale.sourceData,
                fields: 
                // for backward compatibility use, fields if provided
                locale.fields ??
                    (0, asset_sources_utils_1.getImageFieldsFromSourceData)({
                        sourceData: locale.sourceData,
                        imageModelField: imageModelField,
                        assetSources,
                        logger
                    })
            };
        })
    });
}
function mapCrossReferenceField(csiDocumentField) {
    const unlocalizedUnset = {
        type: 'cross-reference',
        refType: 'document',
        isUnset: true
    };
    if (!(0, types_1.isDocumentFieldOneOfFieldTypes)(csiDocumentField, ['string', 'text', 'json', 'cross-reference'])) {
        if ((0, types_1.isLocalizedField)(csiDocumentField)) {
            return {
                type: 'cross-reference',
                refType: 'document',
                localized: true,
                locales: {}
            };
        }
        return unlocalizedUnset;
    }
    if (csiDocumentField.type === 'cross-reference') {
        if ((0, types_1.isLocalizedField)(csiDocumentField)) {
            return {
                type: 'cross-reference',
                refType: 'document',
                localized: true,
                locales: lodash_1.default.reduce(csiDocumentField.locales, (accum, locale, localeKey) => {
                    // the documentField.type is 'cross-reference', so it is already in the correct format
                    accum[localeKey] = locale;
                    return accum;
                }, {})
            };
        }
        else {
            return csiDocumentField;
        }
    }
    const parseRefObject = (value) => {
        if (typeof value === 'string') {
            try {
                value = JSON.parse(value);
            }
            catch (error) {
                return null;
            }
        }
        if (lodash_1.default.isPlainObject(value) && 'refId' in value && 'refSrcType' in value && 'refProjectId' in value) {
            return {
                refId: value.refId,
                refSrcType: value.refSrcType,
                refProjectId: value.refProjectId
            };
        }
        return null;
    };
    if ((0, types_1.isLocalizedField)(csiDocumentField)) {
        return {
            type: 'cross-reference',
            refType: 'document',
            localized: true,
            locales: lodash_1.default.reduce(csiDocumentField.locales, (accum, locale, localeKey) => {
                const refObject = parseRefObject(locale.value);
                if (refObject) {
                    accum[localeKey] = {
                        locale: locale.locale,
                        ...refObject
                    };
                }
                return accum;
            }, {})
        };
    }
    if (!('value' in csiDocumentField)) {
        return unlocalizedUnset;
    }
    const refObject = parseRefObject(csiDocumentField.value);
    if (!refObject) {
        return unlocalizedUnset;
    }
    return {
        type: 'cross-reference',
        refType: 'document',
        ...refObject
    };
}
function mapObjectField(csiDocumentField, modelField, context) {
    const _getObjectPreview = ({ delegate, locale }) => {
        return getObjectPreview({
            parentDocument: context.parentDocument,
            documentField: csiDocumentField,
            objectModelOrObjectField: modelField,
            srcType: context.srcType,
            srcProjectId: context.srcProjectId,
            delegate: delegate ?? context.createConfigDelegate(),
            locale
        });
    };
    if (!(0, types_1.isLocalizedField)(csiDocumentField)) {
        return {
            type: csiDocumentField.type,
            getPreview: _getObjectPreview,
            fields: mapCSIFieldsToStoreFields({
                csiDocumentFields: csiDocumentField.fields ?? {},
                modelFields: modelField.fields ?? [],
                context
            })
        };
    }
    return {
        type: csiDocumentField.type,
        localized: true,
        locales: lodash_1.default.mapValues(csiDocumentField.locales, (locale) => {
            const fieldPath = context.fieldPath.concat(locale.locale);
            return {
                locale: locale.locale,
                getPreview: _getObjectPreview,
                fields: mapCSIFieldsToStoreFields({
                    csiDocumentFields: locale.fields ?? {},
                    modelFields: modelField.fields ?? [],
                    context: {
                        ...context,
                        fieldPath: fieldPath
                    }
                })
            };
        })
    };
}
function mapModelField(csiDocumentField, modelField, context) {
    const _getObjectPreview = (model) => ({ delegate, locale }) => {
        return getObjectPreview({
            parentDocument: context.parentDocument,
            documentField: csiDocumentField,
            objectModelOrObjectField: model,
            srcType: context.srcType,
            srcProjectId: context.srcProjectId,
            delegate: delegate ?? context.createConfigDelegate(),
            locale
        });
    };
    if (!(0, types_1.isLocalizedField)(csiDocumentField)) {
        const model = context.modelMap[csiDocumentField.modelName];
        return {
            type: csiDocumentField.type,
            getPreview: _getObjectPreview(model),
            srcModelName: csiDocumentField.modelName,
            srcModelLabel: model.label ?? lodash_1.default.startCase(model.name),
            fields: mapCSIFieldsToStoreFields({
                csiDocumentFields: csiDocumentField.fields ?? {},
                modelFields: model.fields ?? [],
                context
            })
        };
    }
    return {
        type: csiDocumentField.type,
        localized: true,
        locales: lodash_1.default.mapValues(csiDocumentField.locales, (locale) => {
            const model = context.modelMap[locale.modelName];
            const fieldPath = context.fieldPath.concat(locale.locale);
            return {
                locale: locale.locale,
                getPreview: _getObjectPreview(model),
                srcModelName: locale.modelName,
                srcModelLabel: model.label ?? lodash_1.default.startCase(model.name),
                fields: mapCSIFieldsToStoreFields({
                    csiDocumentFields: locale.fields ?? {},
                    modelFields: model.fields ?? [],
                    context: {
                        ...context,
                        fieldPath
                    }
                })
            };
        })
    };
}
function mapListField(csiDocumentField, modelField, context) {
    if (!(0, types_1.isLocalizedField)(csiDocumentField)) {
        return {
            type: csiDocumentField.type,
            items: csiDocumentField.items.map((item, index) => mapCSIFieldToStoreField({
                csiDocumentField: item,
                modelField: modelField.items ?? { type: 'string' },
                // list items can not be localized, only the list itself can be localized
                localized: false,
                context: {
                    ...context,
                    fieldPath: context.fieldPath.concat(index)
                }
            }))
        };
    }
    return {
        type: csiDocumentField.type,
        localized: true,
        locales: lodash_1.default.mapValues(csiDocumentField.locales, (locale) => {
            return {
                locale: locale.locale,
                items: (locale.items ?? []).map((item, index) => mapCSIFieldToStoreField({
                    csiDocumentField: item,
                    modelField: modelField.items ?? { type: 'string' },
                    // list items can not be localized, only the list itself can be localized
                    localized: false,
                    context: {
                        ...context,
                        fieldPath: context.fieldPath.concat([locale.locale, index])
                    }
                }))
            };
        })
    };
}
function mapRichTextField(csiDocumentField) {
    if (!(0, types_1.isLocalizedField)(csiDocumentField)) {
        return {
            ...csiDocumentField,
            multiElement: true
        };
    }
    return {
        type: csiDocumentField.type,
        localized: true,
        locales: lodash_1.default.mapValues(csiDocumentField.locales, (locale) => {
            return {
                ...locale,
                multiElement: true
            };
        })
    };
}
function mapMarkdownField(csiDocumentField) {
    if (!(0, types_1.isLocalizedField)(csiDocumentField)) {
        return {
            type: 'markdown',
            value: csiDocumentField.value,
            multiElement: true
        };
    }
    return {
        type: 'markdown',
        localized: true,
        locales: lodash_1.default.mapValues(csiDocumentField.locales, (locale) => {
            return {
                ...locale,
                multiElement: true
            };
        })
    };
}
function getMetadataFromContentStore({ contentSourceInstance }) {
    return {
        srcType: contentSourceInstance.getContentSourceType(),
        srcProjectId: contentSourceInstance.getProjectId(),
        srcProjectUrl: contentSourceInstance.getProjectManageUrl(),
        srcEnvironment: contentSourceInstance.getProjectEnvironment()
    };
}
function getDocumentLocale({ csiDocument, model }) {
    if (csiDocument.locale) {
        return csiDocument.locale;
    }
    if ((model.type === 'page' || model.type === 'data') && model.localized && typeof model.locale === 'function') {
        return model.locale({ document: csiDocument, model });
    }
}
exports.getDocumentLocale = getDocumentLocale;
function getDocumentPreview({ csiDocument, model, srcType, srcProjectId, delegate, locale }) {
    let previewTitle;
    if ('preview' in model && model.preview && (model.type === 'page' || model.type === 'data')) {
        if (typeof model.preview === 'function') {
            const previewResult = model.preview({
                document: { ...csiDocument, srcType, srcProjectId },
                currentLocale: locale,
                ...delegate
            });
            previewTitle = previewResult.title;
        }
        else if (model.preview.title) {
            // do not pass locale when resolving automatically to use default locale
            previewTitle = resolveDocumentLabelForFieldPath({
                document: { ...csiDocument, srcType, srcProjectId },
                fieldPath: model.preview.title,
                delegate
            });
        }
    }
    // if previewTitle was not resolved, resolve using model, at the worst case the model name or label will be used
    if (!previewTitle) {
        previewTitle = getObjectTitleFromLabelField({
            document: { ...csiDocument, srcType, srcProjectId },
            modelOrObjectField: model,
            delegate,
            locale
        });
    }
    if (!previewTitle) {
        previewTitle = getObjectTitleFromModel(model);
    }
    return { previewTitle: previewTitle?.toString?.() };
}
exports.getDocumentPreview = getDocumentPreview;
function getObjectPreview({ parentDocument, documentField, objectModelOrObjectField, srcType, srcProjectId, delegate, locale }) {
    let previewTitle;
    if ('preview' in objectModelOrObjectField && objectModelOrObjectField.preview) {
        if (typeof objectModelOrObjectField.preview === 'function') {
            const previewResult = objectModelOrObjectField.preview({
                parentDocument: { ...parentDocument, srcType, srcProjectId },
                documentField: documentField,
                currentLocale: locale,
                ...delegate
            });
            previewTitle = previewResult.title;
        }
        else if (objectModelOrObjectField.preview.title) {
            // do not pass locale when resolving automatically to use default locale
            previewTitle = resolveDocumentLabelForFieldPath({
                document: { ...parentDocument, srcType, srcProjectId },
                fromField: documentField,
                fieldPath: objectModelOrObjectField.preview.title,
                delegate
            });
        }
    }
    if (!previewTitle) {
        previewTitle = getObjectTitleFromLabelField({
            document: { ...parentDocument, srcType, srcProjectId },
            documentField,
            modelOrObjectField: objectModelOrObjectField,
            delegate,
            locale
        });
    }
    if (!previewTitle && 'name' in objectModelOrObjectField) {
        previewTitle = getObjectTitleFromModel(objectModelOrObjectField);
    }
    return { previewTitle: previewTitle?.toString?.() };
}
function resolveDocumentLabelForFieldPath({ document, fromField, fieldPath, delegate }) {
    const documentField = delegate.getDocumentFieldForFieldPath({
        document: document,
        fromField: fromField,
        fieldPath: fieldPath
    });
    if (documentField && 'value' in documentField) {
        return documentField.value?.toString?.();
    }
    return undefined;
}
function getObjectTitleFromLabelField({ document, documentField, modelOrObjectField, delegate }) {
    const labelField = modelOrObjectField.labelField;
    if (!labelField) {
        return;
    }
    return resolveDocumentLabelForFieldPath({
        document: document,
        fromField: documentField,
        fieldPath: labelField,
        delegate
    });
}
function getAssetLabel(csiAsset, locale) {
    const imageModel = common_schema_1.IMAGE_MODEL;
    let label = getAssetLabelFromLabelField(csiAsset, imageModel, locale);
    if (!label) {
        label = getObjectTitleFromModel(imageModel);
    }
    return label;
}
function getAssetLabelFromLabelField(csiAsset, imageModel, locale) {
    const labelField = imageModel.labelField;
    if (!labelField) {
        return;
    }
    const field = lodash_1.default.get(csiAsset.fields, labelField);
    if (!field) {
        return;
    }
    const localizedField = (0, types_1.getLocalizedFieldForLocale)(field, locale);
    if (localizedField && 'value' in localizedField && localizedField.value) {
        return localizedField.value;
    }
}
function getObjectTitleFromModel(model) {
    return model.label ? model.label : lodash_1.default.startCase(model.name);
}
//# sourceMappingURL=csi-to-store-docs-converter.js.map