"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDocumentFieldLabelValueForSiteMapEntry = exports.updateSiteMapEntriesWithContentChanges = exports.getSiteMapEntriesFromStackbitConfig = exports.SiteMapStaticEntriesKey = void 0;
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@stackbit/utils");
const store_to_csi_docs_converter_1 = require("./store-to-csi-docs-converter");
const content_store_utils_1 = require("../content-store-utils");
exports.SiteMapStaticEntriesKey = Symbol.for('SiteMapStaticEntriesKey');
async function getSiteMapEntriesFromStackbitConfig({ stackbitConfig, contentSourceDataById, configDelegate }) {
    if (!stackbitConfig?.siteMap) {
        return {};
    }
    const siteMapOptions = lodash_1.default.reduce(contentSourceDataById, (accum, contentSourceData) => {
        return {
            models: accum.models.concat(contentSourceData.models.map((model) => ({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                ...model
            }))),
            documents: accum.documents.concat((0, store_to_csi_docs_converter_1.mapStoreDocumentsToCSIDocumentsWithSource)({
                documents: contentSourceData.documents,
                csiDocumentMap: contentSourceData.csiDocumentMap
            }))
        };
    }, { models: [], documents: [] });
    const rawSiteMapEntries = stackbitConfig.siteMap({
        ...siteMapOptions,
        ...configDelegate
    }) ?? [];
    // The rawSiteMapEntries entries are provided by the user, sanitize them and filter out illegal entries
    return sanitizeAndGroupSiteMapEntries(rawSiteMapEntries);
}
exports.getSiteMapEntriesFromStackbitConfig = getSiteMapEntriesFromStackbitConfig;
/**
 * Because the sitemap is directly affected by documents, the sitemap can change
 * whenever there is a content change. For example, if a new document is added
 * or deleted, a new sitemap entry would be added or deleted respectively.
 * Likewise, if a slug of an existing document is changed, the sitemap entry for
 * that document would also change.
 *
 * However, to improve overall performance, we don't want to call
 * stackbitConfig.siteMap() with all the documents when a small set of documents
 * is changed. Instead, we want to call stackbitConfig.siteMap() with only the
 * changed documents. Then we merge the partial sitemap entries with the
 * existing sitemap entries using sitemap entry identifiers such as
 * srcDocumentId for document-related entries and stackbitId for static entries.
 *
 * @param siteMapEntries Existing sitemap entries
 * @param contentChanges A ContentChangeResult including new, changed and
 *   deleted documents
 * @param stackbitConfig Stackbit config
 * @param contentSourceDataById ContentSourceData by content source IDs
 */
async function updateSiteMapEntriesWithContentChanges({ siteMapEntryGroups, contentChanges, stackbitConfig, contentSourceDataById, configDelegate }) {
    if (!stackbitConfig?.siteMap) {
        return {};
    }
    const updatedDocuments = [...contentChanges.createdDocuments, ...contentChanges.updatedDocuments];
    if (updatedDocuments.length === 0 && contentChanges.deletedDocuments.length === 0) {
        return siteMapEntryGroups;
    }
    // Create a map of changed documents by content source id
    const changedDocumentsByContentSourceId = updatedDocuments.reduce((accum, contentChangeResultItem) => {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(contentChangeResultItem.srcType, contentChangeResultItem.srcProjectId);
        const document = contentSourceDataById[contentSourceId]?.documentMap[contentChangeResultItem.srcObjectId];
        if (document) {
            (0, utils_1.append)(accum, [contentSourceId], document);
        }
        return accum;
    }, {});
    // Create siteMap parameters from changed documents
    const partialSiteMapOptions = lodash_1.default.reduce(contentSourceDataById, (accum, contentSourceData) => {
        const changedDocuments = changedDocumentsByContentSourceId[contentSourceData.id] ?? [];
        return {
            models: accum.models.concat(contentSourceData.models.map((model) => ({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                ...model
            }))),
            documents: accum.documents.concat((0, store_to_csi_docs_converter_1.mapStoreDocumentsToCSIDocumentsWithSource)({
                documents: changedDocuments,
                csiDocumentMap: contentSourceData.csiDocumentMap
            }))
        };
    }, { models: [], documents: [] });
    const partialRawSiteMapEntries = stackbitConfig.siteMap({
        ...partialSiteMapOptions,
        ...configDelegate
    }) ?? [];
    // The partialRawSiteMapEntries entries are provided by the user, sanitize them and filter out illegal entries
    const partialSiteMapEntryGroups = sanitizeAndGroupSiteMapEntries(partialRawSiteMapEntries);
    siteMapEntryGroups = lodash_1.default.reduce(contentChanges.deletedDocuments, (accum, contentChangeResultItem) => {
        const siteMapGroupKey = `${contentChangeResultItem.srcType}:${contentChangeResultItem.srcProjectId}:${contentChangeResultItem.srcObjectId}`;
        delete accum[siteMapGroupKey];
        return accum;
    }, siteMapEntryGroups);
    siteMapEntryGroups = lodash_1.default.reduce(partialSiteMapEntryGroups, (accum, newSiteMapEntriesByStableId, siteMapGroupKey) => {
        accum[siteMapGroupKey] = newSiteMapEntriesByStableId;
        return accum;
    }, siteMapEntryGroups);
    return siteMapEntryGroups;
}
exports.updateSiteMapEntriesWithContentChanges = updateSiteMapEntriesWithContentChanges;
function sanitizeAndGroupSiteMapEntries(siteMapEntries) {
    return siteMapEntries.reduce((accum, siteMapEntry) => {
        if (!siteMapEntry) {
            return accum;
        }
        if (typeof siteMapEntry.urlPath !== 'string') {
            return accum;
        }
        if ('document' in siteMapEntry) {
            const doc = siteMapEntry.document;
            if (!doc.srcType || !doc.srcProjectId || !doc.modelName || !doc.id) {
                return accum;
            }
            siteMapEntry = {
                ...siteMapEntry,
                document: {
                    id: doc.id,
                    modelName: doc.modelName,
                    srcType: doc.srcType,
                    srcProjectId: doc.srcProjectId
                }
            };
        }
        if (!siteMapEntry.stableId) {
            siteMapEntry = {
                ...siteMapEntry,
                stableId: 'document' in siteMapEntry ? siteMapEntry.document.id : siteMapEntry.urlPath
            };
        }
        const groupKey = getSiteMapGroupKey(siteMapEntry);
        lodash_1.default.set(accum, [groupKey, siteMapEntry.stableId], siteMapEntry);
        return accum;
    }, {});
}
function getSiteMapGroupKey(siteMapEntry) {
    return 'document' in siteMapEntry
        ? (0, content_store_utils_1.getObjectId)(siteMapEntry.document.srcType, siteMapEntry.document.srcProjectId, siteMapEntry.document.id)
        : exports.SiteMapStaticEntriesKey.toString();
}
function getDocumentFieldLabelValueForSiteMapEntry({ siteMapEntry, locale, contentSourceDataById }) {
    if (!('document' in siteMapEntry)) {
        return null;
    }
    const contentSourceId = (0, content_store_utils_1.getContentSourceId)(siteMapEntry.document.srcType, siteMapEntry.document.srcProjectId);
    const contentSourceData = contentSourceDataById[contentSourceId];
    if (!contentSourceData) {
        return null;
    }
    const document = contentSourceData.documentMap[siteMapEntry.document.id];
    if (!document) {
        return null;
    }
    const { previewTitle } = document?.getPreview({ locale }) ?? {};
    if (previewTitle) {
        return String(previewTitle);
    }
    const labelFieldName = contentSourceData.modelMap[siteMapEntry.document.modelName]?.labelField;
    if (labelFieldName) {
        const labelField = labelFieldName ? document?.fields[labelFieldName] : undefined;
        if (!labelField) {
            return null;
        }
        const localizedLabelField = (0, content_store_utils_1.getDocumentFieldForLocale)(labelField, locale);
        if (!localizedLabelField || !('value' in localizedLabelField) || !localizedLabelField.value) {
            return null;
        }
        return String(localizedLabelField.value);
    }
    return null;
}
exports.getDocumentFieldLabelValueForSiteMapEntry = getDocumentFieldLabelValueForSiteMapEntry;
//# sourceMappingURL=site-map.js.map