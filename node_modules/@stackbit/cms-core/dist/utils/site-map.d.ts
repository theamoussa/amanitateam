import { Config } from '@stackbit/sdk';
import { SiteMapEntry } from '@stackbit/types';
import * as CSITypes from '@stackbit/types';
import * as ContentStoreTypes from '../types';
export declare const SiteMapStaticEntriesKey: unique symbol;
export type SiteMapEntriesSourceKeys = string | symbol;
/**
 * SiteMapEntryGroups is a two level hashmap.
 * If the SiteMapEntry is document-related, the first level key will be an
 * identifier of the document including content source, and the second key will
 * be the stableId. If the SiteMapEntry is static entry, the first key will
 * be a constant Symbol and the second key will be the stableId.
 * {
 *     `{srcType}:{srcProjectId}:{srcDocumentId}`: {
 *         `{stableId}`: SiteMapEntry
 *     },
 *     [SiteMapStaticEntriesKey]: {
 *         `{stableId}`: SiteMapEntry
 *     }
 * }
 */
export type SiteMapEntryGroups = Record<SiteMapEntriesSourceKeys, Record<string, SiteMapEntry>>;
export declare function getSiteMapEntriesFromStackbitConfig({ stackbitConfig, contentSourceDataById, configDelegate }: {
    stackbitConfig: Config | null;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    configDelegate: CSITypes.ConfigDelegate;
}): Promise<SiteMapEntryGroups>;
/**
 * Because the sitemap is directly affected by documents, the sitemap can change
 * whenever there is a content change. For example, if a new document is added
 * or deleted, a new sitemap entry would be added or deleted respectively.
 * Likewise, if a slug of an existing document is changed, the sitemap entry for
 * that document would also change.
 *
 * However, to improve overall performance, we don't want to call
 * stackbitConfig.siteMap() with all the documents when a small set of documents
 * is changed. Instead, we want to call stackbitConfig.siteMap() with only the
 * changed documents. Then we merge the partial sitemap entries with the
 * existing sitemap entries using sitemap entry identifiers such as
 * srcDocumentId for document-related entries and stackbitId for static entries.
 *
 * @param siteMapEntries Existing sitemap entries
 * @param contentChanges A ContentChangeResult including new, changed and
 *   deleted documents
 * @param stackbitConfig Stackbit config
 * @param contentSourceDataById ContentSourceData by content source IDs
 */
export declare function updateSiteMapEntriesWithContentChanges({ siteMapEntryGroups, contentChanges, stackbitConfig, contentSourceDataById, configDelegate }: {
    siteMapEntryGroups: SiteMapEntryGroups;
    contentChanges: ContentStoreTypes.ContentChangeResult;
    stackbitConfig: Config | null;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    configDelegate: CSITypes.ConfigDelegate;
}): Promise<SiteMapEntryGroups>;
export declare function getDocumentFieldLabelValueForSiteMapEntry({ siteMapEntry, locale, contentSourceDataById }: {
    siteMapEntry: SiteMapEntry;
    locale?: string;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): string | null;
//# sourceMappingURL=site-map.d.ts.map