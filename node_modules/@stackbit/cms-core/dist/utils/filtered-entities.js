"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilteredModelForUser = exports.getContentSourceFilteredModelsForUser = exports.getFilteredAssetsForUser = exports.getFilteredDocumentsForUser = void 0;
const lodash_1 = __importDefault(require("lodash"));
const consts_1 = require("../consts");
const content_store_utils_1 = require("../content-store-utils");
const csi_to_store_docs_converter_1 = require("./csi-to-store-docs-converter");
const getFilteredDocumentsForUser = ({ user, documents, permissionsForModel, permissionsForDocument, contentSourceDataById, createConfigDelegate, logger }) => {
    if (!user) {
        return documents;
    }
    const documentsBySourceId = lodash_1.default.groupBy(documents, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
    const resultDocuments = [];
    const configDelegate = createConfigDelegate();
    for (const [contentSourceId, contentSourceDocuments] of Object.entries(documentsBySourceId)) {
        const contentSourceData = (0, content_store_utils_1.getContentSourceDataByIdOrThrow)(contentSourceId, contentSourceDataById);
        const filteredModelsMap = {};
        contentSourceDocuments.forEach((document) => {
            const csiDoc = contentSourceData.csiDocumentMap[document.srcObjectId];
            if (!csiDoc) {
                throw new Error(`Document with id '${document.srcObjectId}' not found in content source '${contentSourceId}'`);
            }
            const modelName = csiDoc.modelName;
            if (!filteredModelsMap[modelName]) {
                filteredModelsMap[modelName] = (0, exports.getFilteredModelForUser)({
                    user,
                    name: modelName,
                    contentSourceData,
                    configDelegate,
                    permissionsForModel
                });
            }
            const documentModel = filteredModelsMap[modelName];
            if (!documentModel) {
                throw new Error(`Can't find model with name '${document.srcModelName}' for object with id '${document.srcObjectId}' in content source '${contentSourceId}'`);
            }
            const docPermissions = lodash_1.default.defaults(csiDoc.permissions, documentModel.permissions);
            const permissions = permissionsForDocument?.({
                ...configDelegate,
                document: {
                    ...csiDoc,
                    permissions: docPermissions,
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId
                },
                userContext: user
            }) ?? docPermissions;
            resultDocuments.push({
                ...document,
                permissions,
                hidden: documentModel.hidden || document.hidden || permissions?.canView === false
            });
            return;
        });
    }
    return resultDocuments;
};
exports.getFilteredDocumentsForUser = getFilteredDocumentsForUser;
const getFilteredAssetsForUser = ({ user, assets, filterAsset, configDelegate, contentSourceDataById }) => {
    if (!user || !filterAsset) {
        return lodash_1.default.cloneDeep(assets);
    }
    const assetsBySourceId = lodash_1.default.groupBy(assets, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
    const transformedCsiAssets = [];
    const resultAssets = [];
    for (const [contentSourceId, contentSourceAssets] of Object.entries(assetsBySourceId)) {
        const contentSourceData = (0, content_store_utils_1.getContentSourceDataByIdOrThrow)(contentSourceId, contentSourceDataById);
        contentSourceAssets.forEach((asset) => {
            const csiAsset = contentSourceData.csiAssetMap[asset.srcObjectId];
            if (!csiAsset) {
                throw new Error(`Asset with id '${asset.srcObjectId}' not found in content source '${contentSourceId}'`);
            }
            const csiAssetWithSource = {
                ...lodash_1.default.cloneDeep(csiAsset),
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId
            };
            const shouldIncludeAsset = filterAsset({
                ...configDelegate,
                asset: csiAssetWithSource,
                userContext: user
            });
            if (typeof shouldIncludeAsset === 'undefined') {
                transformedCsiAssets.push(csiAssetWithSource);
            }
            else {
                transformedCsiAssets.push({
                    ...csiAssetWithSource,
                    hidden: !shouldIncludeAsset
                });
            }
        });
        if (transformedCsiAssets.length) {
            const csResultAssets = (0, csi_to_store_docs_converter_1.mapCSIAssetsToStoreAssets)({
                csiAssets: transformedCsiAssets,
                contentSourceInstance: contentSourceData.instance,
                defaultLocaleCode: contentSourceData.defaultLocaleCode
            });
            resultAssets.push(...csResultAssets);
        }
    }
    return resultAssets;
};
exports.getFilteredAssetsForUser = getFilteredAssetsForUser;
const getContentSourceFilteredModelsForUser = ({ user, configDelegate, contentSourceData, permissionsForModel }) => {
    const filteredModels = contentSourceData.models.map((model) => {
        return (0, exports.getFilteredModelForUser)({
            user,
            configDelegate,
            name: model.name,
            contentSourceData,
            permissionsForModel
        });
    });
    const cleanModels = filteredModels.filter((model) => model.name !== consts_1.STACKBIT_PRESET_MODEL_NAME);
    return cleanModels;
};
exports.getContentSourceFilteredModelsForUser = getContentSourceFilteredModelsForUser;
const getFilteredModelForUser = ({ user, name, configDelegate, contentSourceData, permissionsForModel }) => {
    const model = contentSourceData.modelMap[name];
    if (!model) {
        throw new Error(`Model with name ${name} not found in source`);
    }
    const shouldResolvePermissions = permissionsForModel || model?.permissions;
    if (!user || !shouldResolvePermissions) {
        return model;
    }
    const modelWithSource = {
        ...lodash_1.default.cloneDeep(model),
        srcType: contentSourceData.srcType,
        srcProjectId: contentSourceData.srcProjectId
    };
    const permissionsResult = typeof model.permissions === 'function' ? model.permissions?.({ ...configDelegate, model: modelWithSource, userContext: user }) : model.permissions;
    const permissionsHookResult = permissionsForModel?.({
        ...configDelegate,
        model: { ...modelWithSource, permissions: permissionsResult },
        userContext: user
    }) ?? permissionsResult;
    const permissions = lodash_1.default.isEmpty(permissionsHookResult) ? undefined : permissionsHookResult;
    const shouldHideModel = model.hidden || permissions?.canView === false;
    return {
        ...model,
        permissions,
        hidden: shouldHideModel
    };
};
exports.getFilteredModelForUser = getFilteredModelForUser;
//# sourceMappingURL=filtered-entities.js.map