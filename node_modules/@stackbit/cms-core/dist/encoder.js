"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const consts = __importStar(require("./consts"));
const utils_1 = require("./utils");
function mapObjectFields({ data, model, fieldDataPath, fieldDataPathsInverted, fieldModelPath, encodeValue, delegate }) {
    if (!fieldModelPath) {
        fieldModelPath = [model.name];
    }
    const isRoot = fieldDataPath.length === 1;
    const metadata = delegate.getItemMetadata(data, model, isRoot);
    const fields = delegate.getItemFields(data, model);
    return lodash_1.default.reduce(fields, (accum, field) => {
        const fieldModel = lodash_1.default.find(model.fields, { name: field.name });
        // if field model wasn't found ignore this field
        if (!fieldModel) {
            return accum;
        }
        // don't include const fields
        if (lodash_1.default.has(fieldModel, 'const')) {
            return accum;
        }
        let childFieldModelPath;
        if (lodash_1.default.get(model, 'isList') && field.name === 'items') {
            childFieldModelPath = fieldModelPath;
        }
        else {
            childFieldModelPath = lodash_1.default.concat(fieldModelPath, field.name);
        }
        const fieldPath = ['fields', field.name];
        const mapLocalizedField = (accum, localizedField) => {
            const localePath = fieldModel.localized ? ['locales', localizedField.locale] : [];
            const fullFieldDataPath = lodash_1.default.concat(fieldPath, localePath);
            const mappedData = mapField({
                fieldValue: localizedField.value,
                fieldModel: fieldModel,
                fieldDataPath: lodash_1.default.concat(fieldDataPath, fullFieldDataPath),
                fieldDataPaths: accum.fieldDataPaths,
                fieldDataPathsInverted: fieldDataPathsInverted,
                fieldModelPath: childFieldModelPath,
                delegate: delegate
            });
            if (localizedField.locale && localizedField.locale !== '_unset') {
                mappedData.fieldData.locale = localizedField.locale;
            }
            lodash_1.default.set(accum.fieldData, fullFieldDataPath, {
                ...lodash_1.default.get(accum.fieldData, fullFieldDataPath),
                ...(0, utils_1.omitByNil)(mappedData.fieldData)
            });
            return {
                fieldData: accum.fieldData
            };
        };
        // always create 'fields' as object, even for objects that have field names as numbers
        lodash_1.default.setWith(accum.fieldData, fieldPath, fieldModelToFieldData(fieldModel), Object);
        if (fieldModel.localized) {
            accum = mapLocalizedField(accum, { locale: '_unset' });
        }
        if (lodash_1.default.has(field, 'locales')) {
            return lodash_1.default.reduce(field.locales, (accum, localizedField) => {
                return mapLocalizedField(accum, localizedField);
            }, accum);
        }
        return mapLocalizedField(accum, field);
    }, {
        fieldData: metadata
    });
}
function mapField({ fieldValue, fieldModel, fieldDataPath, fieldModelPath, delegate }) {
    if (lodash_1.default.includes(consts.SIMPLE_VALUE_FIELDS, fieldModel.type)) {
        return {
            fieldData: { value: fieldValue }
        };
    }
    else if (['enum', 'style'].includes(fieldModel.type)) {
        return {
            fieldData: { value: fieldValue }
        };
    }
    else if (fieldModel.type === 'list') {
        const itemsModel = lodash_1.default.get(fieldModel, 'items');
        let getListItemModel;
        if (lodash_1.default.isArray(itemsModel)) {
            // in Sanity, list items may have multiple types, in this case, 'items' will be an array
            getListItemModel = (listItem, fieldModel) => delegate.getItemTypeForListItem(listItem, fieldModel);
        }
        else {
            // get the type of list items, if type is not defined, set string as it is the default
            const listItemsType = lodash_1.default.get(itemsModel, 'type', 'string');
            getListItemModel = lodash_1.default.constant(lodash_1.default.defaults({}, itemsModel, { type: listItemsType }));
        }
        return lodash_1.default.reduce(fieldValue, (accum, listItem, listIdx) => {
            const itemModel = getListItemModel(listItem, fieldModel);
            let mappedData;
            if (!itemModel) {
                mappedData = unresolvedModel();
                accum.fieldData.items = lodash_1.default.concat(accum.fieldData.items, mappedData.fieldData);
            }
            else {
                mappedData = mapField({
                    fieldValue: listItem,
                    fieldModel: itemModel,
                    fieldDataPath: lodash_1.default.concat(fieldDataPath, ['items', listIdx]),
                    fieldModelPath: fieldModelPath,
                    delegate
                });
                accum.fieldData.items = lodash_1.default.concat(accum.fieldData.items, fieldModelToFieldData(itemModel, mappedData.fieldData));
            }
            return {
                fieldData: accum.fieldData
            };
        }, {
            fieldData: { items: [] }
        });
    }
    else if (fieldModel.type === 'object') {
        // inline object
        if (!fieldValue) {
            return unsetObject();
        }
        return mapObjectFields({
            data: fieldValue,
            model: fieldModel,
            fieldDataPath,
            fieldModelPath,
            delegate
        });
    }
    else if (fieldModel.type === 'reference') {
        if (!fieldValue) {
            return unsetObject();
        }
        const isLink = delegate.isLinkItem(fieldValue);
        if (isLink) {
            return unresolvedReference(fieldValue, delegate);
        }
        const model = delegate.getModelForItemOfReferenceType(fieldValue);
        if (!model) {
            return unresolvedModel();
        }
        return mapObjectFields({
            data: fieldValue,
            model,
            fieldDataPath,
            delegate
        });
    }
    else if (fieldModel.type === 'model') {
        if (!fieldValue) {
            return unsetObject();
        }
        const fieldModels = lodash_1.default.get(fieldModel, 'models', []);
        const modelsByName = delegate.getModelsByName();
        const model = fieldModels.length === 1 ? lodash_1.default.get(modelsByName, fieldModels[0]) : delegate.getModelForItemOfModelsType(fieldValue);
        if (!model) {
            return unresolvedModel();
        }
        return mapObjectFields({
            data: fieldValue,
            model,
            fieldDataPath,
            delegate
        });
    }
    else {
        // for everything else, delegate encoding to the delegate
        const fieldData = {};
        const encodedField = delegate.encodeField(fieldValue, fieldModel, fieldDataPath);
        if (encodedField) {
            if (lodash_1.default.has(encodedField, 'fieldData')) {
                lodash_1.default.assign(fieldData, encodedField.fieldData);
            }
        }
        return {
            fieldData: (0, utils_1.omitByNil)(fieldData)
        };
    }
}
function fieldModelToFieldData(fieldModel, overrides) {
    const type = ['reference', 'model'].includes(fieldModel.type) ? 'object' : fieldModel.type;
    return (0, utils_1.omitByNil)(lodash_1.default.assign({
        type: type,
        label: fieldModel.label,
        description: fieldModel.description,
        // fieldType: fieldModel.type,
        // fieldLabel: fieldModel.label,
        // "localized" field will be excluded from final fieldData by decoder
        localized: fieldModel.localized,
        // "models" field will be excluded from final fieldData by decoder
        models: getFieldModelNames(fieldModel)
    }, fieldModel.type === 'markdown'
        ? {
            multiElement: true
        }
        : null, fieldModel.type === 'enum'
        ? {
            options: lodash_1.default.get(fieldModel, 'options', []),
            source: lodash_1.default.get(fieldModel, 'source')
        }
        : null, overrides));
}
function getFieldModelNames(fieldModel) {
    const fieldType = fieldModel.type;
    if (fieldType === 'reference' || fieldType === 'model') {
        return lodash_1.default.clone(lodash_1.default.get(fieldModel, 'models', []));
    }
    else if (fieldModel.type === 'list') {
        const itemsModel = lodash_1.default.get(fieldModel, 'items');
        // in Sanity, array can have items of multiple types
        if (lodash_1.default.isArray(itemsModel)) {
            return Array.from(lodash_1.default.reduce(itemsModel, (accum, itemModel) => {
                return new Set([...accum, ...(getFieldModelNames(itemModel) || [])]);
            }, new Set()));
        }
        else {
            return getFieldModelNames(itemsModel);
        }
    }
    return null;
}
function unsetObject() {
    return {
        fieldData: {
            isUnset: true
        }
    };
}
function unresolvedReference(fieldValue, delegate) {
    return {
        fieldData: {
            type: 'unresolved_reference',
            refId: delegate.getReferenceId(fieldValue),
            refType: 'object'
        }
    };
}
function unresolvedModel() {
    return {
        fieldData: {
            type: 'unresolved_model'
        }
    };
}
function mapData(data, prevEncodingResult, delegate) {
    // scan model instances and replace their 'data' with an identity-mapped data
    return lodash_1.default.reduce(data, (accum, item) => {
        const model = delegate.getModelForRootItem(item);
        if (!model) {
            return {
                fieldData: accum.fieldData
            };
        }
        const itemId = delegate.getItemId(item);
        // todo: pass the accumulated hashedData to all children, because we need to remove duplicate fieldPaths from it per strategy when a field has changed (because we might get partial field data)
        // todo: create inverse map to find duplications
        const mappedData = mapObjectFields({
            data: item,
            model: model,
            fieldDataPath: [itemId],
            delegate: delegate
        });
        return {
            fieldData: lodash_1.default.assign(accum.fieldData, { [itemId]: mappedData.fieldData })
        };
    }, {
        fieldData: lodash_1.default.get(prevEncodingResult, 'fieldData', {})
    });
}
function encodeData({ data, prevEncodingResult, delegate }) {
    data = lodash_1.default.cloneDeep(data);
    const mappedData = mapData(data, prevEncodingResult, delegate);
    return {
        fieldData: mappedData.fieldData
    };
}
exports.default = encodeData;
//# sourceMappingURL=encoder.js.map