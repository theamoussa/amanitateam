type Distribute<U> = U extends any ? U[] : never;
export type ReferenceValueType = {
    srcType: string;
    srcProjectId: string;
    srcDocumentId: string;
};
type ValueType = string | number | Date | boolean | ReferenceValueType;
type BaseFilterItem = {
    field: string;
    isMeta?: boolean;
};
type EqualFilterItem = BaseFilterItem & {
    operator: 'eq' | 'neq';
    value: ValueType;
};
type UndefinedFilterItem = BaseFilterItem & {
    operator: 'is-undefined' | 'is-not-undefined';
};
type EmptyFilterItem = BaseFilterItem & {
    operator: 'is-empty' | 'is-not-empty';
};
type CompareFilterItem = BaseFilterItem & {
    operator: 'gte' | 'lte';
    value: ValueType;
};
type IncludeStringFilterItem = BaseFilterItem & {
    operator: 'includes' | 'not-includes';
    value: string;
};
type IncludeListFilterItem = BaseFilterItem & {
    operator: 'in' | 'nin';
    values: Distribute<ValueType>;
};
type IncludeAllFilterItem = BaseFilterItem & {
    operator: 'all';
    values: Distribute<ValueType>;
};
type BetweenFilterItem = BaseFilterItem & {
    operator: 'between';
    startValue: ValueType;
    endValue: ValueType;
};
export type SearchFilterItem = EqualFilterItem | UndefinedFilterItem | CompareFilterItem | IncludeStringFilterItem | IncludeListFilterItem | IncludeAllFilterItem | BetweenFilterItem | EmptyFilterItem;
export type SearchFilterItemGrouped = SearchFilterItem | (LogicalAndOperator | LogicalOrOperator);
export type SearchFilter = LogicalAndOperator | LogicalOrOperator;
type LogicalAndOperator = {
    and: SearchFilterItemGrouped[];
};
type LogicalOrOperator = {
    or: SearchFilterItemGrouped[];
};
export {};
//# sourceMappingURL=search-filter.d.ts.map