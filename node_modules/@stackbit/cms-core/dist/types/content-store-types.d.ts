import * as StackbitTypes from '@stackbit/types';
import { ImageModel, Model } from '@stackbit/sdk';
import { Asset, Document } from './content-store-documents';
import { BackCompatContentSourceInterface } from '../utils/backward-compatibility';
import * as CSITypes from '@stackbit/types';
export type ContentSourceRawData = {
    id: string;
    instance: BackCompatContentSourceInterface;
    destroyed: boolean;
    version: {
        interfaceVersion: string;
        contentSourceVersion: string;
    };
    srcType: string;
    srcProjectId: string;
    locales?: StackbitTypes.Locale[];
    defaultLocaleCode?: string;
    csiSchema: StackbitTypes.Schema;
    csiModels: StackbitTypes.Model[];
    csiModelMap: Record<string, StackbitTypes.Model>;
    csiDocuments: StackbitTypes.Document[];
    csiDocumentMap: Record<string, StackbitTypes.Document>;
    csiAssets: StackbitTypes.Asset[];
    csiAssetMap: Record<string, StackbitTypes.Asset>;
    assets: Asset[];
    assetMap: Record<string, Asset>;
    scheduledActions: StackbitTypes.ScheduledAction[];
    syncContext?: {
        documentsSyncContext?: unknown;
        assetsSyncContext?: unknown;
    };
    enabledFeatures: {
        unpublish: boolean;
        archive: boolean;
        unarchive: boolean;
        scheduledActions: boolean;
        documentVersions: boolean;
        assetsEditing?: boolean;
    };
};
export type ProvisionalData = Pick<ContentSourceRawData, 'srcType' | 'srcProjectId'> & Partial<Pick<ContentSourceRawData, 'syncContext' | 'csiSchema' | 'csiModelMap' | 'csiDocuments' | 'csiDocumentMap' | 'csiAssets' | 'csiAssetMap' | 'scheduledActions'>>;
export type ContentSourceData = ContentSourceRawData & {
    models: Model[];
    modelMap: Record<string, Model>;
    documents: Document[];
    documentMap: Record<string, Document>;
};
export declare const ContentStoreEventType: {
    readonly YamlModelFilesChange: "yamlModelFilesChange";
    readonly PresetFilesChange: "presetFilesChange";
    readonly ContentSourceInvalidateSchema: "contentSourceInvalidateSchema";
    readonly ContentSourceContentChange: "contentSourceContentChange";
    readonly ContentSourceRequestSync: "contentSourceRequestSync";
};
export type ContentStoreEvent = {
    eventName: typeof ContentStoreEventType.YamlModelFilesChange;
} | {
    eventName: typeof ContentStoreEventType.PresetFilesChange;
} | {
    eventName: typeof ContentStoreEventType.ContentSourceInvalidateSchema;
    contentSourceId: string;
} | {
    eventName: typeof ContentStoreEventType.ContentSourceContentChange;
    contentSourceId: string;
    contentChanges: CSITypes.ContentChanges;
} | {
    eventName: typeof ContentStoreEventType.ContentSourceRequestSync;
    contentSourceId: string;
    options: Parameters<CSITypes.Cache['requestSync']>[0];
};
export interface UploadAssetData {
    url: string;
    data?: string;
    metadata: {
        name: string;
        type: string;
    };
}
export type OnFilesChangeResponse = {
    contentChanged?: boolean;
    codeChanged?: boolean;
    contentFiles: string[];
};
export type ContentChangeType = 'added' | 'modified' | 'deleted';
export interface ContentChangeItem {
    srcType: string;
    srcProjectId: string;
    srcObjectId: string;
}
export interface ContentChangeResultItem extends ContentChangeItem {
    type: ContentChangeType;
    srcObjectType: 'document' | 'asset';
}
export interface ContentChangeScheduledAction {
    srcType: string;
    srcProjectId: string;
    scheduledActionId: string;
}
export interface ContentChangeResultScheduledAction extends ContentChangeScheduledAction {
    type: ContentChangeType;
}
export interface ContentChangeResult {
    createdDocuments: ContentChangeItem[];
    createdAssets: ContentChangeItem[];
    createdScheduledActions: ContentChangeScheduledAction[];
    updatedDocuments: ContentChangeItem[];
    updatedAssets: ContentChangeItem[];
    updatedScheduledActions: ContentChangeScheduledAction[];
    deletedDocuments: ContentChangeItem[];
    deletedAssets: ContentChangeItem[];
    deletedScheduledActions: ContentChangeScheduledAction[];
}
export interface User {
    id: string;
    name: string;
    email: string;
    role?: string;
    sso?: StackbitTypes.UserSSOProfile;
    connections: {
        type: string;
        [key: string]: any;
    }[];
}
export interface ValidationError {
    message: string;
    srcType: string;
    srcProjectId: string;
    srcObjectType: string;
    srcObjectId: string;
    fieldPath: (string | number)[];
    isUniqueValidation?: boolean;
}
export interface HasAccessResult {
    hasConnection: boolean;
    hasPermissions: boolean;
    contentSources: {
        srcType: string;
        srcProjectId: string;
        hasConnection: boolean;
        hasPermissions: boolean;
    }[];
}
export interface CrossReferenceData {
    refId: string;
    refSrcType: string;
    refProjectId: string;
}
export interface ContentStoreLocale {
    srcType: string;
    srcProjectId: string;
    locales: string[];
    defaultLocale: string | undefined;
}
export type RecordSchema = Record<string, Record<string, Record<string, Model | ImageModel>>>;
export type FieldFile = StackbitTypes.FieldCommonProps & {
    type: 'assetFile';
};
export type AssetModelField = StackbitTypes.FieldString | StackbitTypes.FieldText | FieldFile;
export type AssetModel = {
    type: 'asset';
    name: '__asset_model';
    label?: string;
    labelField?: string;
    fields?: AssetModelField[];
};
//# sourceMappingURL=content-store-types.d.ts.map