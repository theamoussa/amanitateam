import { Config, Model } from '@stackbit/sdk';
import { FieldType, UpdateOperationCrossReferenceField, UpdateOperationValueField } from '@stackbit/types';
import * as CSITypes from '@stackbit/types';
import * as ContentStoreTypes from './types';
import { BackCompatContentSourceInterface } from './utils/backward-compatibility';
export declare function getContentSourceIdForContentSource(contentSource: BackCompatContentSourceInterface): string;
export declare function getContentSourceId(contentSourceType: string, srcProjectId: string): string;
export declare function getObjectId(srcType: string, srcProjectId: string, srcObjectId: string): string;
export declare function getContentSourceDataByTypeAndProjectIdOrThrow(srcType: string, srcProjectId: string, contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>): ContentStoreTypes.ContentSourceData;
export declare function getContentSourceDataByIdOrThrow(contentSourceId: string, contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>): ContentStoreTypes.ContentSourceData;
export declare function findContentSourcesDataForTypeOrId({ contentSourceDataById, srcType, srcProjectId }: {
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    srcType?: string;
    srcProjectId?: string;
}): ContentStoreTypes.ContentSourceData[];
export declare function getUserContextForSrcTypeThunk(user?: ContentStoreTypes.User): (srcType: string) => {
    name: string;
    email: string;
    role?: string | undefined;
    sso?: CSITypes.UserSSOProfile | undefined;
} | undefined;
export declare function getUserContextForSrcType(srcType: string, user?: ContentStoreTypes.User): CSITypes.User | undefined;
export declare function isDocumentFieldOneOfFieldTypes<T extends FieldType>(documentField: ContentStoreTypes.DocumentField, fieldTypes: ReadonlyArray<T>): documentField is ContentStoreTypes.DocumentFieldForType<T>;
export declare function getDocumentFieldForLocale<Type extends FieldType>(docField: ContentStoreTypes.DocumentFieldForType<Type>, locale?: string): ContentStoreTypes.DocumentFieldNonLocalizedForType<Type> | null;
export declare function groupModelsByContentSource({ models }: {
    models: CSITypes.ModelWithSource[];
}): Record<string, Record<string, Record<string, Model>>>;
export declare function groupDocumentsByContentSource({ documents }: {
    documents: CSITypes.DocumentWithSource[];
}): Record<string, Record<string, CSITypes.Document[]>>;
export declare function getCSIDocumentsAndAssetsFromContentSourceDataByIds(contentSourceData: ContentStoreTypes.ContentSourceData, objects: {
    srcObjectId: string;
}[]): {
    documents: CSITypes.Document[];
    assets: CSITypes.Asset[];
};
export declare function updateOperationValueFieldWithCrossReference(type: 'string' | 'text' | 'json' | 'cross-reference', refObject: ContentStoreTypes.CrossReferenceData): UpdateOperationValueField | UpdateOperationCrossReferenceField;
export declare function isContentChangesEmpty(contentChanges?: CSITypes.ContentChanges): contentChanges is undefined;
export declare function isContentChangeResultEmpty(contentChangeResult: ContentStoreTypes.ContentChangeResult): boolean;
export declare function contentChangeResultCounts(contentChangeResult: ContentStoreTypes.ContentChangeResult): {
    createdDocumentsCount: number;
    createdAssetsCount: number;
    createdScheduledActionsCount: number;
    updatedDocumentsCount: number;
    updatedAssetsCount: number;
    updatedScheduledActionsCount: number;
    deletedDocumentsCount: number;
    deletedAssetsCount: number;
    deletedScheduledActionsCount: number;
};
export declare function getErrorAtLine(dropLastCallStackEntries: number, dropCallStackFunc?: Function): string;
export declare function getCacheDir(stackbitConfig: Config): string;
//# sourceMappingURL=content-store-utils.d.ts.map