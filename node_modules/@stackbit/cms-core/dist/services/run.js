"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommandRunner = exports.runCommand = void 0;
const child_process_1 = __importDefault(require("child_process"));
const utils_1 = require("@stackbit/utils");
function runCommand(command, args, options) {
    if (options?.logger) {
        options.logger.info(`Running command '${command}${args ? ' ' : ''}${args?.join(' ')}'${options?.cwd ? ` in '${options.cwd}'` : ''} ...`);
    }
    const process = child_process_1.default.spawn(command, args, {
        cwd: options?.cwd,
        shell: options?.shell,
        env: options?.env,
        ...(options?.uid ? { uid: options.uid } : {})
    });
    if (options?.logger) {
        (0, utils_1.logProcess)(process, 'run', options.logger);
    }
    return process;
}
exports.runCommand = runCommand;
function getCommandRunner(commandRunnerOptions) {
    return (command, args, options) => {
        const process = runCommand(command, args, {
            ...options,
            uid: options?.uid ?? commandRunnerOptions.uid,
            env: {
                ...commandRunnerOptions.env,
                ...options?.env
            }
        });
        return getProcessPromise(process);
    };
}
exports.getCommandRunner = getCommandRunner;
function getProcessPromise(p) {
    return new Promise((resolve, reject) => {
        let stdout = '';
        let stderr = '';
        p.stdout.on('data', (out) => (stdout += out));
        p.stderr.on('data', (out) => (stderr += out));
        p.on('close', (exitCode) => {
            if (exitCode !== 0) {
                let msg = `Command '${p.spawnargs.join(' ')}' exited with code: ${exitCode},`;
                if (stderr) {
                    msg += `, stderr: ${stderr}`;
                }
                if (stdout) {
                    msg += `, stdout: ${stdout}`;
                }
                reject(new Error(msg));
            }
            else {
                resolve({
                    stdout,
                    stderr
                });
            }
        });
        p.on('error', (err) => {
            let msg = `Command '${p.spawnargs.join(' ')}' failed with error: ${err.message},`;
            if (stderr) {
                msg += `, stderr: ${stderr}`;
            }
            if (stdout) {
                msg += `, stdout: ${stdout}`;
            }
            reject(new Error(msg));
        });
    });
}
//# sourceMappingURL=run.js.map