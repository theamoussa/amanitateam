"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProcessPromise = exports.logProcess = exports.createLogBufferHandler = void 0;
const lodash_1 = __importDefault(require("lodash"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
function createLogBufferHandler(name, logger, { onLog, info = {} } = {}) {
    const lineBuffer = {
        stdout: '',
        stderr: '',
        error: ''
    };
    function logLine(target, line) {
        if (lodash_1.default.isEmpty(lodash_1.default.trim((0, strip_ansi_1.default)(line)))) {
            return;
        }
        if (target === 'stdout') {
            logger.debug(`[${name}]: ${line}`, info);
        }
        else {
            // log.error - too much errors logs generated which are not really errors
            logger.debug(`[${name}]: ${line}`, info);
        }
        lodash_1.default.forEach(onLog, (onLogItem) => {
            if (lodash_1.default.has(onLogItem, 'callback')) {
                const pattern = lodash_1.default.get(onLogItem, 'pattern');
                if (pattern && !pattern.test((0, strip_ansi_1.default)(line))) {
                    return;
                }
                const filterTarget = lodash_1.default.get(onLogItem, 'target', null);
                if (filterTarget && filterTarget !== target) {
                    return;
                }
                onLogItem.callback(name, target, line);
            }
        });
    }
    return {
        // If handler gets unterminated line, save it until we get line ending
        // For example assume data stream has two lines called in following order:
        // handler("hello world\nhow are ")
        // handler("you?\n")
        // First time the handler called, we can output the first line: "hello world".
        // The second line was not terminated so we need to wait until we receive its ending
        // then we can output the full second line: "how are you?"
        handler: (target, data) => {
            const lines = lodash_1.default.split(data, '\n');
            if (lineBuffer[target]) {
                lines[0] = lineBuffer[target] + lines[0];
                lineBuffer[target] = '';
            }
            if (lodash_1.default.last(lines) !== '') {
                lineBuffer[target] = lines.pop();
            }
            lodash_1.default.forEach(lines, (line) => {
                logLine(target, line);
            });
        },
        flush: () => {
            lodash_1.default.forEach(lineBuffer, (line, target) => {
                const logTarget = target;
                logLine(logTarget, line);
                lineBuffer[logTarget] = '';
            });
        }
    };
}
exports.createLogBufferHandler = createLogBufferHandler;
function logProcess(p, name, logger, options) {
    const bufferHandler = createLogBufferHandler(name, logger, options);
    p.stdout.on('data', lodash_1.default.partial(bufferHandler.handler, 'stdout'));
    p.stderr.on('data', lodash_1.default.partial(bufferHandler.handler, 'stderr'));
    p.on('error', (error) => {
        logger.debug(`[${name}] error: ${error.message}`);
    });
    p.on('close', (code) => {
        bufferHandler.flush();
        if (code != 0) {
            logger.debug(`[${name}] closed with code: ${code}`);
        }
    });
    p.on('exit', (code) => {
        bufferHandler.flush();
        if (code != 0) {
            logger.debug(`[${name}] exited with code: ${code}`);
        }
    });
}
exports.logProcess = logProcess;
function getProcessPromise(p) {
    return new Promise((resolve, reject) => {
        let data = '';
        let stderr = '';
        p.stdout.on('data', (out) => (data += out));
        p.stderr.on('data', (out) => (stderr += out));
        p.on('close', (code) => {
            if (code !== 0) {
                reject(new Error(`process exited with code: ${code}, stderr: ${stderr}`));
            }
            else {
                resolve(data);
            }
        });
        p.on('error', (err) => {
            reject(err);
        });
    });
}
exports.getProcessPromise = getProcessPromise;
//# sourceMappingURL=process-utils.js.map