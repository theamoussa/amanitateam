"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModelAndDocumentFieldForLocalizedFieldPath = exports.getDocumentAndModelFieldAtFieldPath = exports.getDocumentFieldAtFieldPath = exports.getModelFieldAtFieldPath = void 0;
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("@stackbit/types");
function getModelFieldAtFieldPath({ document, fieldPath, modelMap, locale }) {
    if (lodash_1.default.isEmpty(fieldPath)) {
        throw new Error('the fieldPath can not be empty');
    }
    const model = modelMap[document.modelName];
    if (!model) {
        throw new Error(`model with name '${document.modelName}' of a document '${document.id}' not found`);
    }
    function getField(docField, modelField, fieldPath) {
        const fieldName = lodash_1.default.head(fieldPath);
        if (typeof fieldName === 'undefined') {
            throw new Error('the first fieldPath item must be string');
        }
        const childFieldPath = lodash_1.default.tail(fieldPath);
        let childDocField;
        let childModelField;
        switch (docField.type) {
            case 'object': {
                const localizedObjectField = (0, types_1.getLocalizedFieldForLocale)(docField, locale);
                if (!localizedObjectField) {
                    throw new Error(`locale for field was not found`);
                }
                childDocField = localizedObjectField.fields[fieldName];
                childModelField = lodash_1.default.find(modelField.fields, (field) => field.name === fieldName);
                if (!childDocField || !childModelField) {
                    throw new Error(`field ${fieldName} doesn't exist`);
                }
                if (childFieldPath.length === 0) {
                    return childModelField;
                }
                return getField(childDocField, childModelField, childFieldPath);
            }
            case 'model': {
                const localizedModelField = (0, types_1.getLocalizedFieldForLocale)(docField, locale);
                if (!localizedModelField) {
                    throw new Error(`locale for field was not found`);
                }
                const modelName = localizedModelField.modelName;
                const childModel = modelMap[modelName];
                if (!childModel) {
                    throw new Error(`model ${modelName} doesn't exist`);
                }
                childModelField = lodash_1.default.find(childModel.fields, (field) => field.name === fieldName);
                childDocField = localizedModelField.fields[fieldName];
                if (!childDocField || !childModelField) {
                    throw new Error(`field ${fieldName} doesn't exist`);
                }
                if (childFieldPath.length === 0) {
                    return childModelField;
                }
                return getField(childDocField, childModelField, childFieldPath);
            }
            case 'list': {
                const localizedListField = (0, types_1.getLocalizedFieldForLocale)(docField, locale);
                if (!localizedListField) {
                    throw new Error(`locale for field was not found`);
                }
                const listItem = localizedListField.items && localizedListField.items[fieldName];
                const listItemsModel = modelField.items;
                if (!listItem || !listItemsModel) {
                    throw new Error(`field ${fieldName} doesn't exist`);
                }
                if (childFieldPath.length === 0) {
                    return listItemsModel;
                }
                if (!Array.isArray(listItemsModel)) {
                    return getField(listItem, listItemsModel, childFieldPath);
                }
                else {
                    const fieldListItems = listItemsModel.find((listItemsModel) => listItemsModel.type === listItem.type);
                    if (!fieldListItems) {
                        throw new Error('cannot find matching field model');
                    }
                    return getField(listItem, fieldListItems, childFieldPath);
                }
            }
            default:
                if (!lodash_1.default.isEmpty(childFieldPath)) {
                    throw new Error('illegal fieldPath');
                }
                return modelField;
        }
    }
    const fieldName = lodash_1.default.head(fieldPath);
    const childFieldPath = lodash_1.default.tail(fieldPath);
    if (typeof fieldName !== 'string') {
        throw new Error('the first fieldPath item must be string');
    }
    const childDocField = document.fields[fieldName];
    const childModelField = lodash_1.default.find(model.fields, { name: fieldName });
    if (!childDocField || !childModelField) {
        throw new Error(`field ${fieldName} doesn't exist`);
    }
    if (childFieldPath.length === 0) {
        return childModelField;
    }
    return getField(childDocField, childModelField, childFieldPath);
}
exports.getModelFieldAtFieldPath = getModelFieldAtFieldPath;
/**
 * This function receives a `document` and returns DocumentFieldNonLocalized at
 * the specified `fieldPath` while resolving any localized fields with the
 * specified `locale`.
 *
 * @example
 * getDocumentFieldAtFieldPath({
 *   document,
 *   locale,
 *   fieldPath: ['sections', 1, 'title']
 * })
 *
 * For improved localization support, use the getModelAndDocumentFieldForLocalizedFieldPath
 * method instead.
 *
 * The `isFullFieldPath` flag specifies if the `fieldPath` includes container
 * specifiers such as "fields" and "items".
 *
 * @example
 * isFullFieldPath: false => fieldPath: ['sections', 1, 'title']
 * isFullFieldPath: true => fieldPath: ['fields', 'sections', 'items', 1, 'fields', 'title']
 */
function getDocumentFieldAtFieldPath({ document, fieldPath, locale, isFullFieldPath }) {
    if (isFullFieldPath) {
        if (lodash_1.default.head(fieldPath) !== 'fields') {
            throw new Error('fieldPath must start with "fields" specifier');
        }
        fieldPath = lodash_1.default.tail(fieldPath);
    }
    if (lodash_1.default.isEmpty(fieldPath)) {
        throw new Error('the fieldPath cannot be empty');
    }
    const docId = document.id;
    const modelName = document.modelName;
    const origFieldPath = fieldPath;
    const origFieldPathStr = fieldPath.join('.');
    function getPrefixOf(fieldPath, include = 0) {
        return origFieldPath.slice(0, origFieldPath.length - fieldPath.length + include).join('.');
    }
    function getField(docField, fieldPath) {
        const localizedField = (0, types_1.getLocalizedFieldForLocale)(docField, locale);
        if (!localizedField) {
            throw new Error(`the value of a field at fieldPath '${getPrefixOf(fieldPath)}' is undefined ` +
                `for the document '${docId}' of type '${modelName}' for the '${locale}' locale.`);
        }
        // if no more items in fieldPath return the found document and model fields
        if (fieldPath.length === 0) {
            return localizedField;
        }
        switch (localizedField.type) {
            case 'object':
            case 'model': {
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'fields') {
                        throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier before a field's name`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const fieldName = lodash_1.default.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${modelName}' must point to a field name`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const childDocField = localizedField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing field in a document '${docId}' of type '${modelName}'`);
                }
                return getField(childDocField, fieldPath);
            }
            case 'list': {
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'items') {
                        throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "items" specifier after a "list" field`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const itemIndex = lodash_1.default.head(fieldPath);
                if (typeof itemIndex === 'undefined') {
                    throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${modelName}' must point to a list item index`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const listItem = localizedField.items && localizedField.items[itemIndex];
                if (!listItem) {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing list item in a document '${docId}' of type '${modelName}'`);
                }
                return getField(listItem, fieldPath);
            }
            default: {
                const primitiveFieldName = origFieldPath[origFieldPath.length - fieldPath.length - 1];
                throw new Error(`the fieldPath '${origFieldPathStr}' is illegal, a primitive field '${primitiveFieldName}' of type '${localizedField.type}' cannot be followed by additional field paths`);
            }
        }
    }
    const fieldName = lodash_1.default.head(fieldPath);
    const restFieldPath = lodash_1.default.tail(fieldPath);
    if (typeof fieldName !== 'string') {
        throw new Error('the first fieldPath item must be string');
    }
    const childDocField = document.fields[fieldName];
    if (!childDocField) {
        throw new Error(`document '${docId}' of type '${modelName}' doesn't have a field named '${fieldName}'`);
    }
    return getField(childDocField, restFieldPath);
}
exports.getDocumentFieldAtFieldPath = getDocumentFieldAtFieldPath;
/**
 * This function receives a `document` and a `modelMap` and returns an object
 * with DocumentFieldNonLocalized and a model Field at the specified `fieldPath`
 * while resolving any localized fields with the specified `locale`.
 *
 * @example
 * getDocumentAndModelFieldAtFieldPath({
 *   document,
 *   locale,
 *   modelMap,
 *   fieldPath: ['sections', 1, 'title']
 * })
 *
 * For improved localization support, use the getModelAndDocumentFieldForLocalizedFieldPath
 * method instead.
 *
 * The `isFullFieldPath` flag specifies if the `fieldPath` includes container
 * specifiers such as "fields" and "items".
 *
 * @example
 * isFullFieldPath: false => fieldPath: ['sections', 1, 'title']
 * isFullFieldPath: true => fieldPath: ['fields', 'sections', 'items', 1, 'fields', 'title']
 */
function getDocumentAndModelFieldAtFieldPath({ document, fieldPath, modelMap, locale, isFullFieldPath }) {
    if (isFullFieldPath) {
        if (lodash_1.default.head(fieldPath) !== 'fields') {
            throw new Error('fieldPath must start with "fields" specifier');
        }
        fieldPath = lodash_1.default.tail(fieldPath);
    }
    if (lodash_1.default.isEmpty(fieldPath)) {
        throw new Error('the fieldPath cannot be empty');
    }
    const docId = document.id;
    const docModelName = document.modelName;
    const origFieldPath = fieldPath;
    const origFieldPathStr = fieldPath.join('.');
    let parentModel = modelMap[docModelName];
    let fieldPathFromParentModel = fieldPath;
    if (!parentModel) {
        throw new Error(`model with name '${docModelName}' of a document '${docId}' not found`);
    }
    function getPrefixOf(fieldPath, include = 0) {
        return origFieldPath.slice(0, origFieldPath.length - fieldPath.length + include).join('.');
    }
    function getModelPrefixOf(fieldPath, include = 0) {
        return fieldPathFromParentModel.slice(0, fieldPathFromParentModel.length - fieldPath.length + include).join('.');
    }
    function getField(docField, modelField, fieldPath) {
        const localizedField = (0, types_1.getLocalizedFieldForLocale)(docField, locale);
        if (!localizedField) {
            throw new Error(`the value of a field at fieldPath '${getPrefixOf(fieldPath)}' is undefined ` +
                `for the document '${docId}' of type '${docModelName}' for the '${locale}' locale.`);
        }
        // if no more items in fieldPath return the found document and model fields
        if (fieldPath.length === 0) {
            return {
                modelField: modelField,
                documentField: localizedField
            };
        }
        switch (localizedField.type) {
            case 'object': {
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'fields') {
                        throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier before a field's name`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const fieldName = lodash_1.default.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' must point to a field name`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const childDocField = localizedField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing field in a document '${docId}' of type '${docModelName}'`);
                }
                if (modelField.type !== 'object') {
                    throw new Error(`model field of type '${modelField.type}' of model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                        `doesn't match document field of type 'object' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`);
                }
                const childModelField = lodash_1.default.find(modelField.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${parentModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'model': {
                fieldPathFromParentModel = fieldPath;
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'fields') {
                        throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier before a field's name`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const fieldName = lodash_1.default.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' must point to a field name`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const childDocField = localizedField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing field in a document '${docId}' of type '${docModelName}'`);
                }
                const modelName = localizedField.modelName;
                const childModel = modelMap[modelName];
                if (!childModel) {
                    throw new Error(`the "model" field at path '${getPrefixOf(fieldPath)}' of a document '${docId}' of type '${docModelName}' ` +
                        `contains an object with type of non existing model '${modelName}'`);
                }
                parentModel = childModel;
                const childModelField = lodash_1.default.find(childModel.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${childModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'list': {
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'items') {
                        throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "items" specifier before a list item index`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const itemIndex = lodash_1.default.head(fieldPath);
                if (typeof itemIndex === 'undefined') {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath, 1)}' of a document '${docId}' of type '${docModelName}' must point to a list item index`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const listItem = localizedField.items && localizedField.items[itemIndex];
                if (!listItem) {
                    throw new Error(`the fieldPath '${getPrefixOf(fieldPath)}' points to a non existing list item in a document '${docId}' of type '${docModelName}'`);
                }
                if (modelField.type !== 'list') {
                    throw new Error(`model field of type '${modelField.type}' of model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                        `doesn't match document field of type 'list' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`);
                }
                const listItemsModel = modelField.items;
                if (!Array.isArray(listItemsModel)) {
                    return getField(listItem, listItemsModel, fieldPath);
                }
                else {
                    const fieldListItems = listItemsModel.find((listItemsModel) => listItemsModel.type === listItem.type);
                    if (!fieldListItems) {
                        throw new Error(`cannot find list item model for list item of type '${listItem.type}' for model '${parentModel.name}' ` +
                            `at field path '${getModelPrefixOf(fieldPath)}'`);
                    }
                    return getField(listItem, fieldListItems, fieldPath);
                }
            }
            default: {
                const primitiveFieldName = origFieldPath[origFieldPath.length - fieldPath.length - 1];
                throw new Error(`the fieldPath '${origFieldPathStr}' is illegal, a primitive field '${primitiveFieldName}' of type '${localizedField.type}' cannot be followed by additional field paths`);
            }
        }
    }
    const fieldName = lodash_1.default.head(fieldPath);
    const restFieldPath = lodash_1.default.tail(fieldPath);
    if (typeof fieldName !== 'string') {
        throw new Error('the first fieldPath item must be string');
    }
    const childDocField = document.fields[fieldName];
    if (!childDocField) {
        throw new Error(`document '${docId}' of type '${docModelName}' doesn't have a field named '${fieldName}'`);
    }
    const childModelField = lodash_1.default.find(parentModel.fields, { name: fieldName });
    if (!childModelField) {
        throw new Error(`model '${docModelName}' doesn't have a field named '${fieldName}'`);
    }
    return getField(childDocField, childModelField, restFieldPath);
}
exports.getDocumentAndModelFieldAtFieldPath = getDocumentAndModelFieldAtFieldPath;
/**
 * This function receives a `document` and a `modelMap` and returns an object
 * with DocumentField and a model Field at the specified `fieldPath`.
 *
 * If some fields along the fieldPath are localized, the `fieldPath` must
 * contain the locale of the field under the "locales" property. The locales
 * along the field path don't have to be the same.
 *
 * @example
 * fieldPath: ['fields', 'button', 'locales', 'en', 'fields', 'title', 'locales', 'es']
 *
 * If the provided `fieldPath` points to a list item, the returned model field
 * and document field will belong to a list item. In this case, the model field
 * will contain only field-specific properties and the document field will be
 * localized.
 *
 * @example
 * fieldPath: ['fields', 'buttons', 'items', 2]
 *
 * The `isFullFieldPath` flag specifies if the `fieldPath` includes container
 * specifiers such as "fields" and "items".
 *
 * @example
 * isFullFieldPath: false => fieldPath: ['sections', 1, 'title', 'es']
 * isFullFieldPath: true => fieldPath: ['fields', 'sections', 'items', 1, 'fields', 'title', 'locales', 'es']
 */
function getModelAndDocumentFieldForLocalizedFieldPath({ document, fieldPath, modelMap, isFullFieldPath }) {
    if (isFullFieldPath) {
        if (lodash_1.default.head(fieldPath) !== 'fields') {
            throw new Error('fieldPath must start with "fields" specifier');
        }
        fieldPath = lodash_1.default.tail(fieldPath);
    }
    if (lodash_1.default.isEmpty(fieldPath)) {
        throw new Error('the fieldPath cannot be empty');
    }
    const docId = document.id;
    const origModelName = document.modelName;
    const origFieldPath = fieldPath;
    const origFieldPathStr = fieldPath.join('.');
    const model = modelMap[origModelName];
    if (!model) {
        throw new Error(`model with name '${origModelName}' of a document '${docId}' not found`);
    }
    let parentModel = model;
    let fieldPathFromParentModel = fieldPath;
    function getPrefixOf(fieldPath, include = 0) {
        return origFieldPath.slice(0, origFieldPath.length - fieldPath.length + include).join('.');
    }
    function getModelPrefixOf(fieldPath, include = 0) {
        return fieldPathFromParentModel.slice(0, fieldPathFromParentModel.length - fieldPath.length + include).join('.');
    }
    function getField(docField, modelField, fieldPath) {
        // if no more items in fieldPath return the found document and model fields
        if (fieldPath.length === 0) {
            return {
                modelField: modelField,
                documentField: docField
            };
        }
        if (docField.localized) {
            if (isFullFieldPath) {
                if (lodash_1.default.head(fieldPath) !== 'locales') {
                    throw new Error(`fieldPath '${origFieldPath.join('.')}' must contain "locales" specifier for localized field`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
            }
            const locale = lodash_1.default.head(fieldPath);
            if (typeof locale !== 'string') {
                throw new Error(`the locale specifier must be string in fieldPath '${origFieldPath.join('.')}'`);
            }
            fieldPath = lodash_1.default.tail(fieldPath);
            const localizedDocField = (0, types_1.getLocalizedFieldForLocale)(docField, locale);
            if (!localizedDocField) {
                if (!fieldPath.length) {
                    // field locale is not set
                    return { modelField, documentField: undefined };
                }
                throw new Error(`fieldPath '${origFieldPath.join('.')}' doesn't specify the locale`);
            }
            docField = localizedDocField;
        }
        switch (docField.type) {
            case 'object': {
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'fields') {
                        throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier after an "object" field`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const fieldName = lodash_1.default.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must specify a field name for an "object" field`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const childDocField = docField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(`document '${docId}' of type '${origModelName}' doesn't have a field at path: '${getPrefixOf(fieldPath)}'`);
                }
                if (modelField.type !== 'object') {
                    throw new Error(`model field of type '${modelField.type}' of model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                        `doesn't match document field of type 'object' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`);
                }
                const childModelField = lodash_1.default.find(modelField.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${parentModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'model': {
                fieldPathFromParentModel = fieldPath;
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'fields') {
                        throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "fields" specifier after a "model" field`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const fieldName = lodash_1.default.head(fieldPath);
                if (typeof fieldName === 'undefined') {
                    throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must specify a field name for an "model" field`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const modelName = docField.modelName;
                const childModel = modelMap[modelName];
                if (!childModel) {
                    throw new Error(`a "model" field of a document '${docId}' at path '${getPrefixOf(fieldPath)}' ` +
                        `contains an object with non existing modelName '${modelName}'`);
                }
                parentModel = childModel;
                const childDocField = docField.fields[fieldName];
                if (!childDocField) {
                    throw new Error(`document '${docId}' of type '${origModelName}' doesn't have a field at path: '${getPrefixOf(fieldPath)}'`);
                }
                const childModelField = lodash_1.default.find(childModel.fields, (field) => field.name === fieldName);
                if (!childModelField) {
                    throw new Error(`model '${childModel.name}' doesn't have a field at path: '${getModelPrefixOf(fieldPath)}'`);
                }
                return getField(childDocField, childModelField, fieldPath);
            }
            case 'list': {
                if (isFullFieldPath) {
                    if (lodash_1.default.head(fieldPath) !== 'items') {
                        throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must contain "items" specifier after a "list" field`);
                    }
                    fieldPath = lodash_1.default.tail(fieldPath);
                }
                const itemIndex = lodash_1.default.head(fieldPath);
                if (typeof itemIndex === 'undefined') {
                    throw new Error(`fieldPath '${getPrefixOf(fieldPath, 1)}' must specify a list item index for a "list" field`);
                }
                fieldPath = lodash_1.default.tail(fieldPath);
                const listItem = docField.items && docField.items[itemIndex];
                if (!listItem) {
                    throw new Error(`document '${docId}' of type '${origModelName}' doesn't have a list item at path: '${getPrefixOf(fieldPath)}'`);
                }
                if (modelField.type !== 'list') {
                    throw new Error(`model field type '${modelField.type}' of a model '${parentModel.name}' at field path '${getModelPrefixOf(fieldPath)}' ` +
                        `doesn't match document field of type 'list' of document '${docId}' at field path '${getPrefixOf(fieldPath)}'`);
                }
                const listItemsModel = modelField.items;
                if (!Array.isArray(listItemsModel)) {
                    return getField(listItem, listItemsModel, fieldPath);
                }
                else {
                    const fieldListItems = listItemsModel.find((listItemsModel) => listItemsModel.type === listItem.type);
                    if (!fieldListItems) {
                        throw new Error(`cannot find list item model for document list item of type '${listItem.type}' for model '${parentModel.name}' ` +
                            `at field path '${getModelPrefixOf(fieldPath, 1)}'`);
                    }
                    return getField(listItem, fieldListItems, fieldPath);
                }
            }
            default:
                if (!lodash_1.default.isEmpty(fieldPath)) {
                    throw new Error(`illegal fieldPath, a primitive field of type '${docField.type}' was found in the middle of the fieldPath '${origFieldPathStr}'`);
                }
                return {
                    modelField,
                    documentField: docField
                };
        }
    }
    const fieldName = lodash_1.default.head(fieldPath);
    const childFieldPath = lodash_1.default.tail(fieldPath);
    if (typeof fieldName !== 'string') {
        throw new Error('the first fieldPath item must be string');
    }
    const childDocField = document.fields[fieldName];
    const childModelField = lodash_1.default.find(model.fields, { name: fieldName });
    if (!childDocField) {
        throw new Error(`document '${docId}' of type '${model.name}' doesn't have a field named '${fieldName}'`);
    }
    if (!childModelField) {
        throw new Error(`model '${model.name}' doesn't have a field named '${fieldName}'`);
    }
    return getField(childDocField, childModelField, childFieldPath);
}
exports.getModelAndDocumentFieldForLocalizedFieldPath = getModelAndDocumentFieldForLocalizedFieldPath;
//# sourceMappingURL=field-path-utils.js.map