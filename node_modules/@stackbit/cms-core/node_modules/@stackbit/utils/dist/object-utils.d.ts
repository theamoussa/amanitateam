import { PropertyPath } from 'lodash';
/**
 * Gets the value at the first path of object having non undefined value.
 * If all paths resolve to undefined values, the defaultValue is returned.
 *
 * @param object
 * @param paths
 * @param defaultValue
 */
export declare function getFirst(object: any, paths: PropertyPath, defaultValue?: any): any;
/**
 * Appends the `value` to the end of the array located at the specified `path` in
 * the provided `object`. If array at the specified `path` doesn't exist, the
 * function creates a new array with a single `value` item.
 *
 * @param object
 * @param path
 * @param value
 */
export declare function append(object: any, path: PropertyPath, value: any): void;
/**
 * Prepends the `value` to the beginning of the array located at the specified
 * `path` in the provided `object`. If array at the specified `path` doesn't
 * exist, the function creates a new array with a single `value` item.
 *
 * @param object
 * @param path
 * @param value
 */
export declare function prepend(object: any, path: PropertyPath, value: any): void;
/**
 * Concatenates the `value` with an array located at the specified `path` in the
 * provided `object`. If array at the specified `path` doesn't exist, the
 * function creates a new array and concatenates it with `value`.
 *
 * @param object
 * @param path
 * @param value
 */
export declare function concat(object: any, path: PropertyPath, value: any): void;
/**
 * Copies the value from the `sourceObject` at the specified `sourcePath` to
 * the `targetObject` at the specified `targetPath`, optionally transforming the
 * value using the `transform` function.
 *
 * If `sourcePath` resolves to `undefined`, this method does nothing.
 *
 * @param sourceObject
 * @param sourcePath
 * @param targetObject
 * @param targetPath
 * @param transform
 */
export declare function copy(sourceObject: any, sourcePath: PropertyPath, targetObject: any, targetPath: PropertyPath, transform?: (value: any) => any): void;
/**
 * Copies the value from the `sourceObject` at the specified `sourcePath` to
 * the `targetObject` at the specified `targetPath`.
 *
 * If `targetPath` resolves to `undefined`, this method does nothing.
 * If `sourcePath` resolves to `undefined`, this method does nothing.
 *
 * Optionally transform the value using the `transform` function.
 *
 * @param sourceObject
 * @param sourcePath
 * @param targetObject
 * @param targetPath
 * @param transform
 */
export declare function copyIfNotSet(sourceObject: any, sourcePath: PropertyPath, targetObject: any, targetPath: PropertyPath, transform?: (value: any) => any): void;
/**
 * Renames `oldPath` to a `newPath`.
 *
 * @param object
 * @param oldPath
 * @param newPath
 */
export declare function rename(object: any, oldPath: PropertyPath, newPath: PropertyPath): void;
/**
 * Removed all null and undefined properties from the passed object
 * @param object
 */
export declare function omitByNil<T extends Record<string, any>>(object: T): T;
export declare function omitByUndefined<T extends Record<string, any>>(object: T): T;
export declare function undefinedIfEmpty<T extends Record<string, any> | any[]>(value: T): T | undefined;
export type KeyPath = (string | number)[];
/**
 * Creates an object with the same keys as `object` and values generated by
 * recursively running each own enumerable string keyed property of `object` through
 * `iteratee`.
 *
 * @param {any} object
 * @param {Function} iteratee
 * @param [options]
 * @param {boolean} [options.context] The value of `this` provided for the call to `iteratee`. Default: undefined
 * @param {boolean} [options.iterateCollections] Should the `iteratee` be called for collections. Default: true
 * @param {boolean} [options.iteratePrimitives] Should the `iteratee` be called for primitives. Default: true
 * @param {boolean} [options.includeKeyPath] Should the `iteratee` be called with `keyPath` parameter. Default: true
 */
export declare function deepMap<T>(object: T, iteratee: (value: any, object: T) => any, options: {
    context?: any;
    iterateCollections?: boolean;
    iteratePrimitives?: boolean;
    includeKeyPath: false;
}): any;
export declare function deepMap<T>(object: T, iteratee: (value: any, keyPath: KeyPath, mappedValueStack: any[], object: T) => any, options?: {
    context?: any;
    iterateCollections?: boolean;
    iteratePrimitives?: boolean;
    includeKeyPath?: true;
}): any;
export declare function asyncMapDeep(value: any, iteratee: (options: {
    value: any;
    keyPath: (string | number)[];
    stack: any[];
    skipNested: () => void;
}) => Promise<any>, options?: {
    postOrder?: boolean;
    iterateCollections?: boolean;
    iteratePrimitives?: boolean;
    iterateScalars?: boolean;
    context?: any;
}): Promise<any>;
//# sourceMappingURL=object-utils.d.ts.map