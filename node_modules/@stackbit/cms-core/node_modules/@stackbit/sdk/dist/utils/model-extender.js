"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendModelMap = exports.extendModelArray = void 0;
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@stackbit/utils");
const config_errors_1 = require("../config/config-errors");
function extendModelArray(models) {
    const memorized = lodash_1.default.memoize(extendModel, (model, modelName) => modelName);
    const modelsByName = lodash_1.default.keyBy(models, 'name');
    return lodash_1.default.reduce(models, (result, model) => {
        // YamlModel is the same as Model just without 'name' and '__metadata' properties
        const { model: extendedModel, errors } = memorized(model, model.name, modelsByName);
        return {
            models: result.models.concat(extendedModel),
            errors: result.errors.concat(errors)
        };
    }, { models: [], errors: [] });
}
exports.extendModelArray = extendModelArray;
function extendModelMap(models) {
    const memorized = lodash_1.default.memoize(extendModel, (model, modelName) => modelName);
    return lodash_1.default.reduce(models, (result, model, modelName) => {
        const { model: extendedModel, errors } = memorized(model, modelName, models);
        return {
            models: lodash_1.default.assign(result.models, { [modelName]: extendedModel }),
            errors: result.errors.concat(errors)
        };
    }, { models: {}, errors: [] });
}
exports.extendModelMap = extendModelMap;
function extendModel(model, modelName, modelsByName, _extendPath = []) {
    if (lodash_1.default.includes(_extendPath, modelName)) {
        return {
            model,
            errors: [
                new config_errors_1.ConfigValidationError({
                    type: 'model.extends.circular',
                    message: `cyclic dependency detected in model extend tree: ${_extendPath.join(' -> ')} -> ${modelName}`,
                    fieldPath: [],
                    value: null
                })
            ]
        };
    }
    let _extends = lodash_1.default.get(model, 'extends');
    let fields = lodash_1.default.get(model, 'fields');
    if (!_extends) {
        return { model, errors: [] };
    }
    lodash_1.default.unset(model, 'extends');
    if (!lodash_1.default.isArray(_extends)) {
        _extends = [_extends];
    }
    if (!fields) {
        fields = [];
        model.fields = fields;
    }
    let errors = [];
    lodash_1.default.forEach(_extends, (superModelName) => {
        const superModel = lodash_1.default.get(modelsByName, superModelName);
        if (!superModel) {
            errors.push(new config_errors_1.ConfigValidationError({
                type: 'model.extends.model.not.found',
                message: `model '${modelName}' extends non existing model '${superModelName}'`,
                fieldPath: [],
                value: null
            }));
            return;
        }
        const { model: extendedSuperModel, errors: nestedErrors } = extendModel(superModel, superModelName, modelsByName, _extendPath.concat(modelName));
        errors = errors.concat(nestedErrors);
        (0, utils_1.copyIfNotSet)(extendedSuperModel, 'hideContent', model, 'hideContent');
        (0, utils_1.copyIfNotSet)(extendedSuperModel, 'singleInstance', model, 'singleInstance');
        (0, utils_1.copyIfNotSet)(extendedSuperModel, 'labelField', model, 'labelField');
        (0, utils_1.copyIfNotSet)(extendedSuperModel, 'variantField', model, 'variantField');
        if (Array.isArray(extendedSuperModel.fieldGroups) && extendedSuperModel.fieldGroups.length > 0) {
            lodash_1.default.set(model, 'fieldGroups', lodash_1.default.uniqBy(lodash_1.default.concat(extendedSuperModel.fieldGroups, lodash_1.default.get(model, 'fieldGroups', [])), 'name'));
        }
        let idx = 0;
        lodash_1.default.forEach(extendedSuperModel.fields, (superField) => {
            const field = lodash_1.default.find(fields, { name: superField.name });
            superField = lodash_1.default.cloneDeep(superField);
            if (field) {
                lodash_1.default.defaults(field, superField);
            }
            else {
                fields.splice(idx++, 0, superField);
            }
        });
    });
    return { model, errors };
}
//# sourceMappingURL=model-extender.js.map