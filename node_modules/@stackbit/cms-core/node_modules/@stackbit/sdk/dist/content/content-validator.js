"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateContentItems = void 0;
const joi_1 = __importDefault(require("joi"));
const lodash_1 = __importDefault(require("lodash"));
const content_schema_1 = require("./content-schema");
const content_errors_1 = require("./content-errors");
const utils_1 = require("../utils");
function validateContentItems({ contentItems, config }) {
    const errors = [];
    const joiModelSchemas = (0, content_schema_1.joiSchemasForModels)(config);
    const value = lodash_1.default.map(contentItems, (contentItem) => {
        const modelName = contentItem.__metadata?.modelName;
        if (!modelName) {
            return contentItem;
        }
        let modelSchema = joiModelSchemas[modelName];
        if (!modelSchema) {
            return contentItem;
        }
        const validationOptions = {
            abortEarly: false,
            context: {
                filePath: contentItem.__metadata.filePath
            }
        };
        const model = (0, utils_1.getModelByName)(config.models, modelName);
        if (model) {
            if ((0, utils_1.isConfigModel)(model)) {
                if (config.ssgName === 'unibit') {
                    // in Unibit, config model defines the model of the params
                    modelSchema = joi_1.default.object({ params: modelSchema });
                }
                // in config models allow skip root fields
                modelSchema = modelSchema.unknown();
            }
            else if ((0, utils_1.isPageModel)(model) && model.layout) {
                const pageLayoutKey = config.pageLayoutKey || 'layout';
                if (!lodash_1.default.find(model.fields, { name: pageLayoutKey })) {
                    modelSchema = modelSchema.keys({ [pageLayoutKey]: joi_1.default.string().valid(model.layout) });
                }
            }
            else if ((0, utils_1.isDataModel)(model) && !(0, utils_1.isListDataModel)(model)) {
                const objectTypeKey = config.objectTypeKey || 'type';
                if (!lodash_1.default.find(model.fields, { name: objectTypeKey })) {
                    modelSchema = modelSchema.keys({ [objectTypeKey]: joi_1.default.string().valid(model.name) });
                }
            }
            modelSchema = modelSchema.keys({
                __metadata: joi_1.default.object({
                    filePath: joi_1.default.string().required(),
                    modelName: joi_1.default.string().valid(model.name).required()
                }).required()
            });
        }
        const validationResult = modelSchema.validate(contentItem, validationOptions);
        const validationErrors = validationResult.error?.details.map((validationError) => {
            return new content_errors_1.ContentValidationError({
                type: validationError.type,
                message: validationError.message,
                fieldPath: validationError.path,
                modelName: modelName,
                value: validationError.context?.value,
                filePath: contentItem.__metadata.filePath
            });
        });
        if (validationErrors) {
            errors.push(...validationErrors);
        }
        return validationResult.value;
    });
    const valid = lodash_1.default.isEmpty(errors);
    return {
        valid,
        value,
        errors
    };
}
exports.validateContentItems = validateContentItems;
//# sourceMappingURL=content-validator.js.map