"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
let taskTagCounter = 0;
class Task {
    constructor(job, tag) {
        this.tag = tag !== null && tag !== void 0 ? tag : 'task-' + taskTagCounter++;
        this.promise = new Promise((resolve, reject) => {
            this.run = function () {
                return job().then(resolve, reject);
            };
        });
    }
}
class TaskQueue {
    constructor(options) {
        var _a, _b, _c;
        const limit = (_a = options === null || options === void 0 ? void 0 : options.limit) !== null && _a !== void 0 ? _a : null;
        const interval = (_b = options === null || options === void 0 ? void 0 : options.interval) !== null && _b !== void 0 ? _b : null;
        this.debug = (_c = options === null || options === void 0 ? void 0 : options.debug) !== null && _c !== void 0 ? _c : false;
        this.runCount = 0;
        this.lastRunTime = null;
        this.timeout = null;
        this.taskQueue = [];
        if (interval) {
            this._runTask = this._runTaskInterval.bind(this, this._runTask.bind(this), interval);
        }
        if (limit) {
            this._runTask = this._runTaskLimit.bind(this, this._runTask.bind(this), limit);
        }
    }
    addTask(job, tag) {
        let task = new Task(job, tag);
        this.taskQueue.push(task);
        if (this.debug) {
            console.log(`[TaskQueue] submitted task to queue, task: ${task.tag}, queue size: ${this.taskQueue.length}, running tasks: ${this.runCount}`);
        }
        this._executeNextTask();
        return task.promise;
    }
    clearQueue() {
        this.taskQueue = [];
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }
    _executeNextTask() {
        if (this.taskQueue.length > 0) {
            this._runTask();
        }
    }
    _runTaskLimit(runTask, limit) {
        if (this.runCount < limit) {
            runTask();
        }
        if (this.debug) {
            console.log(`[TaskQueue] task run count limit (${limit}) reached, queue size: ${this.taskQueue.length}, ` +
                `running tasks: ${this.runCount}, waiting for previous tasks to finish`);
        }
    }
    _runTaskInterval(runTask, interval) {
        if (!this.lastRunTime) {
            // if this is a first task, run it immediately
            runTask();
        }
        else if (!this.timeout) {
            // if there is no timeout, check if the time from last run is greater
            // than the allowed interval and run the task, otherwise set a timeout
            // to run the task at the right interval
            let diff = process.hrtime(this.lastRunTime);
            let diffMs = diff[0] * 1000 + diff[1] / 1000000;
            if (diffMs >= interval) {
                runTask();
            }
            else {
                this.timeout = setTimeout(runTask, interval - diffMs);
                if (this.debug) {
                    console.log(`[TaskQueue] task interval is less than allowed (${interval}) reached, queue size: ` +
                        `${this.taskQueue.length}, running tasks: ${this.runCount}, waiting for ${interval - diffMs}ms`);
                }
            }
        }
        // If the timeout already set, then the next call to _runTask will call
        // _executeNextTask at the end and will set a new timeout for the
        // following task.
    }
    _runTask() {
        // _runTask is called from _executeNextTask only when the task queue is
        // not empty, and timeout is set only when there is at least one task.
        const task = this.taskQueue.shift();
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        this.runCount += 1;
        this.lastRunTime = process.hrtime();
        if (this.debug) {
            console.log(`[TaskQueue] running task: ${task.tag}, queue size: ${this.taskQueue.length}, running tasks: ${this.runCount}`);
        }
        task.run().then(() => {
            this.runCount -= 1;
            if (this.debug) {
                console.log(`[TaskQueue] finished running task: ${task.tag}, queue size: ${this.taskQueue.length}, running tasks: ${this.runCount}`);
            }
            this._executeNextTask();
        });
        this._executeNextTask();
    }
}
exports.default = TaskQueue;
;
//# sourceMappingURL=task-queue.js.map